
Camera_TFT.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001a2  00800100  00001798  0000182c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001798  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000f  008002a2  008002a2  000019ce  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  000019d0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  0000209c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  00002128  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002c31  00000000  00000000  00002288  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b09  00000000  00000000  00004eb9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001174  00000000  00000000  000059c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006c0  00000000  00000000  00006b38  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007d3  00000000  00000000  000071f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000021a4  00000000  00000000  000079cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000090  00000000  00000000  00009b6f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e5 01 	jmp	0x3ca	; 0x3ca <__ctors_end>
       4:	0c 94 36 09 	jmp	0x126c	; 0x126c <__vector_1>
       8:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
       c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      10:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      14:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      18:	0c 94 04 02 	jmp	0x408	; 0x408 <__vector_6>
      1c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      20:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      24:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      28:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      2c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      30:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      34:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      38:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      3c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      40:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      44:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      48:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      4c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      50:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      54:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      58:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      5c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      60:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      64:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      68:	0c 94 e3 0a 	jmp	0x15c6	; 0x15c6 <__vector_26>
      6c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      70:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      74:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      78:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>

0000007c <Verdana_font_11>:
      7c:	00 0b 09 21 5f 3b 00 01 00 04 00 0b 00 10 00 1a     ...!_;..........
      8c:	00 21 00 22 00 25 00 28 00 2d 00 34 00 36 00 39     .!.".%.(.-.4.6.9
      9c:	00 3a 00 3f 00 44 00 49 00 4e 00 53 00 59 00 5e     .:.?.D.I.N.S.Y.^
      ac:	00 63 00 68 00 6d 00 72 00 73 00 75 00 7b 00 82     .c.h.m.r.s.u.{..
      bc:	00 88 00 8c 00 94 00 9a 00 a0 00 a7 00 ae 00 b3     ................
      cc:	00 b8 00 bf 00 c5 00 c8 00 cc 00 d2 00 d7 00 de     ................
      dc:	00 e4 00 eb 00 f0 00 f7 00 fd 01 03 01 0a 01 10     ................
      ec:	01 16 01 1f 01 25 01 2c 01 32 01 35 01 3a 01 3d     .....%.,.2.5.:.=
      fc:	01 44 01 4b 01 4d 01 52 01 57 01 5c 01 61 01 66     .D.K.M.R.W.\.a.f
     10c:	01 6a 01 6f 01 74 01 75 01 78 01 7d 01 7e 01 87     .j.o.t.u.x.}.~..
     11c:	01 8c 01 91 01 96 01 9b 01 9f 01 a3 01 a7 01 ac     ................
     12c:	01 b1 01 b8 01 bd 01 c2 01 c6 01 cb 01 cc 01 d1     ................
     13c:	01 d8 01 d8 50 04 00 00 4c 20 00 02 00 00 00 00     ....P...L ......
	...
     164:	00 00 3c 38 00 10 20 00 80 c1 09 84 00 00 00 00     ..<8.. .........
     174:	00 00 00 00 00 7c 00 d1 44 62 18 52 a8 00 02 e2     .....|..Db.R....
     184:	39 c1 7c df 73 80 00 00 e3 e3 3c 3d f3 ff 3d 0f     9.|.s.....<=..=.
     194:	78 61 8f 13 9e 39 e3 df e1 86 23 0c 1f e4 08 80     xa...9....#.....
     1a4:	08 20 00 81 01 00 84 00 00 00 00 08 00 00 00 00     . ..............
     1b4:	92 00 d1 4f 92 24 52 70 80 05 1e 46 23 41 01 8c     ...O.$Rp...F#A..
     1c4:	40 00 00 14 13 22 43 0a 10 43 0a 18 a1 8f 14 51     @...."C..C.....Q
     1d4:	45 14 22 21 86 23 0a 20 62 09 40 00 20 00 81 01     E."!.#. b.@. ...
     1e4:	00 84 00 00 00 00 08 00 00 00 00 92 00 87 f4 94     ................
     1f4:	24 21 a8 80 05 12 04 25 42 02 8c 68 60 30 19 d4     $!.....%B..h`0..
     204:	a2 81 06 10 81 0a 19 21 56 98 31 83 14 02 21 85     .......!V.1...!.
     214:	54 91 40 a2 0a 20 03 bc e7 bb df eb 8f dd e7 79     T.@.. .........y
     224:	f6 ff 18 c9 8c 7c 92 00 82 94 64 19 21 20 80 09     .....|....d.! ..
     234:	12 08 c9 7b c2 74 69 9f cc 2a 54 be 81 07 fe 81     ...{.ti..*T.....
     244:	fa 1a 21 56 98 31 83 13 02 21 49 54 60 81 21 0c     ..!V.1...!IT`.!.
     254:	10 00 63 18 c5 23 19 96 23 18 c6 39 09 18 c9 52     ..c..#..#..9...R
     264:	84 92 31 82 8e 09 a5 21 07 f3 89 12 10 31 06 24     ..1....!.....1.$
     274:	8b c6 00 03 4a 54 a1 81 06 10 8f 0a 1e 21 26 58     ....JT.......!&X
     284:	3e 83 e0 c2 21 49 54 60 82 21 08 00 03 e3 08 fd     >...!IT`.!......
     294:	23 19 a6 23 18 c6 31 89 15 55 22 8b 11 c9 8f c5     #..#..1..U".....
     2a4:	0a 62 21 00 80 11 12 20 3f 86 24 88 41 9f cc 4a     .b!.... ?.$.A..J
     2b4:	5f e1 81 06 10 83 0a 19 21 26 58 30 83 20 22 21     _.......!&X0. "!
     2c4:	49 54 90 84 20 88 00 04 63 08 c1 23 19 e6 23 18     IT.. ...c..#..#.
     2d4:	c6 30 69 15 55 22 90 92 46 05 05 12 63 21 00 84     .0i.U"..F...c!..
     2e4:	51 12 42 21 46 28 88 a8 60 30 09 a8 61 43 0a 10     Q.B!F(..`0..aC..
     2f4:	43 0a 18 a1 06 34 50 45 14 22 21 30 89 08 88 20     C....4PE."!0... 
     304:	88 00 04 63 18 c5 23 19 96 23 18 c6 30 29 12 22     ...c..#..#..0)."
     314:	51 20 92 00 85 1e 11 9c 92 00 84 60 ef fd c1 39     Q .........`...9
     324:	c8 73 28 00 00 44 08 7e 3d f3 f0 3d 0f e8 7f 06     .s(..D.~=..=....
     334:	33 90 39 0b c2 1e 30 89 08 8f e0 48 00 03 fc e7     3.9...0....H....
     344:	b9 1f 19 8e 23 17 79 f1 c6 f2 22 89 3c 92 00 00     ....#.y...".<...
     354:	04 00 00 12 00 04 20 00 00 00 00 00 00 08 00 00     ...... .........
     364:	03 c0 00 00 00 00 00 00 00 00 00 00 00 08 00 00     ................
     374:	00 00 00 00 00 20 48 00 00 00 00 00 02 01 00 00     ..... H.........
     384:	00 40 20 00 00 00 01 00 92 00 00 04 00 00 0c 00     .@ .............
     394:	08 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00     ................
	...
     3ac:	06 00 00 00 00 00 00 00 38 38 0f e0 00 00 00 1c     ........88......
     3bc:	06 00 00 00 40 20 00 00 00 02 00 7c 00 00           ....@ .....|..

000003ca <__ctors_end>:
     3ca:	11 24       	eor	r1, r1
     3cc:	1f be       	out	0x3f, r1	; 63
     3ce:	cf ef       	ldi	r28, 0xFF	; 255
     3d0:	d0 e1       	ldi	r29, 0x10	; 16
     3d2:	de bf       	out	0x3e, r29	; 62
     3d4:	cd bf       	out	0x3d, r28	; 61

000003d6 <__do_copy_data>:
     3d6:	12 e0       	ldi	r17, 0x02	; 2
     3d8:	a0 e0       	ldi	r26, 0x00	; 0
     3da:	b1 e0       	ldi	r27, 0x01	; 1
     3dc:	e8 e9       	ldi	r30, 0x98	; 152
     3de:	f7 e1       	ldi	r31, 0x17	; 23
     3e0:	02 c0       	rjmp	.+4      	; 0x3e6 <__do_copy_data+0x10>
     3e2:	05 90       	lpm	r0, Z+
     3e4:	0d 92       	st	X+, r0
     3e6:	a2 3a       	cpi	r26, 0xA2	; 162
     3e8:	b1 07       	cpc	r27, r17
     3ea:	d9 f7       	brne	.-10     	; 0x3e2 <__do_copy_data+0xc>

000003ec <__do_clear_bss>:
     3ec:	12 e0       	ldi	r17, 0x02	; 2
     3ee:	a2 ea       	ldi	r26, 0xA2	; 162
     3f0:	b2 e0       	ldi	r27, 0x02	; 2
     3f2:	01 c0       	rjmp	.+2      	; 0x3f6 <.do_clear_bss_start>

000003f4 <.do_clear_bss_loop>:
     3f4:	1d 92       	st	X+, r1

000003f6 <.do_clear_bss_start>:
     3f6:	a1 3b       	cpi	r26, 0xB1	; 177
     3f8:	b1 07       	cpc	r27, r17
     3fa:	e1 f7       	brne	.-8      	; 0x3f4 <.do_clear_bss_loop>
     3fc:	0e 94 48 02 	call	0x490	; 0x490 <main>
     400:	0c 94 ca 0b 	jmp	0x1794	; 0x1794 <_exit>

00000404 <__bad_interrupt>:
     404:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000408 <__vector_6>:
	C16(255,184,174),    // 14 lt pink
	C16(222,222,255),    // 15 whiteish
};

ISR(PCINT2_vect)
{
     408:	1f 92       	push	r1
     40a:	0f 92       	push	r0
     40c:	0f b6       	in	r0, 0x3f	; 63
     40e:	0f 92       	push	r0
     410:	11 24       	eor	r1, r1
     412:	8f 93       	push	r24
     414:	9f 93       	push	r25
		//xprintf(PSTR("ISR Entered"));
		if (VSYNC_Count==1)//start a frame read
     416:	80 91 a2 02 	lds	r24, 0x02A2
     41a:	90 91 a3 02 	lds	r25, 0x02A3
     41e:	81 30       	cpi	r24, 0x01	; 1
     420:	91 05       	cpc	r25, r1
     422:	59 f4       	brne	.+22     	; 0x43a <__vector_6+0x32>
		{
			/*xprintf(PSTR("WEN Set\n"));*/
			FIFO_WEN_SET;
     424:	46 9a       	sbi	0x08, 6	; 8
			VSYNC_Count++;
     426:	80 91 a2 02 	lds	r24, 0x02A2
     42a:	90 91 a3 02 	lds	r25, 0x02A3
     42e:	01 96       	adiw	r24, 0x01	; 1
     430:	90 93 a3 02 	sts	0x02A3, r25
     434:	80 93 a2 02 	sts	0x02A2, r24
     438:	1e c0       	rjmp	.+60     	; 0x476 <__vector_6+0x6e>
		}
		else if(VSYNC_Count == 2)//rising edge of pin change
     43a:	80 91 a2 02 	lds	r24, 0x02A2
     43e:	90 91 a3 02 	lds	r25, 0x02A3
     442:	82 30       	cpi	r24, 0x02	; 2
     444:	91 05       	cpc	r25, r1
     446:	51 f4       	brne	.+20     	; 0x45c <__vector_6+0x54>
		{
			VSYNC_Count++;
     448:	80 91 a2 02 	lds	r24, 0x02A2
     44c:	90 91 a3 02 	lds	r25, 0x02A3
     450:	01 96       	adiw	r24, 0x01	; 1
     452:	90 93 a3 02 	sts	0x02A3, r25
     456:	80 93 a2 02 	sts	0x02A2, r24
     45a:	0d c0       	rjmp	.+26     	; 0x476 <__vector_6+0x6e>
		}
		else if (VSYNC_Count==3)//end a frame read
     45c:	80 91 a2 02 	lds	r24, 0x02A2
     460:	90 91 a3 02 	lds	r25, 0x02A3
     464:	83 30       	cpi	r24, 0x03	; 3
     466:	91 05       	cpc	r25, r1
     468:	11 f4       	brne	.+4      	; 0x46e <__vector_6+0x66>
		{
			FIFO_WEN_CLR;
     46a:	46 98       	cbi	0x08, 6	; 8
     46c:	04 c0       	rjmp	.+8      	; 0x476 <__vector_6+0x6e>
			/*xprintf(PSTR("WEN Clear\n"));*/
		}
		else
		{
			VSYNC_Count = 0;//wait for a read to be started
     46e:	10 92 a3 02 	sts	0x02A3, r1
     472:	10 92 a2 02 	sts	0x02A2, r1
		}
}
     476:	9f 91       	pop	r25
     478:	8f 91       	pop	r24
     47a:	0f 90       	pop	r0
     47c:	0f be       	out	0x3f, r0	; 63
     47e:	0f 90       	pop	r0
     480:	1f 90       	pop	r1
     482:	18 95       	reti

00000484 <_Z9PCINTINITv>:

void PCINTINIT()
{
	PCICR = (1<<PCIE2); //enable PCINTs[23..16]
     484:	84 e0       	ldi	r24, 0x04	; 4
     486:	80 93 68 00 	sts	0x0068, r24
	PCMSK2 = (1<<PCINT18);
     48a:	80 93 6d 00 	sts	0x006D, r24
}
     48e:	08 95       	ret

00000490 <main>:
int main(void)
{
	TWI_Master_Initialise();
     490:	0e 94 76 0a 	call	0x14ec	; 0x14ec <TWI_Master_Initialise>
	LCD::Init();
     494:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_ZN3LCD4InitEv>
	PCINTINIT();
     498:	0e 94 42 02 	call	0x484	; 0x484 <_Z9PCINTINITv>
	sei();
     49c:	78 94       	sei
	Graphics::Rectangle(0,0,240,320, _paletteW[0]);
     49e:	00 91 00 01 	lds	r16, 0x0100
     4a2:	10 91 01 01 	lds	r17, 0x0101
     4a6:	80 e0       	ldi	r24, 0x00	; 0
     4a8:	90 e0       	ldi	r25, 0x00	; 0
     4aa:	60 e0       	ldi	r22, 0x00	; 0
     4ac:	70 e0       	ldi	r23, 0x00	; 0
     4ae:	40 ef       	ldi	r20, 0xF0	; 240
     4b0:	50 e0       	ldi	r21, 0x00	; 0
     4b2:	20 e4       	ldi	r18, 0x40	; 64
     4b4:	31 e0       	ldi	r19, 0x01	; 1
     4b6:	0e 94 bd 02 	call	0x57a	; 0x57a <_ZN8Graphics9RectangleEiiiii>
	Graphics::BeginPixels();
     4ba:	0e 94 3c 03 	call	0x678	; 0x678 <_ZN8Graphics11BeginPixelsEv>
	int x,y,i,j;//,height,width;
	x = 0;
	y = 0;
		
	//LCD::SetPixel(x, y, colour);
	FIFO_init();
     4be:	0e 94 09 0a 	call	0x1412	; 0x1412 <FIFO_init>
	if(OV7670_init() == 1)
     4c2:	0e 94 ac 09 	call	0x1358	; 0x1358 <OV7670_init>
     4c6:	81 30       	cpi	r24, 0x01	; 1
     4c8:	29 f4       	brne	.+10     	; 0x4d4 <main+0x44>
		colour = _paletteW[12];//green
     4ca:	00 91 18 01 	lds	r16, 0x0118
     4ce:	10 91 19 01 	lds	r17, 0x0119
     4d2:	04 c0       	rjmp	.+8      	; 0x4dc <main+0x4c>
	else
		colour = _paletteW[1];
     4d4:	00 91 02 01 	lds	r16, 0x0102
     4d8:	10 91 03 01 	lds	r17, 0x0103
	Graphics::Rectangle(0,0, LCD::GetWidth(), LCD::GetHeight(), colour);
     4dc:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN3LCD8GetWidthEv>
     4e0:	ec 01       	movw	r28, r24
     4e2:	0e 94 c2 06 	call	0xd84	; 0xd84 <_ZN3LCD9GetHeightEv>
     4e6:	9c 01       	movw	r18, r24
     4e8:	80 e0       	ldi	r24, 0x00	; 0
     4ea:	90 e0       	ldi	r25, 0x00	; 0
     4ec:	60 e0       	ldi	r22, 0x00	; 0
     4ee:	70 e0       	ldi	r23, 0x00	; 0
     4f0:	ae 01       	movw	r20, r28
     4f2:	0e 94 bd 02 	call	0x57a	; 0x57a <_ZN8Graphics9RectangleEiiiii>
{
	PCICR = (1<<PCIE2); //enable PCINTs[23..16]
	PCMSK2 = (1<<PCINT18);
}
int main(void)
{
     4f6:	88 24       	eor	r8, r8
     4f8:	99 24       	eor	r9, r9
     4fa:	b8 2c       	mov	r11, r8
     4fc:	a9 2c       	mov	r10, r9
	else
		colour = _paletteW[1];
	Graphics::Rectangle(0,0, LCD::GetWidth(), LCD::GetHeight(), colour);
    while(1)
    {
		LoadImageToBuffer();
     4fe:	0e 94 ee 09 	call	0x13dc	; 0x13dc <LoadImageToBuffer>
		while(VSYNC_Count != 3)
     502:	80 91 a2 02 	lds	r24, 0x02A2
     506:	90 91 a3 02 	lds	r25, 0x02A3
     50a:	83 30       	cpi	r24, 0x03	; 3
     50c:	91 05       	cpc	r25, r1
     50e:	c9 f7       	brne	.-14     	; 0x502 <main+0x72>
			;//wait for an image
		//reset read pointer
		FIFO_nRRST_CLR; 
     510:	47 98       	cbi	0x08, 7	; 8
		FIFO_RCLK_SET;
     512:	44 9a       	sbi	0x08, 4	; 8
		FIFO_RCLK_CLR;
     514:	44 98       	cbi	0x08, 4	; 8
		FIFO_nRRST_SET;
     516:	47 9a       	sbi	0x08, 7	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     518:	87 eb       	ldi	r24, 0xB7	; 183
     51a:	9b e0       	ldi	r25, 0x0B	; 11
     51c:	01 97       	sbiw	r24, 0x01	; 1
     51e:	f1 f7       	brne	.-4      	; 0x51c <main+0x8c>
     520:	00 c0       	rjmp	.+0      	; 0x522 <main+0x92>
     522:	00 00       	nop
     524:	0f 2e       	mov	r0, r31
     526:	f0 ef       	ldi	r31, 0xF0	; 240
     528:	cf 2e       	mov	r12, r31
     52a:	dd 24       	eor	r13, r13
     52c:	f0 2d       	mov	r31, r0
     52e:	18 c0       	rjmp	.+48     	; 0x560 <main+0xd0>
		{

			for (i=0; i < 320; i++)
			{
				
				colour=FIFO_TO_AVR();
     530:	0e 94 2e 0a 	call	0x145c	; 0x145c <FIFO_TO_AVR>
				colour = (char)(colour >> 8) |(((char)colour)<<8);
     534:	f8 2e       	mov	r15, r24
     536:	ee 24       	eor	r14, r14
     538:	49 2f       	mov	r20, r25
     53a:	50 e0       	ldi	r21, 0x00	; 0
     53c:	4e 29       	or	r20, r14
     53e:	5f 29       	or	r21, r15
				LCD::SetPixel(j,i, colour);
     540:	81 2f       	mov	r24, r17
     542:	90 2f       	mov	r25, r16
     544:	be 01       	movw	r22, r28
     546:	0e 94 00 09 	call	0x1200	; 0x1200 <_ZN3LCD8SetPixelEiit>
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=240; j > 0; j--) //Read all data
		{

			for (i=0; i < 320; i++)
     54a:	21 96       	adiw	r28, 0x01	; 1
     54c:	91 e0       	ldi	r25, 0x01	; 1
     54e:	c0 34       	cpi	r28, 0x40	; 64
     550:	d9 07       	cpc	r29, r25
     552:	71 f7       	brne	.-36     	; 0x530 <main+0xa0>
     554:	08 94       	sec
     556:	c1 08       	sbc	r12, r1
     558:	d1 08       	sbc	r13, r1
		FIFO_nRRST_CLR; 
		FIFO_RCLK_SET;
		FIFO_RCLK_CLR;
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=240; j > 0; j--) //Read all data
     55a:	c1 14       	cp	r12, r1
     55c:	d1 04       	cpc	r13, r1
     55e:	29 f0       	breq	.+10     	; 0x56a <main+0xda>
     560:	1c 2d       	mov	r17, r12
     562:	0d 2d       	mov	r16, r13
{
	PCICR = (1<<PCIE2); //enable PCINTs[23..16]
	PCMSK2 = (1<<PCINT18);
}
int main(void)
{
     564:	cb 2d       	mov	r28, r11
     566:	da 2d       	mov	r29, r10
     568:	e3 cf       	rjmp	.-58     	; 0x530 <main+0xa0>
				colour = (char)(colour >> 8) |(((char)colour)<<8);
				LCD::SetPixel(j,i, colour);

			}
		}
		VSYNC_Count = 0;
     56a:	90 92 a3 02 	sts	0x02A3, r9
     56e:	80 92 a2 02 	sts	0x02A2, r8
	if(OV7670_init() == 1)
		colour = _paletteW[12];//green
	else
		colour = _paletteW[1];
	Graphics::Rectangle(0,0, LCD::GetWidth(), LCD::GetHeight(), colour);
    while(1)
     572:	c5 cf       	rjmp	.-118    	; 0x4fe <main+0x6e>

00000574 <_ZN8Graphics4InitEv>:
    DrawString(s,strlen(s),x,y);
}

void Graphics::Init()
{
    LCD::Init();
     574:	0e 94 4e 05 	call	0xa9c	; 0xa9c <_ZN3LCD4InitEv>
}
     578:	08 95       	ret

0000057a <_ZN8Graphics9RectangleEiiiii>:

void Graphics::Rectangle(int x, int y, int width, int height, int color)
{
     57a:	8f 92       	push	r8
     57c:	9f 92       	push	r9
     57e:	af 92       	push	r10
     580:	bf 92       	push	r11
     582:	cf 92       	push	r12
     584:	df 92       	push	r13
     586:	ef 92       	push	r14
     588:	ff 92       	push	r15
     58a:	0f 93       	push	r16
     58c:	1f 93       	push	r17
     58e:	cf 93       	push	r28
     590:	df 93       	push	r29
     592:	ec 01       	movw	r28, r24
     594:	5b 01       	movw	r10, r22
     596:	48 01       	movw	r8, r16
    int right = x + width;
     598:	8c 01       	movw	r16, r24
     59a:	04 0f       	add	r16, r20
     59c:	15 1f       	adc	r17, r21
    int bottom = y + height;
     59e:	7b 01       	movw	r14, r22
     5a0:	e2 0e       	add	r14, r18
     5a2:	f3 1e       	adc	r15, r19
    right = min(right,(int)LCD::GetWidth());
     5a4:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN3LCD8GetWidthEv>
     5a8:	08 17       	cp	r16, r24
     5aa:	19 07       	cpc	r17, r25
     5ac:	24 f0       	brlt	.+8      	; 0x5b6 <_ZN8Graphics9RectangleEiiiii+0x3c>
     5ae:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN3LCD8GetWidthEv>
     5b2:	08 2f       	mov	r16, r24
     5b4:	19 2f       	mov	r17, r25
    bottom = min(bottom,(int)LCD::GetHeight());
     5b6:	0e 94 c2 06 	call	0xd84	; 0xd84 <_ZN3LCD9GetHeightEv>
     5ba:	e8 16       	cp	r14, r24
     5bc:	f9 06       	cpc	r15, r25
     5be:	24 f0       	brlt	.+8      	; 0x5c8 <_ZN8Graphics9RectangleEiiiii+0x4e>
     5c0:	0e 94 c2 06 	call	0xd84	; 0xd84 <_ZN3LCD9GetHeightEv>
     5c4:	e8 2e       	mov	r14, r24
     5c6:	f9 2e       	mov	r15, r25
    x = max(x,0);
     5c8:	dd 23       	and	r29, r29
     5ca:	14 f4       	brge	.+4      	; 0x5d0 <_ZN8Graphics9RectangleEiiiii+0x56>
     5cc:	c0 e0       	ldi	r28, 0x00	; 0
     5ce:	d0 e0       	ldi	r29, 0x00	; 0
    y = max(y,0);
    width = right - x;
     5d0:	68 01       	movw	r12, r16
     5d2:	cc 1a       	sub	r12, r28
     5d4:	dd 0a       	sbc	r13, r29
    height = bottom - y;
    if (width <= 0 || height <= 0)
     5d6:	1c 14       	cp	r1, r12
     5d8:	1d 04       	cpc	r1, r13
     5da:	0c f0       	brlt	.+2      	; 0x5de <_ZN8Graphics9RectangleEiiiii+0x64>
     5dc:	3d c0       	rjmp	.+122    	; 0x658 <_ZN8Graphics9RectangleEiiiii+0xde>
    int right = x + width;
    int bottom = y + height;
    right = min(right,(int)LCD::GetWidth());
    bottom = min(bottom,(int)LCD::GetHeight());
    x = max(x,0);
    y = max(y,0);
     5de:	85 01       	movw	r16, r10
     5e0:	bb 20       	and	r11, r11
     5e2:	14 f4       	brge	.+4      	; 0x5e8 <_ZN8Graphics9RectangleEiiiii+0x6e>
     5e4:	00 e0       	ldi	r16, 0x00	; 0
     5e6:	10 e0       	ldi	r17, 0x00	; 0
    width = right - x;
    height = bottom - y;
     5e8:	e0 1a       	sub	r14, r16
     5ea:	f1 0a       	sbc	r15, r17
    if (width <= 0 || height <= 0)
     5ec:	1e 14       	cp	r1, r14
     5ee:	1f 04       	cpc	r1, r15
     5f0:	9c f5       	brge	.+102    	; 0x658 <_ZN8Graphics9RectangleEiiiii+0xde>
        return;
        
    LCD::SetWrap(x,y,width,height);
     5f2:	ce 01       	movw	r24, r28
     5f4:	b8 01       	movw	r22, r16
     5f6:	a6 01       	movw	r20, r12
     5f8:	97 01       	movw	r18, r14
     5fa:	0e 94 8b 06 	call	0xd16	; 0xd16 <_ZN3LCD7SetWrapEiiii>
    LCD::SetGRAM(x,y);
     5fe:	ce 01       	movw	r24, r28
     600:	b8 01       	movw	r22, r16
     602:	0e 94 b7 06 	call	0xd6e	; 0xd6e <_ZN3LCD7SetGRAMEii>
    LCD::SetColor(color);
     606:	c4 01       	movw	r24, r8
     608:	0e 94 c5 06 	call	0xd8a	; 0xd8a <_ZN3LCD8SetColorEt>
    
    // Keep 16 bit int range
    while (height > 128)
     60c:	81 e8       	ldi	r24, 0x81	; 129
     60e:	e8 16       	cp	r14, r24
     610:	f1 04       	cpc	r15, r1
     612:	cc f0       	brlt	.+50     	; 0x646 <_ZN8Graphics9RectangleEiiiii+0xcc>
    {
        LCD::SolidFill(width*128);
     614:	86 01       	movw	r16, r12
     616:	16 95       	lsr	r17
     618:	10 2f       	mov	r17, r16
     61a:	00 27       	eor	r16, r16
     61c:	17 95       	ror	r17
     61e:	07 95       	ror	r16
    right = min(right,(int)LCD::GetWidth());
    bottom = min(bottom,(int)LCD::GetHeight());
    x = max(x,0);
    y = max(y,0);
    width = right - x;
    height = bottom - y;
     620:	e7 01       	movw	r28, r14
    LCD::SetColor(color);
    
    // Keep 16 bit int range
    while (height > 128)
    {
        LCD::SolidFill(width*128);
     622:	c8 01       	movw	r24, r16
     624:	0e 94 ba 07 	call	0xf74	; 0xf74 <_ZN3LCD9SolidFillEt>
        height -= 128;
     628:	c0 58       	subi	r28, 0x80	; 128
     62a:	d0 40       	sbci	r29, 0x00	; 0
    LCD::SetWrap(x,y,width,height);
    LCD::SetGRAM(x,y);
    LCD::SetColor(color);
    
    // Keep 16 bit int range
    while (height > 128)
     62c:	c1 38       	cpi	r28, 0x81	; 129
     62e:	d1 05       	cpc	r29, r1
     630:	c4 f7       	brge	.-16     	; 0x622 <_ZN8Graphics9RectangleEiiiii+0xa8>
void Graphics::Init()
{
    LCD::Init();
}

void Graphics::Rectangle(int x, int y, int width, int height, int color)
     632:	c7 01       	movw	r24, r14
     634:	80 58       	subi	r24, 0x80	; 128
     636:	90 40       	sbci	r25, 0x00	; 0
     638:	97 01       	movw	r18, r14
     63a:	21 58       	subi	r18, 0x81	; 129
     63c:	30 40       	sbci	r19, 0x00	; 0
     63e:	20 78       	andi	r18, 0x80	; 128
     640:	7c 01       	movw	r14, r24
     642:	e2 1a       	sub	r14, r18
     644:	f3 0a       	sbc	r15, r19
    while (height > 128)
    {
        LCD::SolidFill(width*128);
        height -= 128;
    }
    LCD::SolidFill(width*height);
     646:	ce 9c       	mul	r12, r14
     648:	c0 01       	movw	r24, r0
     64a:	cf 9c       	mul	r12, r15
     64c:	90 0d       	add	r25, r0
     64e:	de 9c       	mul	r13, r14
     650:	90 0d       	add	r25, r0
     652:	11 24       	eor	r1, r1
     654:	0e 94 ba 07 	call	0xf74	; 0xf74 <_ZN3LCD9SolidFillEt>
}
     658:	df 91       	pop	r29
     65a:	cf 91       	pop	r28
     65c:	1f 91       	pop	r17
     65e:	0f 91       	pop	r16
     660:	ff 90       	pop	r15
     662:	ef 90       	pop	r14
     664:	df 90       	pop	r13
     666:	cf 90       	pop	r12
     668:	bf 90       	pop	r11
     66a:	af 90       	pop	r10
     66c:	9f 90       	pop	r9
     66e:	8f 90       	pop	r8
     670:	08 95       	ret

00000672 <_ZN8Graphics8SetColorEt>:

void Graphics::SetColor(ushort color)
{
    LCD::SetColor(color);
     672:	0e 94 c5 06 	call	0xd8a	; 0xd8a <_ZN3LCD8SetColorEt>
}
     676:	08 95       	ret

00000678 <_ZN8Graphics11BeginPixelsEv>:

void Graphics::BeginPixels()
{
    LCD::OpenWrap();
     678:	0e 94 ca 06 	call	0xd94	; 0xd94 <_ZN3LCD8OpenWrapEv>
    _ph = _pv = 0xFFFF;
     67c:	8f ef       	ldi	r24, 0xFF	; 255
     67e:	9f ef       	ldi	r25, 0xFF	; 255
     680:	90 93 a5 02 	sts	0x02A5, r25
     684:	80 93 a4 02 	sts	0x02A4, r24
     688:	90 93 a7 02 	sts	0x02A7, r25
     68c:	80 93 a6 02 	sts	0x02A6, r24
}
     690:	08 95       	ret

00000692 <_ZN8Graphics8PutPixelEtt>:

void Graphics::PutPixel(ushort x, ushort y)
{
     692:	0f 93       	push	r16
     694:	1f 93       	push	r17
     696:	cf 93       	push	r28
     698:	df 93       	push	r29
     69a:	ec 01       	movw	r28, r24
     69c:	8b 01       	movw	r16, r22
    if (x >= LCD::GetWidth() || y >= LCD::GetHeight())
     69e:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN3LCD8GetWidthEv>
     6a2:	c8 17       	cp	r28, r24
     6a4:	d9 07       	cpc	r29, r25
     6a6:	80 f5       	brcc	.+96     	; 0x708 <_ZN8Graphics8PutPixelEtt+0x76>
     6a8:	0e 94 c2 06 	call	0xd84	; 0xd84 <_ZN3LCD9GetHeightEv>
     6ac:	08 17       	cp	r16, r24
     6ae:	19 07       	cpc	r17, r25
     6b0:	58 f5       	brcc	.+86     	; 0x708 <_ZN8Graphics8PutPixelEtt+0x76>
     6b2:	22 c0       	rjmp	.+68     	; 0x6f8 <_ZN8Graphics8PutPixelEtt+0x66>
        return; // Clip PutPixel to screen bounds
    if ((int)x != _ph || (int)y != _pv)
     6b4:	80 91 a4 02 	lds	r24, 0x02A4
     6b8:	90 91 a5 02 	lds	r25, 0x02A5
     6bc:	08 17       	cp	r16, r24
     6be:	19 07       	cpc	r17, r25
     6c0:	69 f0       	breq	.+26     	; 0x6dc <_ZN8Graphics8PutPixelEtt+0x4a>
    {
        LCD::SetGRAM(x,y);
     6c2:	ce 01       	movw	r24, r28
     6c4:	60 2f       	mov	r22, r16
     6c6:	71 2f       	mov	r23, r17
     6c8:	0e 94 b7 06 	call	0xd6e	; 0xd6e <_ZN3LCD7SetGRAMEii>
        _ph = x;
     6cc:	d0 93 a7 02 	sts	0x02A7, r29
     6d0:	c0 93 a6 02 	sts	0x02A6, r28
        _pv = y;
     6d4:	00 93 a4 02 	sts	0x02A4, r16
     6d8:	10 93 a5 02 	sts	0x02A5, r17
    }
    LCD::SolidFill(1);
     6dc:	81 e0       	ldi	r24, 0x01	; 1
     6de:	90 e0       	ldi	r25, 0x00	; 0
     6e0:	0e 94 ba 07 	call	0xf74	; 0xf74 <_ZN3LCD9SolidFillEt>
    _ph++;
     6e4:	80 91 a6 02 	lds	r24, 0x02A6
     6e8:	90 91 a7 02 	lds	r25, 0x02A7
     6ec:	01 96       	adiw	r24, 0x01	; 1
     6ee:	90 93 a7 02 	sts	0x02A7, r25
     6f2:	80 93 a6 02 	sts	0x02A6, r24
     6f6:	08 c0       	rjmp	.+16     	; 0x708 <_ZN8Graphics8PutPixelEtt+0x76>

void Graphics::PutPixel(ushort x, ushort y)
{
    if (x >= LCD::GetWidth() || y >= LCD::GetHeight())
        return; // Clip PutPixel to screen bounds
    if ((int)x != _ph || (int)y != _pv)
     6f8:	80 91 a6 02 	lds	r24, 0x02A6
     6fc:	90 91 a7 02 	lds	r25, 0x02A7
     700:	c8 17       	cp	r28, r24
     702:	d9 07       	cpc	r29, r25
     704:	f1 f6       	brne	.-68     	; 0x6c2 <_ZN8Graphics8PutPixelEtt+0x30>
     706:	d6 cf       	rjmp	.-84     	; 0x6b4 <_ZN8Graphics8PutPixelEtt+0x22>
        _ph = x;
        _pv = y;
    }
    LCD::SolidFill(1);
    _ph++;
}
     708:	df 91       	pop	r29
     70a:	cf 91       	pop	r28
     70c:	1f 91       	pop	r17
     70e:	0f 91       	pop	r16
     710:	08 95       	ret

00000712 <_Z8DrawChariii>:
#else
#define FNT(_x) Verdana_font_11[_x]
#endif

int DrawChar(int xx, int yy, int c)
{
     712:	2f 92       	push	r2
     714:	3f 92       	push	r3
     716:	4f 92       	push	r4
     718:	5f 92       	push	r5
     71a:	6f 92       	push	r6
     71c:	7f 92       	push	r7
     71e:	8f 92       	push	r8
     720:	9f 92       	push	r9
     722:	af 92       	push	r10
     724:	bf 92       	push	r11
     726:	cf 92       	push	r12
     728:	df 92       	push	r13
     72a:	ef 92       	push	r14
     72c:	ff 92       	push	r15
     72e:	0f 93       	push	r16
     730:	1f 93       	push	r17
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	00 d0       	rcall	.+0      	; 0x738 <_Z8DrawChariii+0x26>
     738:	00 d0       	rcall	.+0      	; 0x73a <_Z8DrawChariii+0x28>
     73a:	cd b7       	in	r28, 0x3d	; 61
     73c:	de b7       	in	r29, 0x3e	; 62
     73e:	2c 01       	movw	r4, r24
    //byte* f = Verdana_font_11;
    if (c == 32)
     740:	40 32       	cpi	r20, 0x20	; 32
     742:	51 05       	cpc	r21, r1
     744:	51 f4       	brne	.+20     	; 0x75a <_Z8DrawChariii+0x48>
        return FNT(1)>>2;  // Space is 1/4 font height (yuk);
     746:	ed e7       	ldi	r30, 0x7D	; 125
     748:	f0 e0       	ldi	r31, 0x00	; 0
     74a:	e4 91       	lpm	r30, Z
     74c:	6e 2e       	mov	r6, r30
     74e:	77 24       	eor	r7, r7
     750:	75 94       	asr	r7
     752:	67 94       	ror	r6
     754:	75 94       	asr	r7
     756:	67 94       	ror	r6
     758:	c4 c0       	rjmp	.+392    	; 0x8e2 <_Z8DrawChariii+0x1d0>

    int i = c - FNT(3);
     75a:	ef e7       	ldi	r30, 0x7F	; 127
     75c:	f0 e0       	ldi	r31, 0x00	; 0
     75e:	e4 91       	lpm	r30, Z
     760:	4e 1b       	sub	r20, r30
     762:	51 09       	sbc	r21, r1
    if (i < 0 || i >= FNT(4)) return 0;
     764:	55 23       	and	r21, r21
     766:	0c f4       	brge	.+2      	; 0x76a <_Z8DrawChariii+0x58>
     768:	b7 c0       	rjmp	.+366    	; 0x8d8 <_Z8DrawChariii+0x1c6>
     76a:	a0 e8       	ldi	r26, 0x80	; 128
     76c:	b0 e0       	ldi	r27, 0x00	; 0
     76e:	fd 01       	movw	r30, r26
     770:	84 91       	lpm	r24, Z
     772:	90 e0       	ldi	r25, 0x00	; 0
     774:	48 17       	cp	r20, r24
     776:	59 07       	cpc	r21, r25
     778:	0c f0       	brlt	.+2      	; 0x77c <_Z8DrawChariii+0x6a>
     77a:	b1 c0       	rjmp	.+354    	; 0x8de <_Z8DrawChariii+0x1cc>

    int ci = 6 + i * 2;
     77c:	ca 01       	movw	r24, r20
     77e:	03 96       	adiw	r24, 0x03	; 3
     780:	9c 01       	movw	r18, r24
     782:	22 0f       	add	r18, r18
     784:	33 1f       	adc	r19, r19
    int width = (FNT(ci) << 8) | FNT(ci + 1);   // simplify
     786:	f9 01       	movw	r30, r18
     788:	e4 58       	subi	r30, 0x84	; 132
     78a:	ff 4f       	sbci	r31, 0xFF	; 255
     78c:	94 91       	lpm	r25, Z
     78e:	f9 01       	movw	r30, r18
     790:	e3 58       	subi	r30, 0x83	; 131
     792:	ff 4f       	sbci	r31, 0xFF	; 255
     794:	84 91       	lpm	r24, Z
     796:	f9 2f       	mov	r31, r25
     798:	e0 e0       	ldi	r30, 0x00	; 0
     79a:	90 e0       	ldi	r25, 0x00	; 0
     79c:	3f 01       	movw	r6, r30
     79e:	68 2a       	or	r6, r24
     7a0:	79 2a       	or	r7, r25
    int height = FNT(1);
     7a2:	0d e7       	ldi	r16, 0x7D	; 125
     7a4:	10 e0       	ldi	r17, 0x00	; 0
     7a6:	f8 01       	movw	r30, r16
     7a8:	f4 91       	lpm	r31, Z
     7aa:	f9 83       	std	Y+1, r31	; 0x01
    int src = 0;
    if (i > 0)
     7ac:	14 16       	cp	r1, r20
     7ae:	15 06       	cpc	r1, r21
     7b0:	84 f4       	brge	.+32     	; 0x7d2 <_Z8DrawChariii+0xc0>
    {
        src = (FNT(ci - 2) << 8) | FNT(ci - 1);
     7b2:	f9 01       	movw	r30, r18
     7b4:	e6 58       	subi	r30, 0x86	; 134
     7b6:	ff 4f       	sbci	r31, 0xFF	; 255
     7b8:	94 91       	lpm	r25, Z
     7ba:	f9 01       	movw	r30, r18
     7bc:	e5 58       	subi	r30, 0x85	; 133
     7be:	ff 4f       	sbci	r31, 0xFF	; 255
     7c0:	84 91       	lpm	r24, Z
     7c2:	59 2f       	mov	r21, r25
     7c4:	40 e0       	ldi	r20, 0x00	; 0
     7c6:	90 e0       	ldi	r25, 0x00	; 0
     7c8:	48 2b       	or	r20, r24
     7ca:	59 2b       	or	r21, r25
        width -= src;
     7cc:	64 1a       	sub	r6, r20
     7ce:	75 0a       	sbc	r7, r21
     7d0:	02 c0       	rjmp	.+4      	; 0x7d6 <_Z8DrawChariii+0xc4>
    if (i < 0 || i >= FNT(4)) return 0;

    int ci = 6 + i * 2;
    int width = (FNT(ci) << 8) | FNT(ci + 1);   // simplify
    int height = FNT(1);
    int src = 0;
     7d2:	40 e0       	ldi	r20, 0x00	; 0
     7d4:	50 e0       	ldi	r21, 0x00	; 0
        src = (FNT(ci - 2) << 8) | FNT(ci - 1);
        width -= src;
    }
    
    //  clip?
    src += (6 + 2 * FNT(4)) * 8;    // start of pixels (roll into cols) 
     7d6:	fd 01       	movw	r30, r26
     7d8:	84 91       	lpm	r24, Z
     7da:	90 e0       	ldi	r25, 0x00	; 0
     7dc:	03 96       	adiw	r24, 0x03	; 3
     7de:	82 95       	swap	r24
     7e0:	92 95       	swap	r25
     7e2:	90 7f       	andi	r25, 0xF0	; 240
     7e4:	98 27       	eor	r25, r24
     7e6:	80 7f       	andi	r24, 0xF0	; 240
     7e8:	98 27       	eor	r25, r24
     7ea:	48 0f       	add	r20, r24
     7ec:	59 1f       	adc	r21, r25
    byte mask = 0x80 >> (src & 7);  // Mask at start of line
     7ee:	9a 01       	movw	r18, r20
     7f0:	27 70       	andi	r18, 0x07	; 7
     7f2:	30 70       	andi	r19, 0x00	; 0
     7f4:	80 e8       	ldi	r24, 0x80	; 128
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	02 c0       	rjmp	.+4      	; 0x7fe <_Z8DrawChariii+0xec>
     7fa:	95 95       	asr	r25
     7fc:	87 95       	ror	r24
     7fe:	2a 95       	dec	r18
     800:	e2 f7       	brpl	.-8      	; 0x7fa <_Z8DrawChariii+0xe8>
     802:	a8 2f       	mov	r26, r24
    int end = (src+width) >> 3;     // number of bytes read
    src >>= 3;
     804:	9a 01       	movw	r18, r20
     806:	35 95       	asr	r19
     808:	27 95       	ror	r18
     80a:	35 95       	asr	r19
     80c:	27 95       	ror	r18
     80e:	35 95       	asr	r19
     810:	27 95       	ror	r18
    int makeup = FNT(5) - (end + 1 - src);
     812:	e1 e8       	ldi	r30, 0x81	; 129
     814:	f0 e0       	ldi	r31, 0x00	; 0
     816:	e4 91       	lpm	r30, Z
    }
    
    //  clip?
    src += (6 + 2 * FNT(4)) * 8;    // start of pixels (roll into cols) 
    byte mask = 0x80 >> (src & 7);  // Mask at start of line
    int end = (src+width) >> 3;     // number of bytes read
     818:	ca 01       	movw	r24, r20
     81a:	86 0d       	add	r24, r6
     81c:	97 1d       	adc	r25, r7
     81e:	95 95       	asr	r25
     820:	87 95       	ror	r24
     822:	95 95       	asr	r25
     824:	87 95       	ror	r24
     826:	95 95       	asr	r25
     828:	87 95       	ror	r24
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
     82a:	80 95       	com	r24
     82c:	90 95       	com	r25
     82e:	82 0f       	add	r24, r18
     830:	93 1f       	adc	r25, r19
     832:	1c 01       	movw	r2, r24
     834:	2e 0e       	add	r2, r30
     836:	31 1c       	adc	r3, r1
    for (byte y = 0; y < (byte)height; y++)
     838:	f9 81       	ldd	r31, Y+1	; 0x01
     83a:	ff 23       	and	r31, r31
     83c:	09 f4       	brne	.+2      	; 0x840 <_Z8DrawChariii+0x12e>
     83e:	51 c0       	rjmp	.+162    	; 0x8e2 <_Z8DrawChariii+0x1d0>
     840:	a6 2e       	mov	r10, r22
     842:	b7 2e       	mov	r11, r23
     844:	88 24       	eor	r8, r8
    {
        byte p = FNT(src++);
        byte m = mask;
        for (byte x = 0; x < (byte)width; x++)
     846:	d6 2c       	mov	r13, r6
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
    {
        byte p = FNT(src++);
        byte m = mask;
     848:	aa 83       	std	Y+2, r26	; 0x02
            if (m == 0)
            {
                p = FNT(src++);
                if (p == 0 && (width-x) <= 8)   // early out
                    break;
                m = 0x80;
     84a:	0f 2e       	mov	r0, r31
     84c:	f0 e8       	ldi	r31, 0x80	; 128
     84e:	cf 2e       	mov	r12, r31
     850:	f0 2d       	mov	r31, r0
            if (p & m)
                Graphics::PutPixel(x + xx, y + yy);
            m >>= 1;
            if (m == 0)
            {
                p = FNT(src++);
     852:	99 24       	eor	r9, r9
    int end = (src+width) >> 3;     // number of bytes read
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
    {
        byte p = FNT(src++);
     854:	79 01       	movw	r14, r18
     856:	08 94       	sec
     858:	e1 1c       	adc	r14, r1
     85a:	f1 1c       	adc	r15, r1
     85c:	f9 01       	movw	r30, r18
     85e:	e4 58       	subi	r30, 0x84	; 132
     860:	ff 4f       	sbci	r31, 0xFF	; 255
     862:	e4 91       	lpm	r30, Z
        byte m = mask;
        for (byte x = 0; x < (byte)width; x++)
     864:	dd 20       	and	r13, r13
     866:	61 f1       	breq	.+88     	; 0x8c0 <_Z8DrawChariii+0x1ae>
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
    {
        byte p = FNT(src++);
        byte m = mask;
     868:	8a 81       	ldd	r24, Y+2	; 0x02
     86a:	8b 83       	std	Y+3, r24	; 0x03
    int end = (src+width) >> 3;     // number of bytes read
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
    {
        byte p = FNT(src++);
     86c:	ec 83       	std	Y+4, r30	; 0x04
        byte m = mask;
        for (byte x = 0; x < (byte)width; x++)
     86e:	00 e0       	ldi	r16, 0x00	; 0
     870:	10 e0       	ldi	r17, 0x00	; 0
        {
            if (p & m)
     872:	8b 81       	ldd	r24, Y+3	; 0x03
     874:	9c 81       	ldd	r25, Y+4	; 0x04
     876:	89 23       	and	r24, r25
     878:	31 f0       	breq	.+12     	; 0x886 <_Z8DrawChariii+0x174>
                Graphics::PutPixel(x + xx, y + yy);
     87a:	c8 01       	movw	r24, r16
     87c:	84 0d       	add	r24, r4
     87e:	95 1d       	adc	r25, r5
     880:	b5 01       	movw	r22, r10
     882:	0e 94 49 03 	call	0x692	; 0x692 <_ZN8Graphics8PutPixelEtt>
            m >>= 1;
     886:	eb 81       	ldd	r30, Y+3	; 0x03
     888:	e6 95       	lsr	r30
     88a:	eb 83       	std	Y+3, r30	; 0x03
            if (m == 0)
     88c:	ee 23       	and	r30, r30
     88e:	a1 f4       	brne	.+40     	; 0x8b8 <_Z8DrawChariii+0x1a6>
            {
                p = FNT(src++);
     890:	f7 01       	movw	r30, r14
     892:	e4 58       	subi	r30, 0x84	; 132
     894:	ff 4f       	sbci	r31, 0xFF	; 255
     896:	08 94       	sec
     898:	e1 1c       	adc	r14, r1
     89a:	f1 1c       	adc	r15, r1
     89c:	e4 91       	lpm	r30, Z
                if (p == 0 && (width-x) <= 8)   // early out
     89e:	ee 23       	and	r30, r30
     8a0:	49 f4       	brne	.+18     	; 0x8b4 <_Z8DrawChariii+0x1a2>
#define FNT(_x) pgm_read_byte(Verdana_font_11 + (_x))
#else
#define FNT(_x) Verdana_font_11[_x]
#endif

int DrawChar(int xx, int yy, int c)
     8a2:	c3 01       	movw	r24, r6
     8a4:	80 1b       	sub	r24, r16
     8a6:	91 0b       	sbc	r25, r17
                Graphics::PutPixel(x + xx, y + yy);
            m >>= 1;
            if (m == 0)
            {
                p = FNT(src++);
                if (p == 0 && (width-x) <= 8)   // early out
     8a8:	89 30       	cpi	r24, 0x09	; 9
     8aa:	91 05       	cpc	r25, r1
     8ac:	4c f0       	brlt	.+18     	; 0x8c0 <_Z8DrawChariii+0x1ae>
                    break;
                m = 0x80;
     8ae:	cb 82       	std	Y+3, r12	; 0x03
            if (p & m)
                Graphics::PutPixel(x + xx, y + yy);
            m >>= 1;
            if (m == 0)
            {
                p = FNT(src++);
     8b0:	9c 82       	std	Y+4, r9	; 0x04
     8b2:	02 c0       	rjmp	.+4      	; 0x8b8 <_Z8DrawChariii+0x1a6>
     8b4:	ec 83       	std	Y+4, r30	; 0x04
                if (p == 0 && (width-x) <= 8)   // early out
                    break;
                m = 0x80;
     8b6:	cb 82       	std	Y+3, r12	; 0x03
                Graphics::PutPixel(x + xx, y + yy);
            m >>= 1;
            if (m == 0)
            {
                p = FNT(src++);
                if (p == 0 && (width-x) <= 8)   // early out
     8b8:	0f 5f       	subi	r16, 0xFF	; 255
     8ba:	1f 4f       	sbci	r17, 0xFF	; 255
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
    {
        byte p = FNT(src++);
        byte m = mask;
        for (byte x = 0; x < (byte)width; x++)
     8bc:	0d 15       	cp	r16, r13
     8be:	c8 f2       	brcs	.-78     	; 0x872 <_Z8DrawChariii+0x160>
                if (p == 0 && (width-x) <= 8)   // early out
                    break;
                m = 0x80;
            }
        }
        src += makeup;
     8c0:	97 01       	movw	r18, r14
     8c2:	22 0d       	add	r18, r2
     8c4:	33 1d       	adc	r19, r3
    src += (6 + 2 * FNT(4)) * 8;    // start of pixels (roll into cols) 
    byte mask = 0x80 >> (src & 7);  // Mask at start of line
    int end = (src+width) >> 3;     // number of bytes read
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
     8c6:	83 94       	inc	r8
     8c8:	08 94       	sec
     8ca:	a1 1c       	adc	r10, r1
     8cc:	b1 1c       	adc	r11, r1
     8ce:	f9 81       	ldd	r31, Y+1	; 0x01
     8d0:	8f 16       	cp	r8, r31
     8d2:	09 f0       	breq	.+2      	; 0x8d6 <_Z8DrawChariii+0x1c4>
     8d4:	bf cf       	rjmp	.-130    	; 0x854 <_Z8DrawChariii+0x142>
     8d6:	05 c0       	rjmp	.+10     	; 0x8e2 <_Z8DrawChariii+0x1d0>
    //byte* f = Verdana_font_11;
    if (c == 32)
        return FNT(1)>>2;  // Space is 1/4 font height (yuk);

    int i = c - FNT(3);
    if (i < 0 || i >= FNT(4)) return 0;
     8d8:	66 24       	eor	r6, r6
     8da:	77 24       	eor	r7, r7
     8dc:	02 c0       	rjmp	.+4      	; 0x8e2 <_Z8DrawChariii+0x1d0>
     8de:	66 24       	eor	r6, r6
     8e0:	77 24       	eor	r7, r7
            }
        }
        src += makeup;
    }
    return width;
}
     8e2:	86 2d       	mov	r24, r6
     8e4:	97 2d       	mov	r25, r7
     8e6:	0f 90       	pop	r0
     8e8:	0f 90       	pop	r0
     8ea:	0f 90       	pop	r0
     8ec:	0f 90       	pop	r0
     8ee:	df 91       	pop	r29
     8f0:	cf 91       	pop	r28
     8f2:	1f 91       	pop	r17
     8f4:	0f 91       	pop	r16
     8f6:	ff 90       	pop	r15
     8f8:	ef 90       	pop	r14
     8fa:	df 90       	pop	r13
     8fc:	cf 90       	pop	r12
     8fe:	bf 90       	pop	r11
     900:	af 90       	pop	r10
     902:	9f 90       	pop	r9
     904:	8f 90       	pop	r8
     906:	7f 90       	pop	r7
     908:	6f 90       	pop	r6
     90a:	5f 90       	pop	r5
     90c:	4f 90       	pop	r4
     90e:	3f 90       	pop	r3
     910:	2f 90       	pop	r2
     912:	08 95       	ret

00000914 <_ZN8Graphics10DrawStringEPKciii>:

void Graphics::DrawString(const char* s, int len, int x, int y)
{
     914:	af 92       	push	r10
     916:	bf 92       	push	r11
     918:	cf 92       	push	r12
     91a:	df 92       	push	r13
     91c:	ef 92       	push	r14
     91e:	ff 92       	push	r15
     920:	0f 93       	push	r16
     922:	1f 93       	push	r17
     924:	cf 93       	push	r28
     926:	df 93       	push	r29
     928:	08 2f       	mov	r16, r24
     92a:	19 2f       	mov	r17, r25
     92c:	6b 01       	movw	r12, r22
     92e:	ea 01       	movw	r28, r20
     930:	59 01       	movw	r10, r18
    BeginPixels();
     932:	0e 94 3c 03 	call	0x678	; 0x678 <_ZN8Graphics11BeginPixelsEv>
    for (int i = 0; i < len; i++)
     936:	1c 14       	cp	r1, r12
     938:	1d 04       	cpc	r1, r13
     93a:	a4 f4       	brge	.+40     	; 0x964 <_ZN8Graphics10DrawStringEPKciii+0x50>
     93c:	e0 2e       	mov	r14, r16
     93e:	f1 2e       	mov	r15, r17
     940:	00 e0       	ldi	r16, 0x00	; 0
     942:	10 e0       	ldi	r17, 0x00	; 0
        x += DrawChar(x,y,s[i]) + 1;
     944:	f7 01       	movw	r30, r14
     946:	41 91       	ld	r20, Z+
     948:	7f 01       	movw	r14, r30
     94a:	ce 01       	movw	r24, r28
     94c:	b5 01       	movw	r22, r10
     94e:	50 e0       	ldi	r21, 0x00	; 0
     950:	0e 94 89 03 	call	0x712	; 0x712 <_Z8DrawChariii>
     954:	01 96       	adiw	r24, 0x01	; 1
     956:	c8 0f       	add	r28, r24
     958:	d9 1f       	adc	r29, r25
}

void Graphics::DrawString(const char* s, int len, int x, int y)
{
    BeginPixels();
    for (int i = 0; i < len; i++)
     95a:	0f 5f       	subi	r16, 0xFF	; 255
     95c:	1f 4f       	sbci	r17, 0xFF	; 255
     95e:	0c 15       	cp	r16, r12
     960:	1d 05       	cpc	r17, r13
     962:	81 f7       	brne	.-32     	; 0x944 <_ZN8Graphics10DrawStringEPKciii+0x30>
        x += DrawChar(x,y,s[i]) + 1;
}
     964:	df 91       	pop	r29
     966:	cf 91       	pop	r28
     968:	1f 91       	pop	r17
     96a:	0f 91       	pop	r16
     96c:	ff 90       	pop	r15
     96e:	ef 90       	pop	r14
     970:	df 90       	pop	r13
     972:	cf 90       	pop	r12
     974:	bf 90       	pop	r11
     976:	af 90       	pop	r10
     978:	08 95       	ret

0000097a <_ZN8Graphics10DrawStringEPKcii>:

void Graphics::DrawString(const char* s, int x, int y)
{
     97a:	cf 93       	push	r28
     97c:	df 93       	push	r29
     97e:	9b 01       	movw	r18, r22
     980:	ea 01       	movw	r28, r20
    DrawString(s,strlen(s),x,y);
     982:	e8 2f       	mov	r30, r24
     984:	f9 2f       	mov	r31, r25
     986:	df 01       	movw	r26, r30
     988:	0d 90       	ld	r0, X+
     98a:	00 20       	and	r0, r0
     98c:	e9 f7       	brne	.-6      	; 0x988 <_ZN8Graphics10DrawStringEPKcii+0xe>
     98e:	11 97       	sbiw	r26, 0x01	; 1
     990:	bd 01       	movw	r22, r26
     992:	6e 1b       	sub	r22, r30
     994:	7f 0b       	sbc	r23, r31
     996:	a9 01       	movw	r20, r18
     998:	9e 01       	movw	r18, r28
     99a:	0e 94 8a 04 	call	0x914	; 0x914 <_ZN8Graphics10DrawStringEPKciii>
}
     99e:	df 91       	pop	r29
     9a0:	cf 91       	pop	r28
     9a2:	08 95       	ret

000009a4 <_Z3cmpPKhPKc>:
     }
 }
	    
*/
bool cmp(const byte* d, const char* s)
{
     9a4:	fc 01       	movw	r30, r24
    while (*s)
        if (*d++ != *s++)
            return false;
    return true;
     9a6:	a6 2f       	mov	r26, r22
     9a8:	b7 2f       	mov	r27, r23
 }
	    
*/
bool cmp(const byte* d, const char* s)
{
    while (*s)
     9aa:	03 c0       	rjmp	.+6      	; 0x9b2 <_Z3cmpPKhPKc+0xe>
        if (*d++ != *s++)
     9ac:	91 91       	ld	r25, Z+
     9ae:	89 17       	cp	r24, r25
     9b0:	29 f4       	brne	.+10     	; 0x9bc <_Z3cmpPKhPKc+0x18>
 }
	    
*/
bool cmp(const byte* d, const char* s)
{
    while (*s)
     9b2:	8d 91       	ld	r24, X+
     9b4:	88 23       	and	r24, r24
     9b6:	d1 f7       	brne	.-12     	; 0x9ac <_Z3cmpPKhPKc+0x8>
        if (*d++ != *s++)
            return false;
    return true;
     9b8:	81 e0       	ldi	r24, 0x01	; 1
     9ba:	08 95       	ret
*/
bool cmp(const byte* d, const char* s)
{
    while (*s)
        if (*d++ != *s++)
            return false;
     9bc:	80 e0       	ldi	r24, 0x00	; 0
    return true;
}
     9be:	08 95       	ret

000009c0 <_Z5Draw8hPt>:
        }
    }
}
*/
void Draw8(byte c, ushort* color)
{
     9c0:	1f 93       	push	r17
     9c2:	cf 93       	push	r28
     9c4:	df 93       	push	r29
     9c6:	eb 01       	movw	r28, r22
    if (c == 0 || c == 0xFF)
     9c8:	98 2f       	mov	r25, r24
     9ca:	91 50       	subi	r25, 0x01	; 1
     9cc:	9e 3f       	cpi	r25, 0xFE	; 254
     9ce:	90 f0       	brcs	.+36     	; 0x9f4 <_Z5Draw8hPt+0x34>
    {
        LCD::SetColor(color[c == 0 ? 0 : 1]);
     9d0:	88 23       	and	r24, r24
     9d2:	19 f0       	breq	.+6      	; 0x9da <_Z5Draw8hPt+0x1a>
     9d4:	82 e0       	ldi	r24, 0x02	; 2
     9d6:	90 e0       	ldi	r25, 0x00	; 0
     9d8:	02 c0       	rjmp	.+4      	; 0x9de <_Z5Draw8hPt+0x1e>
     9da:	80 e0       	ldi	r24, 0x00	; 0
     9dc:	90 e0       	ldi	r25, 0x00	; 0
     9de:	c8 0f       	add	r28, r24
     9e0:	d9 1f       	adc	r29, r25
     9e2:	88 81       	ld	r24, Y
     9e4:	99 81       	ldd	r25, Y+1	; 0x01
     9e6:	0e 94 c5 06 	call	0xd8a	; 0xd8a <_ZN3LCD8SetColorEt>
        LCD::SolidFill(8);
     9ea:	88 e0       	ldi	r24, 0x08	; 8
     9ec:	90 e0       	ldi	r25, 0x00	; 0
     9ee:	0e 94 ba 07 	call	0xf74	; 0xf74 <_ZN3LCD9SolidFillEt>
        return;
     9f2:	0b c0       	rjmp	.+22     	; 0xa0a <_Z5Draw8hPt+0x4a>
    }
}
*/
void Draw8(byte c, ushort* color)
{
    if (c == 0 || c == 0xFF)
     9f4:	18 e0       	ldi	r17, 0x08	; 8
        return;
    }
    char s = c;
    for (byte i = 0; i < 8; i++)
    {
        LCD::SetColor(color[s < 0 ? 1 : 0]);
     9f6:	88 81       	ld	r24, Y
     9f8:	99 81       	ldd	r25, Y+1	; 0x01
     9fa:	0e 94 c5 06 	call	0xd8a	; 0xd8a <_ZN3LCD8SetColorEt>
        LCD::SolidFill(1);
     9fe:	81 e0       	ldi	r24, 0x01	; 1
     a00:	90 e0       	ldi	r25, 0x00	; 0
     a02:	0e 94 ba 07 	call	0xf74	; 0xf74 <_ZN3LCD9SolidFillEt>
     a06:	11 50       	subi	r17, 0x01	; 1
        LCD::SetColor(color[c == 0 ? 0 : 1]);
        LCD::SolidFill(8);
        return;
    }
    char s = c;
    for (byte i = 0; i < 8; i++)
     a08:	b1 f7       	brne	.-20     	; 0x9f6 <_Z5Draw8hPt+0x36>
    {
        LCD::SetColor(color[s < 0 ? 1 : 0]);
        LCD::SolidFill(1);
        s <<= 1;
    }
}
     a0a:	df 91       	pop	r29
     a0c:	cf 91       	pop	r28
     a0e:	1f 91       	pop	r17
     a10:	08 95       	ret

00000a12 <_ZN8Graphics9Draw8x8x1EiiPKhPt>:

void Graphics::Draw8x8x1(int x, int y, const byte* t, ushort* color)
{
     a12:	cf 92       	push	r12
     a14:	df 92       	push	r13
     a16:	ef 92       	push	r14
     a18:	ff 92       	push	r15
     a1a:	0f 93       	push	r16
     a1c:	1f 93       	push	r17
     a1e:	cf 93       	push	r28
     a20:	df 93       	push	r29
     a22:	8c 01       	movw	r16, r24
     a24:	6b 01       	movw	r12, r22
     a26:	ea 01       	movw	r28, r20
     a28:	79 01       	movw	r14, r18
    LCD::SetWrap(x,y,8,8);
     a2a:	48 e0       	ldi	r20, 0x08	; 8
     a2c:	50 e0       	ldi	r21, 0x00	; 0
     a2e:	28 e0       	ldi	r18, 0x08	; 8
     a30:	30 e0       	ldi	r19, 0x00	; 0
     a32:	0e 94 8b 06 	call	0xd16	; 0xd16 <_ZN3LCD7SetWrapEiiii>
    LCD::SetGRAM(x,y);
     a36:	c8 01       	movw	r24, r16
     a38:	b6 01       	movw	r22, r12
     a3a:	0e 94 b7 06 	call	0xd6e	; 0xd6e <_ZN3LCD7SetGRAMEii>
        LCD::SolidFill(1);
        s <<= 1;
    }
}

void Graphics::Draw8x8x1(int x, int y, const byte* t, ushort* color)
     a3e:	8e 01       	movw	r16, r28
     a40:	08 5f       	subi	r16, 0xF8	; 248
     a42:	1f 4f       	sbci	r17, 0xFF	; 255
{
    LCD::SetWrap(x,y,8,8);
    LCD::SetGRAM(x,y);
    for (int i = 0; i < 8; i++)
        Draw8(*t++,color);
     a44:	89 91       	ld	r24, Y+
     a46:	b7 01       	movw	r22, r14
     a48:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <_Z5Draw8hPt>

void Graphics::Draw8x8x1(int x, int y, const byte* t, ushort* color)
{
    LCD::SetWrap(x,y,8,8);
    LCD::SetGRAM(x,y);
    for (int i = 0; i < 8; i++)
     a4c:	c0 17       	cp	r28, r16
     a4e:	d1 07       	cpc	r29, r17
     a50:	c9 f7       	brne	.-14     	; 0xa44 <_ZN8Graphics9Draw8x8x1EiiPKhPt+0x32>
        Draw8(*t++,color);
}
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	1f 91       	pop	r17
     a58:	0f 91       	pop	r16
     a5a:	ff 90       	pop	r15
     a5c:	ef 90       	pop	r14
     a5e:	df 90       	pop	r13
     a60:	cf 90       	pop	r12
     a62:	08 95       	ret

00000a64 <_ZN8Graphics9Draw8x8x8EiiPKhPt>:

void Graphics::Draw8x8x8(int x, int y, const byte* t, ushort* color)
{
}
     a64:	08 95       	ret

00000a66 <_Z10init_portsv>:

void init_ports()
{
	/* Disable JTAG in software, so that it does not interfere with Port C  */
	/* It will be re-enabled after a power cycle if the JTAGEN fuse is set. */
	MCUCR |=(1<<JTD);
     a66:	85 b7       	in	r24, 0x35	; 53
     a68:	80 68       	ori	r24, 0x80	; 128
     a6a:	85 bf       	out	0x35, r24	; 53
	MCUCR |=(1<<JTD);
     a6c:	85 b7       	in	r24, 0x35	; 53
     a6e:	80 68       	ori	r24, 0x80	; 128
     a70:	85 bf       	out	0x35, r24	; 53
	
	CTRL_DDR = 0x7F;
     a72:	8f e7       	ldi	r24, 0x7F	; 127
     a74:	8a b9       	out	0x0a, r24	; 10
	DATA_DDR = 0xFF;
     a76:	8f ef       	ldi	r24, 0xFF	; 255
     a78:	84 b9       	out	0x04, r24	; 4
}
     a7a:	08 95       	ret

00000a7c <_Z8delay_msj>:

void delay_ms(uint16_t m)
{
	uint16_t i;
	for(i=0; i<m; i++)
     a7c:	00 97       	sbiw	r24, 0x00	; 0
     a7e:	69 f0       	breq	.+26     	; 0xa9a <_Z8delay_msj+0x1e>
     a80:	20 e0       	ldi	r18, 0x00	; 0
     a82:	30 e0       	ldi	r19, 0x00	; 0
     a84:	e9 ef       	ldi	r30, 0xF9	; 249
     a86:	f0 e0       	ldi	r31, 0x00	; 0
     a88:	31 97       	sbiw	r30, 0x01	; 1
     a8a:	f1 f7       	brne	.-4      	; 0xa88 <_Z8delay_msj+0xc>
     a8c:	00 c0       	rjmp	.+0      	; 0xa8e <_Z8delay_msj+0x12>
     a8e:	00 00       	nop
     a90:	2f 5f       	subi	r18, 0xFF	; 255
     a92:	3f 4f       	sbci	r19, 0xFF	; 255
     a94:	28 17       	cp	r18, r24
     a96:	39 07       	cpc	r19, r25
     a98:	a9 f7       	brne	.-22     	; 0xa84 <_Z8delay_msj+0x8>
     a9a:	08 95       	ret

00000a9c <_ZN3LCD4InitEv>:
}

void LCD::Init()
{
	uint16_t x, y;
	init_ports();
     a9c:	0e 94 33 05 	call	0xa66	; 0xa66 <_Z10init_portsv>
	RESET_lo();
     aa0:	5a 98       	cbi	0x0b, 2	; 11
	delay_ms(100);
     aa2:	84 e6       	ldi	r24, 0x64	; 100
     aa4:	90 e0       	ldi	r25, 0x00	; 0
     aa6:	0e 94 3e 05 	call	0xa7c	; 0xa7c <_Z8delay_msj>
	RESET_hi();
     aaa:	5a 9a       	sbi	0x0b, 2	; 11
	delay_ms(100);
     aac:	84 e6       	ldi	r24, 0x64	; 100
     aae:	90 e0       	ldi	r25, 0x00	; 0
     ab0:	0e 94 3e 05 	call	0xa7c	; 0xa7c <_Z8delay_msj>
	RS_hi();
     ab4:	5c 9a       	sbi	0x0b, 4	; 11
	WR_hi();
     ab6:	5b 9a       	sbi	0x0b, 3	; 11
	RD_hi(); 
     ab8:	5d 9a       	sbi	0x0b, 5	; 11
	CS_lo();
     aba:	58 98       	cbi	0x0b, 0	; 11
	BLC_lo();
     abc:	59 98       	cbi	0x0b, 1	; 11
	VSYNC_hi();
     abe:	5e 9a       	sbi	0x0b, 6	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     ac0:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     ac2:	88 e2       	ldi	r24, 0x28	; 40
     ac4:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     ac6:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     ac8:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     aca:	5c 9a       	sbi	0x0b, 4	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     acc:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     ace:	81 e1       	ldi	r24, 0x11	; 17
     ad0:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     ad2:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     ad4:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     ad6:	5c 9a       	sbi	0x0b, 4	; 11
	CS_lo();
	BLC_lo();
	VSYNC_hi();
	write_cmd(DISPLAY_OFF);
	write_cmd(SLEEP_OUT);
	delay_ms(60);
     ad8:	8c e3       	ldi	r24, 0x3C	; 60
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	0e 94 3e 05 	call	0xa7c	; 0xa7c <_Z8delay_msj>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     ae0:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     ae2:	8b ec       	ldi	r24, 0xCB	; 203
     ae4:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     ae6:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     ae8:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     aea:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     aec:	81 e0       	ldi	r24, 0x01	; 1
     aee:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     af0:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     af2:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     af4:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     af6:	80 ec       	ldi	r24, 0xC0	; 192
     af8:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     afa:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     afc:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     afe:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b00:	86 e2       	ldi	r24, 0x26	; 38
     b02:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b04:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b06:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b08:	88 e0       	ldi	r24, 0x08	; 8
     b0a:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b0c:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b0e:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     b10:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     b12:	81 ec       	ldi	r24, 0xC1	; 193
     b14:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b16:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b18:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     b1a:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b1c:	80 e1       	ldi	r24, 0x10	; 16
     b1e:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b20:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b22:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     b24:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     b26:	85 ec       	ldi	r24, 0xC5	; 197
     b28:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b2a:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b2c:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     b2e:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b30:	85 e3       	ldi	r24, 0x35	; 53
     b32:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b34:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b36:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b38:	8e e3       	ldi	r24, 0x3E	; 62
     b3a:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b3c:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b3e:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     b40:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     b42:	86 e3       	ldi	r24, 0x36	; 54
     b44:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b46:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b48:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     b4a:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b4c:	88 e4       	ldi	r24, 0x48	; 72
     b4e:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b50:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b52:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     b54:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     b56:	80 eb       	ldi	r24, 0xB0	; 176
     b58:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b5a:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b5c:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     b5e:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b60:	8a e4       	ldi	r24, 0x4A	; 74
     b62:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b64:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b66:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     b68:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     b6a:	81 eb       	ldi	r24, 0xB1	; 177
     b6c:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b6e:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b70:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     b72:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b74:	15 b8       	out	0x05, r1	; 5
	WR_lo();
     b76:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b78:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b7a:	8b e1       	ldi	r24, 0x1B	; 27
     b7c:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b7e:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b80:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     b82:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     b84:	86 eb       	ldi	r24, 0xB6	; 182
     b86:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b88:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b8a:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     b8c:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     b8e:	ee e4       	ldi	r30, 0x4E	; 78
     b90:	f1 e0       	ldi	r31, 0x01	; 1
     b92:	cf 01       	movw	r24, r30
     b94:	04 96       	adiw	r24, 0x04	; 4
__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
     b96:	21 91       	ld	r18, Z+
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b98:	25 b9       	out	0x05, r18	; 5
	WR_lo();
     b9a:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b9c:	5b 9a       	sbi	0x0b, 3	; 11

__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
     b9e:	e8 17       	cp	r30, r24
     ba0:	f9 07       	cpc	r31, r25
     ba2:	c9 f7       	brne	.-14     	; 0xb96 <_ZN3LCD4InitEv+0xfa>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     ba4:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     ba6:	87 ec       	ldi	r24, 0xC7	; 199
     ba8:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     baa:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     bac:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     bae:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     bb0:	85 eb       	ldi	r24, 0xB5	; 181
     bb2:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     bb4:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     bb6:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     bb8:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     bba:	86 ef       	ldi	r24, 0xF6	; 246
     bbc:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     bbe:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     bc0:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     bc2:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     bc4:	ea e4       	ldi	r30, 0x4A	; 74
     bc6:	f1 e0       	ldi	r31, 0x01	; 1
     bc8:	cf 01       	movw	r24, r30
     bca:	03 96       	adiw	r24, 0x03	; 3
__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
     bcc:	21 91       	ld	r18, Z+
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     bce:	25 b9       	out	0x05, r18	; 5
	WR_lo();
     bd0:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     bd2:	5b 9a       	sbi	0x0b, 3	; 11

__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
     bd4:	e8 17       	cp	r30, r24
     bd6:	f9 07       	cpc	r31, r25
     bd8:	c9 f7       	brne	.-14     	; 0xbcc <_ZN3LCD4InitEv+0x130>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     bda:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     bdc:	82 ef       	ldi	r24, 0xF2	; 242
     bde:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     be0:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     be2:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     be4:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     be6:	15 b8       	out	0x05, r1	; 5
	WR_lo();
     be8:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     bea:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     bec:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     bee:	86 e2       	ldi	r24, 0x26	; 38
     bf0:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     bf2:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     bf4:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     bf6:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     bf8:	81 e0       	ldi	r24, 0x01	; 1
     bfa:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     bfc:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     bfe:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     c00:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     c02:	8a e3       	ldi	r24, 0x3A	; 58
     c04:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     c06:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c08:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     c0a:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c0c:	85 e5       	ldi	r24, 0x55	; 85
     c0e:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     c10:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c12:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     c14:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     c16:	80 ee       	ldi	r24, 0xE0	; 224
     c18:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     c1a:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c1c:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     c1e:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     c20:	ea e3       	ldi	r30, 0x3A	; 58
     c22:	f1 e0       	ldi	r31, 0x01	; 1
     c24:	cf 01       	movw	r24, r30
     c26:	0f 96       	adiw	r24, 0x0f	; 15
__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
     c28:	21 91       	ld	r18, Z+
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c2a:	25 b9       	out	0x05, r18	; 5
	WR_lo();
     c2c:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c2e:	5b 9a       	sbi	0x0b, 3	; 11

__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
     c30:	e8 17       	cp	r30, r24
     c32:	f9 07       	cpc	r31, r25
     c34:	c9 f7       	brne	.-14     	; 0xc28 <_ZN3LCD4InitEv+0x18c>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     c36:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     c38:	81 ee       	ldi	r24, 0xE1	; 225
     c3a:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     c3c:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c3e:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     c40:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     c42:	ea e2       	ldi	r30, 0x2A	; 42
     c44:	f1 e0       	ldi	r31, 0x01	; 1
     c46:	cf 01       	movw	r24, r30
     c48:	0f 96       	adiw	r24, 0x0f	; 15
__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
     c4a:	21 91       	ld	r18, Z+
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c4c:	25 b9       	out	0x05, r18	; 5
	WR_lo();
     c4e:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c50:	5b 9a       	sbi	0x0b, 3	; 11

__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
     c52:	e8 17       	cp	r30, r24
     c54:	f9 07       	cpc	r31, r25
     c56:	c9 f7       	brne	.-14     	; 0xc4a <_ZN3LCD4InitEv+0x1ae>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     c58:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     c5a:	8a e2       	ldi	r24, 0x2A	; 42
     c5c:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     c5e:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c60:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     c62:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     c64:	e5 e2       	ldi	r30, 0x25	; 37
     c66:	f1 e0       	ldi	r31, 0x01	; 1
     c68:	cf 01       	movw	r24, r30
     c6a:	04 96       	adiw	r24, 0x04	; 4
__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
     c6c:	21 91       	ld	r18, Z+
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c6e:	25 b9       	out	0x05, r18	; 5
	WR_lo();
     c70:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c72:	5b 9a       	sbi	0x0b, 3	; 11

__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
     c74:	e8 17       	cp	r30, r24
     c76:	f9 07       	cpc	r31, r25
     c78:	c9 f7       	brne	.-14     	; 0xc6c <_ZN3LCD4InitEv+0x1d0>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     c7a:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     c7c:	8b e2       	ldi	r24, 0x2B	; 43
     c7e:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     c80:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c82:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     c84:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     c86:	e0 e2       	ldi	r30, 0x20	; 32
     c88:	f1 e0       	ldi	r31, 0x01	; 1
     c8a:	cf 01       	movw	r24, r30
     c8c:	04 96       	adiw	r24, 0x04	; 4
__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
     c8e:	21 91       	ld	r18, Z+
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c90:	25 b9       	out	0x05, r18	; 5
	WR_lo();
     c92:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c94:	5b 9a       	sbi	0x0b, 3	; 11

__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
     c96:	e8 17       	cp	r30, r24
     c98:	f9 07       	cpc	r31, r25
     c9a:	c9 f7       	brne	.-14     	; 0xc8e <_ZN3LCD4InitEv+0x1f2>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     c9c:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     c9e:	84 e3       	ldi	r24, 0x34	; 52
     ca0:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     ca2:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     ca4:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     ca6:	5c 9a       	sbi	0x0b, 4	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     ca8:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     caa:	84 eb       	ldi	r24, 0xB4	; 180
     cac:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     cae:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     cb0:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     cb2:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     cb4:	15 b8       	out	0x05, r1	; 5
	WR_lo();
     cb6:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     cb8:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     cba:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     cbc:	87 eb       	ldi	r24, 0xB7	; 183
     cbe:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     cc0:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     cc2:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     cc4:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     cc6:	87 e0       	ldi	r24, 0x07	; 7
     cc8:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     cca:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     ccc:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     cce:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     cd0:	8c e2       	ldi	r24, 0x2C	; 44
     cd2:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     cd4:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     cd6:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     cd8:	5c 9a       	sbi	0x0b, 4	; 11
     cda:	20 ef       	ldi	r18, 0xF0	; 240
     cdc:	30 e0       	ldi	r19, 0x00	; 0
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     cde:	40 e4       	ldi	r20, 0x40	; 64
     ce0:	51 e0       	ldi	r21, 0x01	; 1
     ce2:	0b c0       	rjmp	.+22     	; 0xcfa <_ZN3LCD4InitEv+0x25e>
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     ce4:	15 b8       	out	0x05, r1	; 5
	WR_lo();
     ce6:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     ce8:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     cea:	15 b8       	out	0x05, r1	; 5
	WR_lo();
     cec:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     cee:	5b 9a       	sbi	0x0b, 3	; 11
     cf0:	01 97       	sbiw	r24, 0x01	; 1
    write_cmd(TEARING_EFFECT_LINE_OFF);
    write_cmd_data(DISPLAY_INVERSION_CONTROL,	 1, "\x00");
    write_cmd_data(ENTRY_MODE_SET,				 1, "\x07");
	write_cmd(MEMORY_WRITE);
	for(x=0; x<240; x++)
		for(y=0; y<320; y++)
     cf2:	c1 f7       	brne	.-16     	; 0xce4 <_ZN3LCD4InitEv+0x248>
     cf4:	21 50       	subi	r18, 0x01	; 1
     cf6:	30 40       	sbci	r19, 0x00	; 0
    write_cmd_data(PAGE_ADDRESS_SET,			 4, "\x00\x00\x01\x3F");
    write_cmd(TEARING_EFFECT_LINE_OFF);
    write_cmd_data(DISPLAY_INVERSION_CONTROL,	 1, "\x00");
    write_cmd_data(ENTRY_MODE_SET,				 1, "\x07");
	write_cmd(MEMORY_WRITE);
	for(x=0; x<240; x++)
     cf8:	11 f0       	breq	.+4      	; 0xcfe <_ZN3LCD4InitEv+0x262>
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     cfa:	ca 01       	movw	r24, r20
     cfc:	f3 cf       	rjmp	.-26     	; 0xce4 <_ZN3LCD4InitEv+0x248>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     cfe:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     d00:	89 e2       	ldi	r24, 0x29	; 41
     d02:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     d04:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     d06:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     d08:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(MEMORY_WRITE);
	for(x=0; x<240; x++)
		for(y=0; y<320; y++)
			write_data16(0x0000);
	write_cmd(DISPLAY_ON);
	delay_ms(50);
     d0a:	82 e3       	ldi	r24, 0x32	; 50
     d0c:	90 e0       	ldi	r25, 0x00	; 0
     d0e:	0e 94 3e 05 	call	0xa7c	; 0xa7c <_Z8delay_msj>
	BLC_hi();
     d12:	59 9a       	sbi	0x0b, 1	; 11
};
     d14:	08 95       	ret

00000d16 <_ZN3LCD7SetWrapEiiii>:

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     d16:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     d18:	ea e2       	ldi	r30, 0x2A	; 42
     d1a:	e5 b9       	out	0x05, r30	; 5
	WR_lo();
     d1c:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     d1e:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     d20:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     d22:	95 b9       	out	0x05, r25	; 5
	WR_lo();
     d24:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     d26:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     d28:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     d2a:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     d2c:	5b 9a       	sbi	0x0b, 3	; 11
 //   WriteLcdReg(0x44,((x + width - 1) << 8) | x);   //  Horizontal RAM start and end address
 //   WriteLcdReg(0x45,y);                            //  Vertical RAM start address
 //   WriteLcdReg(0x46,y + height-1);                 //  Vertical RAM end address
	write_cmd(COLUMN_ADDRESS_SET);
	write_data16(x);
	write_data16(x + width-1);
     d2e:	84 0f       	add	r24, r20
     d30:	95 1f       	adc	r25, r21
     d32:	01 97       	sbiw	r24, 0x01	; 1
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     d34:	95 b9       	out	0x05, r25	; 5
	WR_lo();
     d36:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     d38:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     d3a:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     d3c:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     d3e:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     d40:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     d42:	8b e2       	ldi	r24, 0x2B	; 43
     d44:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     d46:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     d48:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     d4a:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     d4c:	75 b9       	out	0x05, r23	; 5
	WR_lo();
     d4e:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     d50:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     d52:	65 b9       	out	0x05, r22	; 5
	WR_lo();
     d54:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     d56:	5b 9a       	sbi	0x0b, 3	; 11
	write_cmd(COLUMN_ADDRESS_SET);
	write_data16(x);
	write_data16(x + width-1);
	write_cmd(PAGE_ADDRESS_SET);
	write_data16(y);
	write_data16(y + height-1);
     d58:	62 0f       	add	r22, r18
     d5a:	73 1f       	adc	r23, r19
     d5c:	61 50       	subi	r22, 0x01	; 1
     d5e:	70 40       	sbci	r23, 0x00	; 0
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     d60:	75 b9       	out	0x05, r23	; 5
	WR_lo();
     d62:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     d64:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     d66:	65 b9       	out	0x05, r22	; 5
	WR_lo();
     d68:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     d6a:	5b 9a       	sbi	0x0b, 3	; 11
	write_data16(x);
	write_data16(x + width-1);
	write_cmd(PAGE_ADDRESS_SET);
	write_data16(y);
	write_data16(y + height-1);
}
     d6c:	08 95       	ret

00000d6e <_ZN3LCD7SetGRAMEii>:

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     d6e:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     d70:	8c e2       	ldi	r24, 0x2C	; 44
     d72:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     d74:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     d76:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     d78:	5c 9a       	sbi	0x0b, 4	; 11
{
//      WriteLcdReg(LCD_GRAM_HOR_AD,x);  //  GDDRAM X
//      WriteLcdReg(LCD_GRAM_VER_AD,y);  //  GDDRAM Y
//      WriteLcdRegAddress(LCD_RW_GRAM);
	write_cmd(MEMORY_WRITE);
}
     d7a:	08 95       	ret

00000d7c <_ZN3LCD14HardwareScrollEi>:
/*    while (y < 0)
        y += 320;
    while (y >= 320)
        y -= 320;
    WriteLcdReg(0x41,y); */
}
     d7c:	08 95       	ret

00000d7e <_ZN3LCD8GetWidthEv>:
}
*/
ushort LCD::GetWidth()
{
    return 240;
}
     d7e:	80 ef       	ldi	r24, 0xF0	; 240
     d80:	90 e0       	ldi	r25, 0x00	; 0
     d82:	08 95       	ret

00000d84 <_ZN3LCD9GetHeightEv>:

ushort LCD::GetHeight()
{
    return 320;
}
     d84:	80 e4       	ldi	r24, 0x40	; 64
     d86:	91 e0       	ldi	r25, 0x01	; 1
     d88:	08 95       	ret

00000d8a <_ZN3LCD8SetColorEt>:

void LCD::SetColor(ushort color)
{
    _color = color;
     d8a:	90 93 a9 02 	sts	0x02A9, r25
     d8e:	80 93 a8 02 	sts	0x02A8, r24
}
     d92:	08 95       	ret

00000d94 <_ZN3LCD8OpenWrapEv>:
{
    Blit(count, _color >> 8, _color);
}

void LCD::OpenWrap()
{
     d94:	cf 93       	push	r28
     d96:	df 93       	push	r29
    SetWrap(0,0,GetWidth(),GetHeight());
     d98:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN3LCD8GetWidthEv>
     d9c:	ec 01       	movw	r28, r24
     d9e:	0e 94 c2 06 	call	0xd84	; 0xd84 <_ZN3LCD9GetHeightEv>
     da2:	9c 01       	movw	r18, r24
     da4:	80 e0       	ldi	r24, 0x00	; 0
     da6:	90 e0       	ldi	r25, 0x00	; 0
     da8:	60 e0       	ldi	r22, 0x00	; 0
     daa:	70 e0       	ldi	r23, 0x00	; 0
     dac:	ae 01       	movw	r20, r28
     dae:	0e 94 8b 06 	call	0xd16	; 0xd16 <_ZN3LCD7SetWrapEiiii>
}
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	08 95       	ret

00000db8 <_ZN3LCD6PixelsEiPKh>:

void LCD::Pixels(int count, const byte* d)
{
     db8:	fb 01       	movw	r30, r22
    DATAOUT;
     dba:	2f ef       	ldi	r18, 0xFF	; 255
     dbc:	24 b9       	out	0x04, r18	; 4
    byte w1 = CONTROLPORT;
     dbe:	42 b1       	in	r20, 0x02	; 2
    byte w0 = w1 & ~(1 << WR);
     dc0:	54 2f       	mov	r21, r20
     dc2:	57 7f       	andi	r21, 0xF7	; 247

    byte slow = count & 0x03;
     dc4:	28 2f       	mov	r18, r24
     dc6:	23 70       	andi	r18, 0x03	; 3
    if (slow)
     dc8:	b9 f0       	breq	.+46     	; 0xdf8 <_ZN3LCD6PixelsEiPKh+0x40>
     dca:	32 2f       	mov	r19, r18
     dcc:	db 01       	movw	r26, r22
    {
        do {
        	DATA_PORT = d[0];
     dce:	6c 91       	ld	r22, X
     dd0:	65 b9       	out	0x05, r22	; 5
            CONTROLPORT = w0;
     dd2:	52 b9       	out	0x02, r21	; 2
            CONTROLPORT = w1;
     dd4:	42 b9       	out	0x02, r20	; 2
            DATA_PORT = d[1];
     dd6:	11 96       	adiw	r26, 0x01	; 1
     dd8:	6c 91       	ld	r22, X
     dda:	11 97       	sbiw	r26, 0x01	; 1
     ddc:	65 b9       	out	0x05, r22	; 5
            CONTROLPORT = w0;
     dde:	52 b9       	out	0x02, r21	; 2
            CONTROLPORT = w1;
     de0:	42 b9       	out	0x02, r20	; 2
            d+=2;
     de2:	12 96       	adiw	r26, 0x02	; 2
    byte w0 = w1 & ~(1 << WR);

    byte slow = count & 0x03;
    if (slow)
    {
        do {
     de4:	31 50       	subi	r19, 0x01	; 1
     de6:	99 f7       	brne	.-26     	; 0xdce <_ZN3LCD6PixelsEiPKh+0x16>
void LCD::OpenWrap()
{
    SetWrap(0,0,GetWidth(),GetHeight());
}

void LCD::Pixels(int count, const byte* d)
     de8:	21 50       	subi	r18, 0x01	; 1
     dea:	30 e0       	ldi	r19, 0x00	; 0
     dec:	2f 5f       	subi	r18, 0xFF	; 255
     dee:	3f 4f       	sbci	r19, 0xFF	; 255
     df0:	22 0f       	add	r18, r18
     df2:	33 1f       	adc	r19, r19
    byte w0 = w1 & ~(1 << WR);

    byte slow = count & 0x03;
    if (slow)
    {
        do {
     df4:	e2 0f       	add	r30, r18
     df6:	f3 1f       	adc	r31, r19
            d+=2;
        } while (--slow);
    }
    
    // x4 unrolled
    count >>= 2;
     df8:	95 95       	asr	r25
     dfa:	87 95       	ror	r24
     dfc:	95 95       	asr	r25
     dfe:	87 95       	ror	r24
    if (count)
     e00:	00 97       	sbiw	r24, 0x00	; 0
     e02:	31 f1       	breq	.+76     	; 0xe50 <_ZN3LCD6PixelsEiPKh+0x98>
    {
        byte w1 = CONTROLPORT;
     e04:	22 b1       	in	r18, 0x02	; 2
        byte w0 = w1 & ~(1 << WR);
     e06:	32 2f       	mov	r19, r18
     e08:	37 7f       	andi	r19, 0xF7	; 247
        do {
        	DATA_PORT = d[0];
     e0a:	40 81       	ld	r20, Z
     e0c:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     e0e:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     e10:	22 b9       	out	0x02, r18	; 2
            DATA_PORT = d[1];
     e12:	41 81       	ldd	r20, Z+1	; 0x01
     e14:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     e16:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     e18:	22 b9       	out	0x02, r18	; 2
        	DATA_PORT = d[2];
     e1a:	42 81       	ldd	r20, Z+2	; 0x02
     e1c:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     e1e:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     e20:	22 b9       	out	0x02, r18	; 2
            DATA_PORT = d[3];
     e22:	43 81       	ldd	r20, Z+3	; 0x03
     e24:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     e26:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     e28:	22 b9       	out	0x02, r18	; 2
        	DATA_PORT = d[4];
     e2a:	44 81       	ldd	r20, Z+4	; 0x04
     e2c:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     e2e:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     e30:	22 b9       	out	0x02, r18	; 2
            DATA_PORT = d[5];
     e32:	45 81       	ldd	r20, Z+5	; 0x05
     e34:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     e36:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     e38:	22 b9       	out	0x02, r18	; 2
        	DATA_PORT = d[6];
     e3a:	46 81       	ldd	r20, Z+6	; 0x06
     e3c:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     e3e:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     e40:	22 b9       	out	0x02, r18	; 2
            DATA_PORT = d[7];
     e42:	47 81       	ldd	r20, Z+7	; 0x07
     e44:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     e46:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     e48:	22 b9       	out	0x02, r18	; 2
            d += 8;
     e4a:	38 96       	adiw	r30, 0x08	; 8
    count >>= 2;
    if (count)
    {
        byte w1 = CONTROLPORT;
        byte w0 = w1 & ~(1 << WR);
        do {
     e4c:	01 97       	sbiw	r24, 0x01	; 1
     e4e:	e9 f6       	brne	.-70     	; 0xe0a <_ZN3LCD6PixelsEiPKh+0x52>
     e50:	08 95       	ret

00000e52 <_ZN3LCD13PixelsIndexedEiPKhS1_>:
        } while (--count);
    }
}

void LCD::PixelsIndexed(int count, const byte* d, const byte* palette)
{
     e52:	ff 92       	push	r15
     e54:	0f 93       	push	r16
     e56:	1f 93       	push	r17
     e58:	cf 93       	push	r28
     e5a:	df 93       	push	r29
     e5c:	8c 01       	movw	r16, r24
     e5e:	eb 01       	movw	r28, r22
     e60:	ba 01       	movw	r22, r20
    byte w1 = CONTROLPORT;
     e62:	22 b1       	in	r18, 0x02	; 2
    byte w0 = w1 & ~(1 << WR);
     e64:	32 2f       	mov	r19, r18
     e66:	37 7f       	andi	r19, 0xF7	; 247

    // Looks fussy but it attempts to be fast
    while (count)
     e68:	00 97       	sbiw	r24, 0x00	; 0
     e6a:	91 f1       	breq	.+100    	; 0xed0 <_ZN3LCD13PixelsIndexedEiPKhS1_+0x7e>
    {
        byte c = 255;
     e6c:	ff 24       	eor	r15, r15
     e6e:	fa 94       	dec	r15
        if (count < c)
            c = count;
        byte p = d[0];
        byte i = 0;
     e70:	50 e0       	ldi	r21, 0x00	; 0

    // Looks fussy but it attempts to be fast
    while (count)
    {
        byte c = 255;
        if (count < c)
     e72:	0f 3f       	cpi	r16, 0xFF	; 255
     e74:	11 05       	cpc	r17, r1
     e76:	14 f4       	brge	.+4      	; 0xe7c <_ZN3LCD13PixelsIndexedEiPKhS1_+0x2a>
            c = count;
     e78:	80 2f       	mov	r24, r16
     e7a:	01 c0       	rjmp	.+2      	; 0xe7e <_ZN3LCD13PixelsIndexedEiPKhS1_+0x2c>
    byte w0 = w1 & ~(1 << WR);

    // Looks fussy but it attempts to be fast
    while (count)
    {
        byte c = 255;
     e7c:	8f 2d       	mov	r24, r15
        if (count < c)
            c = count;
        byte p = d[0];
     e7e:	48 81       	ld	r20, Y
        byte i = 0;
     e80:	95 2f       	mov	r25, r21
     e82:	01 c0       	rjmp	.+2      	; 0xe86 <_ZN3LCD13PixelsIndexedEiPKhS1_+0x34>
                CONTROLPORT = w0;
                CONTROLPORT = w1;
                DATA_PORT = b[1];
                CONTROLPORT = w0;
                CONTROLPORT = w1;
                n = d[++i];
     e84:	4e 2f       	mov	r20, r30
            c = count;
        byte p = d[0];
        byte i = 0;
        do
        {
            const byte* b = palette + p*2;
     e86:	a4 2f       	mov	r26, r20
     e88:	b0 e0       	ldi	r27, 0x00	; 0
     e8a:	aa 0f       	add	r26, r26
     e8c:	bb 1f       	adc	r27, r27
     e8e:	a6 0f       	add	r26, r22
     e90:	b7 1f       	adc	r27, r23
            byte n;
            do
            {
                DATA_PORT = b[0];
     e92:	ec 91       	ld	r30, X
     e94:	e5 b9       	out	0x05, r30	; 5
                CONTROLPORT = w0;
     e96:	32 b9       	out	0x02, r19	; 2
                CONTROLPORT = w1;
     e98:	22 b9       	out	0x02, r18	; 2
                DATA_PORT = b[1];
     e9a:	11 96       	adiw	r26, 0x01	; 1
     e9c:	ec 91       	ld	r30, X
     e9e:	11 97       	sbiw	r26, 0x01	; 1
     ea0:	e5 b9       	out	0x05, r30	; 5
                CONTROLPORT = w0;
     ea2:	32 b9       	out	0x02, r19	; 2
                CONTROLPORT = w1;
     ea4:	22 b9       	out	0x02, r18	; 2
                n = d[++i];
     ea6:	9f 5f       	subi	r25, 0xFF	; 255
     ea8:	fe 01       	movw	r30, r28
     eaa:	e9 0f       	add	r30, r25
     eac:	f1 1d       	adc	r31, r1
     eae:	e0 81       	ld	r30, Z
        byte i = 0;
        do
        {
            const byte* b = palette + p*2;
            byte n;
            do
     eb0:	4e 17       	cp	r20, r30
     eb2:	59 f4       	brne	.+22     	; 0xeca <_ZN3LCD13PixelsIndexedEiPKhS1_+0x78>
     eb4:	98 17       	cp	r25, r24
     eb6:	68 f3       	brcs	.-38     	; 0xe92 <_ZN3LCD13PixelsIndexedEiPKhS1_+0x40>
                CONTROLPORT = w1;
                n = d[++i];
            } while (p == n && i < c);
            p = n;
        } while (i < c);
        count -= c;
     eb8:	90 e0       	ldi	r25, 0x00	; 0
     eba:	08 1b       	sub	r16, r24
     ebc:	19 0b       	sbc	r17, r25
        d += c;
     ebe:	c8 0f       	add	r28, r24
     ec0:	d9 1f       	adc	r29, r25
{
    byte w1 = CONTROLPORT;
    byte w0 = w1 & ~(1 << WR);

    // Looks fussy but it attempts to be fast
    while (count)
     ec2:	01 15       	cp	r16, r1
     ec4:	11 05       	cpc	r17, r1
     ec6:	a9 f6       	brne	.-86     	; 0xe72 <_ZN3LCD13PixelsIndexedEiPKhS1_+0x20>
     ec8:	03 c0       	rjmp	.+6      	; 0xed0 <_ZN3LCD13PixelsIndexedEiPKhS1_+0x7e>
        byte c = 255;
        if (count < c)
            c = count;
        byte p = d[0];
        byte i = 0;
        do
     eca:	98 17       	cp	r25, r24
     ecc:	d8 f2       	brcs	.-74     	; 0xe84 <_ZN3LCD13PixelsIndexedEiPKhS1_+0x32>
     ece:	f4 cf       	rjmp	.-24     	; 0xeb8 <_ZN3LCD13PixelsIndexedEiPKhS1_+0x66>
            p = n;
        } while (i < c);
        count -= c;
        d += c;
    }
}
     ed0:	df 91       	pop	r29
     ed2:	cf 91       	pop	r28
     ed4:	1f 91       	pop	r17
     ed6:	0f 91       	pop	r16
     ed8:	ff 90       	pop	r15
     eda:	08 95       	ret

00000edc <_Z4Blitjhh>:
    LCD::SolidFill(count);
}

void Blit(uint16_t count, byte a, byte b)
{
    DATAOUT;
     edc:	2f ef       	ldi	r18, 0xFF	; 255
     ede:	24 b9       	out	0x04, r18	; 4
    
    byte slow = count & 0x07;
     ee0:	28 2f       	mov	r18, r24
     ee2:	27 70       	andi	r18, 0x07	; 7
    if (slow)
     ee4:	41 f0       	breq	.+16     	; 0xef6 <_Z4Blitjhh+0x1a>
    {
        do {
            DATA_PORT = a;
     ee6:	65 b9       	out	0x05, r22	; 5
            WR0;
     ee8:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     eea:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     eec:	45 b9       	out	0x05, r20	; 5
            WR0;
     eee:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     ef0:	5b 9a       	sbi	0x0b, 3	; 11
    DATAOUT;
    
    byte slow = count & 0x07;
    if (slow)
    {
        do {
     ef2:	21 50       	subi	r18, 0x01	; 1
     ef4:	c1 f7       	brne	.-16     	; 0xee6 <_Z4Blitjhh+0xa>
            WR1;
        } while (--slow);
    }
    
    // x8 unrolled
    count >>= 3;
     ef6:	96 95       	lsr	r25
     ef8:	87 95       	ror	r24
     efa:	96 95       	lsr	r25
     efc:	87 95       	ror	r24
     efe:	96 95       	lsr	r25
     f00:	87 95       	ror	r24
    if (count)
     f02:	00 97       	sbiw	r24, 0x00	; 0
     f04:	99 f1       	breq	.+102    	; 0xf6c <_Z4Blitjhh+0x90>
    {
        byte w1 = CONTROLPORT;
     f06:	22 b1       	in	r18, 0x02	; 2
        byte w0 = w1 & ~(1 << WR);
        do {
            DATA_PORT = a;
     f08:	65 b9       	out	0x05, r22	; 5
            WR0;
     f0a:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f0c:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     f0e:	45 b9       	out	0x05, r20	; 5
            WR0;
     f10:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f12:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = a;
     f14:	65 b9       	out	0x05, r22	; 5
            WR0;
     f16:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f18:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     f1a:	45 b9       	out	0x05, r20	; 5
            WR0;
     f1c:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f1e:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = a;
     f20:	65 b9       	out	0x05, r22	; 5
            WR0;
     f22:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f24:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     f26:	45 b9       	out	0x05, r20	; 5
            WR0;
     f28:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f2a:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = a;
     f2c:	65 b9       	out	0x05, r22	; 5
            WR0;
     f2e:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f30:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     f32:	45 b9       	out	0x05, r20	; 5
            WR0;
     f34:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f36:	5b 9a       	sbi	0x0b, 3	; 11

            DATA_PORT = a;
     f38:	65 b9       	out	0x05, r22	; 5
            WR0;
     f3a:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f3c:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     f3e:	45 b9       	out	0x05, r20	; 5
            WR0;
     f40:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f42:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = a;
     f44:	65 b9       	out	0x05, r22	; 5
            WR0;
     f46:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f48:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     f4a:	45 b9       	out	0x05, r20	; 5
            WR0;
     f4c:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f4e:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = a;
     f50:	65 b9       	out	0x05, r22	; 5
            WR0;
     f52:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f54:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     f56:	45 b9       	out	0x05, r20	; 5
            WR0;
     f58:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f5a:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = a;
     f5c:	65 b9       	out	0x05, r22	; 5
            WR0;
     f5e:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f60:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     f62:	45 b9       	out	0x05, r20	; 5
            WR0;
     f64:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     f66:	5b 9a       	sbi	0x0b, 3	; 11
    count >>= 3;
    if (count)
    {
        byte w1 = CONTROLPORT;
        byte w0 = w1 & ~(1 << WR);
        do {
     f68:	01 97       	sbiw	r24, 0x01	; 1
     f6a:	71 f6       	brne	.-100    	; 0xf08 <_Z4Blitjhh+0x2c>
     f6c:	08 95       	ret

00000f6e <_ZN3LCD6PixelsEihh>:
    }
}

void LCD::Pixels(int count, byte a, byte b)
{
    Blit(count,a,b);
     f6e:	0e 94 6e 07 	call	0xedc	; 0xedc <_Z4Blitjhh>
}
     f72:	08 95       	ret

00000f74 <_ZN3LCD9SolidFillEt>:
    _color = color;
}

void LCD::SolidFill(ushort count)
{
    Blit(count, _color >> 8, _color);
     f74:	40 91 a8 02 	lds	r20, 0x02A8
     f78:	60 91 a9 02 	lds	r22, 0x02A9
     f7c:	0e 94 6e 07 	call	0xedc	; 0xedc <_Z4Blitjhh>
}
     f80:	08 95       	ret

00000f82 <_ZN3LCD6PixelsEii>:
{
    Blit(count,a,b);
}

void LCD::Pixels(int count, int color)
{
     f82:	cf 93       	push	r28
     f84:	df 93       	push	r29
     f86:	ec 01       	movw	r28, r24
     f88:	cb 01       	movw	r24, r22
    LCD::SetColor(color);
     f8a:	0e 94 c5 06 	call	0xd8a	; 0xd8a <_ZN3LCD8SetColorEt>
    LCD::SolidFill(count);
     f8e:	ce 01       	movw	r24, r28
     f90:	0e 94 ba 07 	call	0xf74	; 0xf74 <_ZN3LCD9SolidFillEt>
}
     f94:	df 91       	pop	r29
     f96:	cf 91       	pop	r28
     f98:	08 95       	ret

00000f9a <_Z13WritePixelPosiiPh>:
    PORTC = d[2];
    CONTROLPORT = w0;
    CONTROLPORT = w1;
    
    CS1;  // deelect chip*/
}
     f9a:	08 95       	ret

00000f9c <_Z7InitADCv>:
//====================================================================
//  Touch stuff in LCD

void InitADC()
{
    ADMUX = 1<<REFS0;
     f9c:	80 e4       	ldi	r24, 0x40	; 64
     f9e:	80 93 7c 00 	sts	0x007C, r24
    ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); //Rrescalar div factor =128
     fa2:	87 e8       	ldi	r24, 0x87	; 135
     fa4:	80 93 7a 00 	sts	0x007A, r24
}
     fa8:	08 95       	ret

00000faa <_Z7ReadADChPih>:

void ReadADC(uint8_t ch, int* dst, byte count)
{
     faa:	ef 92       	push	r14
     fac:	ff 92       	push	r15
     fae:	0f 93       	push	r16
     fb0:	1f 93       	push	r17
     fb2:	cf 93       	push	r28
     fb4:	df 93       	push	r29
     fb6:	db 01       	movw	r26, r22
    //Select ADC Channel ch must be 0-7
    ADMUX &= ~7;
     fb8:	ec e7       	ldi	r30, 0x7C	; 124
     fba:	f0 e0       	ldi	r31, 0x00	; 0
     fbc:	90 81       	ld	r25, Z
     fbe:	98 7f       	andi	r25, 0xF8	; 248
     fc0:	90 83       	st	Z, r25
    ADMUX |= ch & 7;
     fc2:	90 81       	ld	r25, Z
     fc4:	87 70       	andi	r24, 0x07	; 7
     fc6:	98 2b       	or	r25, r24
     fc8:	90 83       	st	Z, r25
    ADCSRA |= 1 << ADEN;
     fca:	ea e7       	ldi	r30, 0x7A	; 122
     fcc:	f0 e0       	ldi	r31, 0x00	; 0
     fce:	80 81       	ld	r24, Z
     fd0:	80 68       	ori	r24, 0x80	; 128
     fd2:	80 83       	st	Z, r24
    ADCSRA |= 1 << ADSC;
     fd4:	80 81       	ld	r24, Z
     fd6:	80 64       	ori	r24, 0x40	; 64
     fd8:	80 83       	st	Z, r24
    while(!(ADCSRA & 0x10));
     fda:	80 81       	ld	r24, Z
     fdc:	84 ff       	sbrs	r24, 4
     fde:	fd cf       	rjmp	.-6      	; 0xfda <_Z7ReadADChPih+0x30>

    for (byte i = 0; i < count; i++)
     fe0:	44 23       	and	r20, r20
     fe2:	31 f1       	breq	.+76     	; 0x1030 <_Z7ReadADChPih+0x86>
{
    ADMUX = 1<<REFS0;
    ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); //Rrescalar div factor =128
}

void ReadADC(uint8_t ch, int* dst, byte count)
     fe4:	cd 01       	movw	r24, r26
     fe6:	02 96       	adiw	r24, 0x02	; 2
     fe8:	41 50       	subi	r20, 0x01	; 1
     fea:	24 2f       	mov	r18, r20
     fec:	30 e0       	ldi	r19, 0x00	; 0
     fee:	22 0f       	add	r18, r18
     ff0:	33 1f       	adc	r19, r19
     ff2:	28 0f       	add	r18, r24
     ff4:	39 1f       	adc	r19, r25
    ADCSRA |= 1 << ADSC;
    while(!(ADCSRA & 0x10));

    for (byte i = 0; i < count; i++)
    {
        ADCSRA |= 1<<ADSC;
     ff6:	ea e7       	ldi	r30, 0x7A	; 122
     ff8:	f0 e0       	ldi	r31, 0x00	; 0
        while(!(ADCSRA & 0x10));
        int v = ADCL;
     ffa:	0f 2e       	mov	r0, r31
     ffc:	f8 e7       	ldi	r31, 0x78	; 120
     ffe:	ef 2e       	mov	r14, r31
    1000:	ff 24       	eor	r15, r15
    1002:	f0 2d       	mov	r31, r0
        v += ADCH << 8;
    1004:	49 e7       	ldi	r20, 0x79	; 121
    1006:	50 e0       	ldi	r21, 0x00	; 0
    ADCSRA |= 1 << ADSC;
    while(!(ADCSRA & 0x10));

    for (byte i = 0; i < count; i++)
    {
        ADCSRA |= 1<<ADSC;
    1008:	80 81       	ld	r24, Z
    100a:	80 64       	ori	r24, 0x40	; 64
    100c:	80 83       	st	Z, r24
        while(!(ADCSRA & 0x10));
    100e:	80 81       	ld	r24, Z
    1010:	84 ff       	sbrs	r24, 4
    1012:	fd cf       	rjmp	.-6      	; 0x100e <_Z7ReadADChPih+0x64>
        int v = ADCL;
    1014:	e7 01       	movw	r28, r14
    1016:	88 81       	ld	r24, Y
        v += ADCH << 8;
    1018:	ea 01       	movw	r28, r20
    101a:	98 81       	ld	r25, Y
    101c:	19 2f       	mov	r17, r25
    101e:	00 e0       	ldi	r16, 0x00	; 0
    1020:	b8 01       	movw	r22, r16
    1022:	68 0f       	add	r22, r24
    1024:	71 1d       	adc	r23, r1
        *dst++ = v;
    1026:	6d 93       	st	X+, r22
    1028:	7d 93       	st	X+, r23
    ADMUX |= ch & 7;
    ADCSRA |= 1 << ADEN;
    ADCSRA |= 1 << ADSC;
    while(!(ADCSRA & 0x10));

    for (byte i = 0; i < count; i++)
    102a:	a2 17       	cp	r26, r18
    102c:	b3 07       	cpc	r27, r19
    102e:	61 f7       	brne	.-40     	; 0x1008 <_Z7ReadADChPih+0x5e>
        while(!(ADCSRA & 0x10));
        int v = ADCL;
        v += ADCH << 8;
        *dst++ = v;
    }
    ADCSRA &= ~(1 << ADEN);
    1030:	ea e7       	ldi	r30, 0x7A	; 122
    1032:	f0 e0       	ldi	r31, 0x00	; 0
    1034:	80 81       	ld	r24, Z
    1036:	8f 77       	andi	r24, 0x7F	; 127
    1038:	80 83       	st	Z, r24
}
    103a:	df 91       	pop	r29
    103c:	cf 91       	pop	r28
    103e:	1f 91       	pop	r17
    1040:	0f 91       	pop	r16
    1042:	ff 90       	pop	r15
    1044:	ef 90       	pop	r14
    1046:	08 95       	ret

00001048 <_Z4mappllll>:

int mapp(long v, long a, long b, long range)
{
    1048:	4f 92       	push	r4
    104a:	5f 92       	push	r5
    104c:	6f 92       	push	r6
    104e:	7f 92       	push	r7
    1050:	8f 92       	push	r8
    1052:	9f 92       	push	r9
    1054:	af 92       	push	r10
    1056:	bf 92       	push	r11
    1058:	cf 92       	push	r12
    105a:	df 92       	push	r13
    105c:	ef 92       	push	r14
    105e:	ff 92       	push	r15
    1060:	0f 93       	push	r16
    1062:	1f 93       	push	r17
    1064:	2b 01       	movw	r4, r22
    1066:	3c 01       	movw	r6, r24
    1068:	ba 01       	movw	r22, r20
    106a:	a9 01       	movw	r20, r18
    106c:	d8 01       	movw	r26, r16
    106e:	c7 01       	movw	r24, r14
    1070:	96 01       	movw	r18, r12
    1072:	85 01       	movw	r16, r10
    b -= a;
    1074:	6c 01       	movw	r12, r24
    1076:	7d 01       	movw	r14, r26
    1078:	c4 1a       	sub	r12, r20
    107a:	d5 0a       	sbc	r13, r21
    107c:	e6 0a       	sbc	r14, r22
    107e:	f7 0a       	sbc	r15, r23
    return (int)(((v - a)*range + (b>>1))/b);
    1080:	53 01       	movw	r10, r6
    1082:	42 01       	movw	r8, r4
    1084:	84 1a       	sub	r8, r20
    1086:	95 0a       	sbc	r9, r21
    1088:	a6 0a       	sbc	r10, r22
    108a:	b7 0a       	sbc	r11, r23
    108c:	c5 01       	movw	r24, r10
    108e:	b4 01       	movw	r22, r8
    1090:	a9 01       	movw	r20, r18
    1092:	98 01       	movw	r18, r16
    1094:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <__mulsi3>
    1098:	ab 01       	movw	r20, r22
    109a:	bc 01       	movw	r22, r24
    109c:	d7 01       	movw	r26, r14
    109e:	c6 01       	movw	r24, r12
    10a0:	b5 95       	asr	r27
    10a2:	a7 95       	ror	r26
    10a4:	97 95       	ror	r25
    10a6:	87 95       	ror	r24
    10a8:	8a 01       	movw	r16, r20
    10aa:	9b 01       	movw	r18, r22
    10ac:	08 0f       	add	r16, r24
    10ae:	19 1f       	adc	r17, r25
    10b0:	2a 1f       	adc	r18, r26
    10b2:	3b 1f       	adc	r19, r27
    10b4:	c9 01       	movw	r24, r18
    10b6:	b8 01       	movw	r22, r16
    10b8:	a7 01       	movw	r20, r14
    10ba:	96 01       	movw	r18, r12
    10bc:	0e 94 8d 0b 	call	0x171a	; 0x171a <__divmodsi4>
}
    10c0:	82 2f       	mov	r24, r18
    10c2:	93 2f       	mov	r25, r19
    10c4:	1f 91       	pop	r17
    10c6:	0f 91       	pop	r16
    10c8:	ff 90       	pop	r15
    10ca:	ef 90       	pop	r14
    10cc:	df 90       	pop	r13
    10ce:	cf 90       	pop	r12
    10d0:	bf 90       	pop	r11
    10d2:	af 90       	pop	r10
    10d4:	9f 90       	pop	r9
    10d6:	8f 90       	pop	r8
    10d8:	7f 90       	pop	r7
    10da:	6f 90       	pop	r6
    10dc:	5f 90       	pop	r5
    10de:	4f 90       	pop	r4
    10e0:	08 95       	ret

000010e2 <_Z9quicksortPiii>:

void quicksort(int arr[], int left, int right)
{
    10e2:	af 92       	push	r10
    10e4:	bf 92       	push	r11
    10e6:	cf 92       	push	r12
    10e8:	df 92       	push	r13
    10ea:	ef 92       	push	r14
    10ec:	ff 92       	push	r15
    10ee:	0f 93       	push	r16
    10f0:	1f 93       	push	r17
    10f2:	cf 93       	push	r28
    10f4:	df 93       	push	r29
    10f6:	7c 01       	movw	r14, r24
    10f8:	6b 01       	movw	r12, r22
    10fa:	5a 01       	movw	r10, r20
    int i = left, j = right;
    int tmp;
    int pivot = arr[(left + right) >> 1];
    10fc:	fb 01       	movw	r30, r22
    10fe:	e4 0f       	add	r30, r20
    1100:	f5 1f       	adc	r31, r21
    1102:	ee 7f       	andi	r30, 0xFE	; 254
    1104:	e8 0f       	add	r30, r24
    1106:	f9 1f       	adc	r31, r25
    1108:	60 81       	ld	r22, Z
    110a:	71 81       	ldd	r23, Z+1	; 0x01
    return (int)(((v - a)*range + (b>>1))/b);
}

void quicksort(int arr[], int left, int right)
{
    int i = left, j = right;
    110c:	e6 01       	movw	r28, r12
    int tmp;
    int pivot = arr[(left + right) >> 1];

    while (i <= j) {
    110e:	2e c0       	rjmp	.+92     	; 0x116c <__stack+0x6d>
        while (arr[i] < pivot)
            i++;
    1110:	21 96       	adiw	r28, 0x01	; 1
    int i = left, j = right;
    int tmp;
    int pivot = arr[(left + right) >> 1];

    while (i <= j) {
        while (arr[i] < pivot)
    1112:	8f 01       	movw	r16, r30
    1114:	21 91       	ld	r18, Z+
    1116:	31 91       	ld	r19, Z+
    1118:	26 17       	cp	r18, r22
    111a:	37 07       	cpc	r19, r23
    111c:	cc f3       	brlt	.-14     	; 0x1110 <__stack+0x11>
            i++;
        while (arr[j] > pivot)
    111e:	ca 01       	movw	r24, r20
    1120:	88 0f       	add	r24, r24
    1122:	99 1f       	adc	r25, r25
    1124:	d7 01       	movw	r26, r14
    1126:	a8 0f       	add	r26, r24
    1128:	b9 1f       	adc	r27, r25
    112a:	8d 91       	ld	r24, X+
    112c:	9c 91       	ld	r25, X
    112e:	11 97       	sbiw	r26, 0x01	; 1
    1130:	68 17       	cp	r22, r24
    1132:	79 07       	cpc	r23, r25
    1134:	7c f4       	brge	.+30     	; 0x1154 <__stack+0x55>
{
    b -= a;
    return (int)(((v - a)*range + (b>>1))/b);
}

void quicksort(int arr[], int left, int right)
    1136:	fa 01       	movw	r30, r20
    1138:	31 97       	sbiw	r30, 0x01	; 1
    113a:	ee 0f       	add	r30, r30
    113c:	ff 1f       	adc	r31, r31
    113e:	ee 0d       	add	r30, r14
    1140:	ff 1d       	adc	r31, r15

    while (i <= j) {
        while (arr[i] < pivot)
            i++;
        while (arr[j] > pivot)
            j--;
    1142:	41 50       	subi	r20, 0x01	; 1
    1144:	50 40       	sbci	r21, 0x00	; 0
    int pivot = arr[(left + right) >> 1];

    while (i <= j) {
        while (arr[i] < pivot)
            i++;
        while (arr[j] > pivot)
    1146:	df 01       	movw	r26, r30
    1148:	32 97       	sbiw	r30, 0x02	; 2
    114a:	82 81       	ldd	r24, Z+2	; 0x02
    114c:	93 81       	ldd	r25, Z+3	; 0x03
    114e:	68 17       	cp	r22, r24
    1150:	79 07       	cpc	r23, r25
    1152:	bc f3       	brlt	.-18     	; 0x1142 <__stack+0x43>
            j--;
        if (i <= j)
    1154:	4c 17       	cp	r20, r28
    1156:	5d 07       	cpc	r21, r29
    1158:	fc f0       	brlt	.+62     	; 0x1198 <__stack+0x99>
        {
            tmp = arr[i];
            arr[i] = arr[j];
    115a:	f8 01       	movw	r30, r16
    115c:	91 83       	std	Z+1, r25	; 0x01
    115e:	80 83       	st	Z, r24
            arr[j] = tmp;
    1160:	11 96       	adiw	r26, 0x01	; 1
    1162:	3c 93       	st	X, r19
    1164:	2e 93       	st	-X, r18
            i++;
    1166:	21 96       	adiw	r28, 0x01	; 1
            j--;
    1168:	41 50       	subi	r20, 0x01	; 1
    116a:	50 40       	sbci	r21, 0x00	; 0
{
    int i = left, j = right;
    int tmp;
    int pivot = arr[(left + right) >> 1];

    while (i <= j) {
    116c:	4c 17       	cp	r20, r28
    116e:	5d 07       	cpc	r21, r29
    1170:	9c f0       	brlt	.+38     	; 0x1198 <__stack+0x99>
        while (arr[i] < pivot)
    1172:	ce 01       	movw	r24, r28
    1174:	88 0f       	add	r24, r24
    1176:	99 1f       	adc	r25, r25
    1178:	87 01       	movw	r16, r14
    117a:	08 0f       	add	r16, r24
    117c:	19 1f       	adc	r17, r25
    117e:	f8 01       	movw	r30, r16
    1180:	20 81       	ld	r18, Z
    1182:	31 81       	ldd	r19, Z+1	; 0x01
    1184:	26 17       	cp	r18, r22
    1186:	37 07       	cpc	r19, r23
    1188:	54 f6       	brge	.-108    	; 0x111e <__stack+0x1f>
{
    b -= a;
    return (int)(((v - a)*range + (b>>1))/b);
}

void quicksort(int arr[], int left, int right)
    118a:	fe 01       	movw	r30, r28
    118c:	31 96       	adiw	r30, 0x01	; 1
    118e:	ee 0f       	add	r30, r30
    1190:	ff 1f       	adc	r31, r31
    1192:	ee 0d       	add	r30, r14
    1194:	ff 1d       	adc	r31, r15
    1196:	bc cf       	rjmp	.-136    	; 0x1110 <__stack+0x11>
            i++;
            j--;
        }
    }

    if (left < j)
    1198:	c4 16       	cp	r12, r20
    119a:	d5 06       	cpc	r13, r21
    119c:	24 f4       	brge	.+8      	; 0x11a6 <__stack+0xa7>
        quicksort(arr, left, j);
    119e:	c7 01       	movw	r24, r14
    11a0:	b6 01       	movw	r22, r12
    11a2:	0e 94 71 08 	call	0x10e2	; 0x10e2 <_Z9quicksortPiii>
    if (i < right)
    11a6:	ca 15       	cp	r28, r10
    11a8:	db 05       	cpc	r29, r11
    11aa:	2c f4       	brge	.+10     	; 0x11b6 <__stack+0xb7>
        quicksort(arr, i, right);
    11ac:	c7 01       	movw	r24, r14
    11ae:	be 01       	movw	r22, r28
    11b0:	a5 01       	movw	r20, r10
    11b2:	0e 94 71 08 	call	0x10e2	; 0x10e2 <_Z9quicksortPiii>
}
    11b6:	df 91       	pop	r29
    11b8:	cf 91       	pop	r28
    11ba:	1f 91       	pop	r17
    11bc:	0f 91       	pop	r16
    11be:	ff 90       	pop	r15
    11c0:	ef 90       	pop	r14
    11c2:	df 90       	pop	r13
    11c4:	cf 90       	pop	r12
    11c6:	bf 90       	pop	r11
    11c8:	af 90       	pop	r10
    11ca:	08 95       	ret

000011cc <_Z6filterPi>:

int filter(int* d)
{
    11cc:	cf 93       	push	r28
    11ce:	df 93       	push	r29
    11d0:	ec 01       	movw	r28, r24
    quicksort(d,0,7);
    11d2:	60 e0       	ldi	r22, 0x00	; 0
    11d4:	70 e0       	ldi	r23, 0x00	; 0
    11d6:	47 e0       	ldi	r20, 0x07	; 7
    11d8:	50 e0       	ldi	r21, 0x00	; 0
    11da:	0e 94 71 08 	call	0x10e2	; 0x10e2 <_Z9quicksortPiii>
    int n = 0;
    for (byte i = 2; i < 6; i++)
        n += d[i];
    11de:	8c 81       	ldd	r24, Y+4	; 0x04
    11e0:	9d 81       	ldd	r25, Y+5	; 0x05
    11e2:	2e 81       	ldd	r18, Y+6	; 0x06
    11e4:	3f 81       	ldd	r19, Y+7	; 0x07
    11e6:	82 0f       	add	r24, r18
    11e8:	93 1f       	adc	r25, r19
    11ea:	28 85       	ldd	r18, Y+8	; 0x08
    11ec:	39 85       	ldd	r19, Y+9	; 0x09
    11ee:	82 0f       	add	r24, r18
    11f0:	93 1f       	adc	r25, r19
    11f2:	2a 85       	ldd	r18, Y+10	; 0x0a
    11f4:	3b 85       	ldd	r19, Y+11	; 0x0b
    11f6:	82 0f       	add	r24, r18
    11f8:	93 1f       	adc	r25, r19
    return n;
}
    11fa:	df 91       	pop	r29
    11fc:	cf 91       	pop	r28
    11fe:	08 95       	ret

00001200 <_ZN3LCD8SetPixelEiit>:

void LCD::SetPixel(int x, int y, ushort colour)
{
    1200:	cf 92       	push	r12
    1202:	df 92       	push	r13
    1204:	ef 92       	push	r14
    1206:	ff 92       	push	r15
    1208:	0f 93       	push	r16
    120a:	1f 93       	push	r17
    120c:	cf 93       	push	r28
    120e:	df 93       	push	r29
    1210:	8c 01       	movw	r16, r24
    1212:	7b 01       	movw	r14, r22
    1214:	6a 01       	movw	r12, r20
		
	width = LCD::GetWidth();
	height = LCD::GetHeight();
	int right = x + width;
	int bottom = y + height;
	right = LCD::GetWidth();
    1216:	0e 94 bf 06 	call	0xd7e	; 0xd7e <_ZN3LCD8GetWidthEv>
    121a:	ec 01       	movw	r28, r24
	bottom = LCD::GetHeight();
    121c:	0e 94 c2 06 	call	0xd84	; 0xd84 <_ZN3LCD9GetHeightEv>
	width = right - x;
    1220:	c0 1b       	sub	r28, r16
    1222:	d1 0b       	sbc	r29, r17
	height = bottom - y;
	if (width <= 0 || height <= 0)
    1224:	1c 16       	cp	r1, r28
    1226:	1d 06       	cpc	r1, r29
    1228:	c4 f4       	brge	.+48     	; 0x125a <_ZN3LCD8SetPixelEiit+0x5a>
	int right = x + width;
	int bottom = y + height;
	right = LCD::GetWidth();
	bottom = LCD::GetHeight();
	width = right - x;
	height = bottom - y;
    122a:	8e 19       	sub	r24, r14
    122c:	9f 09       	sbc	r25, r15
	if (width <= 0 || height <= 0)
    122e:	18 16       	cp	r1, r24
    1230:	19 06       	cpc	r1, r25
    1232:	9c f4       	brge	.+38     	; 0x125a <_ZN3LCD8SetPixelEiit+0x5a>
		return;
		
	LCD::SetWrap(x,y,1,1);
    1234:	c8 01       	movw	r24, r16
    1236:	b7 01       	movw	r22, r14
    1238:	41 e0       	ldi	r20, 0x01	; 1
    123a:	50 e0       	ldi	r21, 0x00	; 0
    123c:	21 e0       	ldi	r18, 0x01	; 1
    123e:	30 e0       	ldi	r19, 0x00	; 0
    1240:	0e 94 8b 06 	call	0xd16	; 0xd16 <_ZN3LCD7SetWrapEiiii>
	LCD::SetGRAM(x,y);
    1244:	c8 01       	movw	r24, r16
    1246:	b7 01       	movw	r22, r14
    1248:	0e 94 b7 06 	call	0xd6e	; 0xd6e <_ZN3LCD7SetGRAMEii>
	LCD::SetColor(colour);
    124c:	c6 01       	movw	r24, r12
    124e:	0e 94 c5 06 	call	0xd8a	; 0xd8a <_ZN3LCD8SetColorEt>
		
	LCD::SolidFill(2);
    1252:	82 e0       	ldi	r24, 0x02	; 2
    1254:	90 e0       	ldi	r25, 0x00	; 0
    1256:	0e 94 ba 07 	call	0xf74	; 0xf74 <_ZN3LCD9SolidFillEt>
}
    125a:	df 91       	pop	r29
    125c:	cf 91       	pop	r28
    125e:	1f 91       	pop	r17
    1260:	0f 91       	pop	r16
    1262:	ff 90       	pop	r15
    1264:	ef 90       	pop	r14
    1266:	df 90       	pop	r13
    1268:	cf 90       	pop	r12
    126a:	08 95       	ret

0000126c <__vector_1>:
	
};
#endif
//ISR for controlling WEN.
ISR(INT0_vect)
{
    126c:	1f 92       	push	r1
    126e:	0f 92       	push	r0
    1270:	0f b6       	in	r0, 0x3f	; 63
    1272:	0f 92       	push	r0
    1274:	11 24       	eor	r1, r1
    1276:	8f 93       	push	r24
    1278:	9f 93       	push	r25
	//xprintf(PSTR("ISR Entered"));
	if (VSYNC_Count==1)//start a frame read
    127a:	80 91 a2 02 	lds	r24, 0x02A2
    127e:	90 91 a3 02 	lds	r25, 0x02A3
    1282:	81 30       	cpi	r24, 0x01	; 1
    1284:	91 05       	cpc	r25, r1
    1286:	59 f4       	brne	.+22     	; 0x129e <__vector_1+0x32>
	{
		/*xprintf(PSTR("WEN Set\n"));*/
		FIFO_WEN_SET;
    1288:	46 9a       	sbi	0x08, 6	; 8
		VSYNC_Count++;
    128a:	80 91 a2 02 	lds	r24, 0x02A2
    128e:	90 91 a3 02 	lds	r25, 0x02A3
    1292:	01 96       	adiw	r24, 0x01	; 1
    1294:	90 93 a3 02 	sts	0x02A3, r25
    1298:	80 93 a2 02 	sts	0x02A2, r24
    129c:	0d c0       	rjmp	.+26     	; 0x12b8 <__vector_1+0x4c>
	}
	else if (VSYNC_Count==2)//end a frame read
    129e:	80 91 a2 02 	lds	r24, 0x02A2
    12a2:	90 91 a3 02 	lds	r25, 0x02A3
    12a6:	82 30       	cpi	r24, 0x02	; 2
    12a8:	91 05       	cpc	r25, r1
    12aa:	11 f4       	brne	.+4      	; 0x12b0 <__vector_1+0x44>
	{
		FIFO_WEN_CLR;
    12ac:	46 98       	cbi	0x08, 6	; 8
    12ae:	04 c0       	rjmp	.+8      	; 0x12b8 <__vector_1+0x4c>
		/*xprintf(PSTR("WEN Clear\n"));*/
	}
	else
	{
		VSYNC_Count = 0;//wait for a read to be started
    12b0:	10 92 a3 02 	sts	0x02A3, r1
    12b4:	10 92 a2 02 	sts	0x02A2, r1
	}
}
    12b8:	9f 91       	pop	r25
    12ba:	8f 91       	pop	r24
    12bc:	0f 90       	pop	r0
    12be:	0f be       	out	0x3f, r0	; 63
    12c0:	0f 90       	pop	r0
    12c2:	1f 90       	pop	r1
    12c4:	18 95       	reti

000012c6 <wrOV7670Reg>:

//Write Register Method
unsigned char wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
    12c6:	cf 93       	push	r28
    12c8:	df 93       	push	r29
    12ca:	00 d0       	rcall	.+0      	; 0x12cc <wrOV7670Reg+0x6>
    12cc:	00 d0       	rcall	.+0      	; 0x12ce <wrOV7670Reg+0x8>
    12ce:	cd b7       	in	r28, 0x3d	; 61
    12d0:	de b7       	in	r29, 0x3e	; 62
	/*	I2C Traffic Generated:
	 *	S | OV_7670 + W | A | RegID | A | Data | A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (OV7670_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
    12d2:	92 e4       	ldi	r25, 0x42	; 66
    12d4:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for commands.
    12d6:	8a 83       	std	Y+2, r24	; 0x02
	messageBuf[2] = regDat;                        // The second byte is used for the data.
    12d8:	6b 83       	std	Y+3, r22	; 0x03
	TWI_Start_Transceiver_With_Data( messageBuf, 3 );
    12da:	ce 01       	movw	r24, r28
    12dc:	01 96       	adiw	r24, 0x01	; 1
    12de:	63 e0       	ldi	r22, 0x03	; 3
    12e0:	0e 94 8b 0a 	call	0x1516	; 0x1516 <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
    12e4:	0e 94 80 0a 	call	0x1500	; 0x1500 <TWI_Transceiver_Busy>
    12e8:	88 23       	and	r24, r24
    12ea:	e1 f7       	brne	.-8      	; 0x12e4 <wrOV7670Reg+0x1e>
	
	return TWI_statusReg.lastTransOK;
    12ec:	80 91 aa 02 	lds	r24, 0x02AA
}
    12f0:	81 70       	andi	r24, 0x01	; 1
    12f2:	0f 90       	pop	r0
    12f4:	0f 90       	pop	r0
    12f6:	0f 90       	pop	r0
    12f8:	0f 90       	pop	r0
    12fa:	df 91       	pop	r29
    12fc:	cf 91       	pop	r28
    12fe:	08 95       	ret

00001300 <rdOV7670Reg>:

//Read Register Method
unsigned char rdOV7670Reg(unsigned char regID, unsigned char *regDat)
{
    1300:	0f 93       	push	r16
    1302:	1f 93       	push	r17
    1304:	cf 93       	push	r28
    1306:	df 93       	push	r29
    1308:	00 d0       	rcall	.+0      	; 0x130a <rdOV7670Reg+0xa>
    130a:	00 d0       	rcall	.+0      	; 0x130c <rdOV7670Reg+0xc>
    130c:	cd b7       	in	r28, 0x3d	; 61
    130e:	de b7       	in	r29, 0x3e	; 62
    1310:	8b 01       	movw	r16, r22
	 *	S	|	OV_ADDR + W	| A | RegID | A | P |
	 *	S	|	OV_ADDR + R | A | Data	|~A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
    1312:	92 e4       	ldi	r25, 0x42	; 66
    1314:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for Address Pointer.
    1316:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
    1318:	ce 01       	movw	r24, r28
    131a:	01 96       	adiw	r24, 0x01	; 1
    131c:	62 e0       	ldi	r22, 0x02	; 2
    131e:	0e 94 8b 0a 	call	0x1516	; 0x1516 <TWI_Start_Transceiver_With_Data>
	
	// Request/collect the data from the Slave
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
    1322:	83 e4       	ldi	r24, 0x43	; 67
    1324:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );              
    1326:	ce 01       	movw	r24, r28
    1328:	01 96       	adiw	r24, 0x01	; 1
    132a:	62 e0       	ldi	r22, 0x02	; 2
    132c:	0e 94 8b 0a 	call	0x1516	; 0x1516 <TWI_Start_Transceiver_With_Data>
    
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
    1330:	ce 01       	movw	r24, r28
    1332:	01 96       	adiw	r24, 0x01	; 1
    1334:	62 e0       	ldi	r22, 0x02	; 2
    1336:	0e 94 c1 0a 	call	0x1582	; 0x1582 <TWI_Get_Data_From_Transceiver>
	*regDat = messageBuf[1];       
    133a:	8a 81       	ldd	r24, Y+2	; 0x02
    133c:	f8 01       	movw	r30, r16
    133e:	80 83       	st	Z, r24
	return TWI_statusReg.lastTransOK;
    1340:	80 91 aa 02 	lds	r24, 0x02AA
}
    1344:	81 70       	andi	r24, 0x01	; 1
    1346:	0f 90       	pop	r0
    1348:	0f 90       	pop	r0
    134a:	0f 90       	pop	r0
    134c:	0f 90       	pop	r0
    134e:	df 91       	pop	r29
    1350:	cf 91       	pop	r28
    1352:	1f 91       	pop	r17
    1354:	0f 91       	pop	r16
    1356:	08 95       	ret

00001358 <OV7670_init>:

// Initial OV7670 - TWI_Master Must be initialised before hand.
unsigned char OV7670_init(void)
{
    1358:	0f 93       	push	r16
    135a:	1f 93       	push	r17
    135c:	cf 93       	push	r28
    135e:	df 93       	push	r29
	
	VSYNC_Count = 0;
    1360:	10 92 a3 02 	sts	0x02A3, r1
    1364:	10 92 a2 02 	sts	0x02A2, r1
	unsigned char temp;
	
	unsigned int i=0;
	
	// initial the int0 interrupt for WEN
	DDRD &= ~(1<<OV7670_VSYNC);		//set OV7670_SYNC as input for INT0
    1368:	52 98       	cbi	0x0a, 2	; 10
	PORTD |= (1<<OV7670_VSYNC);		//Enable OV7670_SYNC pull-up resistor
    136a:	5a 9a       	sbi	0x0b, 2	; 11
	
	EIMSK = 1<<INT0;				//Enable INT0
    136c:	81 e0       	ldi	r24, 0x01	; 1
    136e:	8d bb       	out	0x1d, r24	; 29
	EICRA = 1<<ISC01;				//Trigger INT0 on the falling edge
    1370:	82 e0       	ldi	r24, 0x02	; 2
    1372:	80 93 69 00 	sts	0x0069, r24
	
	temp=0x80;
	if(0==wrOV7670Reg(OV_COM7, temp)) //Reset Camera
    1376:	82 e1       	ldi	r24, 0x12	; 18
    1378:	60 e8       	ldi	r22, 0x80	; 128
    137a:	0e 94 63 09 	call	0x12c6	; 0x12c6 <wrOV7670Reg>
    137e:	88 23       	and	r24, r24
    1380:	f1 f0       	breq	.+60     	; 0x13be <OV7670_init+0x66>
    1382:	83 ec       	ldi	r24, 0xC3	; 195
    1384:	99 e0       	ldi	r25, 0x09	; 9
    1386:	01 97       	sbiw	r24, 0x01	; 1
    1388:	f1 f7       	brne	.-4      	; 0x1386 <OV7670_init+0x2e>
    138a:	00 c0       	rjmp	.+0      	; 0x138c <OV7670_init+0x34>
    138c:	00 00       	nop
    138e:	c4 e5       	ldi	r28, 0x54	; 84
    1390:	d1 e0       	ldi	r29, 0x01	; 1
	*regDat = messageBuf[1];       
	return TWI_statusReg.lastTransOK;
}

// Initial OV7670 - TWI_Master Must be initialised before hand.
unsigned char OV7670_init(void)
    1392:	02 ea       	ldi	r16, 0xA2	; 162
    1394:	12 e0       	ldi	r17, 0x02	; 2
    1396:	fe 01       	movw	r30, r28
    1398:	31 97       	sbiw	r30, 0x01	; 1
	}
	_delay_ms(10);
#if SETTINGS == PGM_SPACE
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
    139a:	80 81       	ld	r24, Z
    139c:	68 81       	ld	r22, Y
    139e:	0e 94 63 09 	call	0x12c6	; 0x12c6 <wrOV7670Reg>
    13a2:	88 23       	and	r24, r24
    13a4:	71 f0       	breq	.+28     	; 0x13c2 <OV7670_init+0x6a>
    13a6:	89 ef       	ldi	r24, 0xF9	; 249
    13a8:	90 e0       	ldi	r25, 0x00	; 0
    13aa:	01 97       	sbiw	r24, 0x01	; 1
    13ac:	f1 f7       	brne	.-4      	; 0x13aa <OV7670_init+0x52>
    13ae:	00 c0       	rjmp	.+0      	; 0x13b0 <OV7670_init+0x58>
    13b0:	00 00       	nop
    13b2:	22 96       	adiw	r28, 0x02	; 2
	{
		return 0;
	}
	_delay_ms(10);
#if SETTINGS == PGM_SPACE
	for(i=0; i<SETTINGS_LENGTH; i++)
    13b4:	c0 17       	cp	r28, r16
    13b6:	d1 07       	cpc	r29, r17
    13b8:	71 f7       	brne	.-36     	; 0x1396 <OV7670_init+0x3e>
			return 0;
		}
		_delay_ms(1);
	}	
#endif
	return 1; //ok
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	03 c0       	rjmp	.+6      	; 0x13c4 <OV7670_init+0x6c>
	EICRA = 1<<ISC01;				//Trigger INT0 on the falling edge
	
	temp=0x80;
	if(0==wrOV7670Reg(OV_COM7, temp)) //Reset Camera
	{
		return 0;
    13be:	80 e0       	ldi	r24, 0x00	; 0
    13c0:	01 c0       	rjmp	.+2      	; 0x13c4 <OV7670_init+0x6c>
#if SETTINGS == PGM_SPACE
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
		{
			return 0;
    13c2:	80 e0       	ldi	r24, 0x00	; 0
		}
		_delay_ms(1);
	}	
#endif
	return 1; //ok
}
    13c4:	df 91       	pop	r29
    13c6:	cf 91       	pop	r28
    13c8:	1f 91       	pop	r17
    13ca:	0f 91       	pop	r16
    13cc:	08 95       	ret

000013ce <FIFO_Reset>:

//Resets both pointers
void FIFO_Reset() 
{
	FIFO_WRST_CLR;
    13ce:	43 98       	cbi	0x08, 3	; 8
	FIFO_nRRST_CLR;
    13d0:	47 98       	cbi	0x08, 7	; 8
	FIFO_RCLK_SET;
    13d2:	44 9a       	sbi	0x08, 4	; 8
	FIFO_RCLK_CLR;
    13d4:	44 98       	cbi	0x08, 4	; 8
	FIFO_nRRST_SET;
    13d6:	47 9a       	sbi	0x08, 7	; 8
	FIFO_WRST_SET;
    13d8:	43 9a       	sbi	0x08, 3	; 8
}
    13da:	08 95       	ret

000013dc <LoadImageToBuffer>:
}


void LoadImageToBuffer( void )
{
	while(VSYNC_Count != 0); //wait for any frame to be written to complete
    13dc:	80 91 a2 02 	lds	r24, 0x02A2
    13e0:	90 91 a3 02 	lds	r25, 0x02A3
    13e4:	00 97       	sbiw	r24, 0x00	; 0
    13e6:	d1 f7       	brne	.-12     	; 0x13dc <LoadImageToBuffer>
	FIFO_WRST_CLR;//Reset the write pointer
    13e8:	43 98       	cbi	0x08, 3	; 8
    13ea:	89 ef       	ldi	r24, 0xF9	; 249
    13ec:	90 e0       	ldi	r25, 0x00	; 0
    13ee:	01 97       	sbiw	r24, 0x01	; 1
    13f0:	f1 f7       	brne	.-4      	; 0x13ee <LoadImageToBuffer+0x12>
    13f2:	00 c0       	rjmp	.+0      	; 0x13f4 <LoadImageToBuffer+0x18>
    13f4:	00 00       	nop
	_delay_ms(1);//wait a few clock cycles of the internal oscillator
	FIFO_WRST_SET;
    13f6:	43 9a       	sbi	0x08, 3	; 8
    13f8:	89 ef       	ldi	r24, 0xF9	; 249
    13fa:	90 e0       	ldi	r25, 0x00	; 0
    13fc:	01 97       	sbiw	r24, 0x01	; 1
    13fe:	f1 f7       	brne	.-4      	; 0x13fc <LoadImageToBuffer+0x20>
    1400:	00 c0       	rjmp	.+0      	; 0x1402 <LoadImageToBuffer+0x26>
    1402:	00 00       	nop
	_delay_ms(1);
	VSYNC_Count = 1;
    1404:	81 e0       	ldi	r24, 0x01	; 1
    1406:	90 e0       	ldi	r25, 0x00	; 0
    1408:	90 93 a3 02 	sts	0x02A3, r25
    140c:	80 93 a2 02 	sts	0x02A2, r24
}
    1410:	08 95       	ret

00001412 <FIFO_init>:

//Initial FIFO
unsigned char FIFO_init(void)
{
	
	OV7670_CTRL_DDR |=(1<<FIFO_WEN)|(1<<FIFO_nRRST)|(1<<FIFO_RCLK)|(1 << FIFO_WRST) | (1 << FIFO_nOE);
    1412:	87 b1       	in	r24, 0x07	; 7
    1414:	88 6f       	ori	r24, 0xF8	; 248
    1416:	87 b9       	out	0x07, r24	; 7
	FIFO_WRST_CLR;
    1418:	43 98       	cbi	0x08, 3	; 8
	
	FIFO_RCLK_CLR;
    141a:	44 98       	cbi	0x08, 4	; 8
	FIFO_nOE_CLR;
    141c:	45 98       	cbi	0x08, 5	; 8
	FIFO_nRRST_SET;
    141e:	47 9a       	sbi	0x08, 7	; 8
	FIFO_WEN_CLR;
    1420:	46 98       	cbi	0x08, 6	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1422:	83 e0       	ldi	r24, 0x03	; 3
    1424:	8a 95       	dec	r24
    1426:	f1 f7       	brne	.-4      	; 0x1424 <FIFO_init+0x12>
    1428:	00 00       	nop
	_delay_us(10);
	FIFO_RCLK_SET;
    142a:	44 9a       	sbi	0x08, 4	; 8
    142c:	83 e0       	ldi	r24, 0x03	; 3
    142e:	8a 95       	dec	r24
    1430:	f1 f7       	brne	.-4      	; 0x142e <FIFO_init+0x1c>
    1432:	00 00       	nop
	_delay_us(10);
	FIFO_RCLK_CLR;
    1434:	44 98       	cbi	0x08, 4	; 8
	FIFO_nRRST_CLR;
    1436:	47 98       	cbi	0x08, 7	; 8
    1438:	83 e0       	ldi	r24, 0x03	; 3
    143a:	8a 95       	dec	r24
    143c:	f1 f7       	brne	.-4      	; 0x143a <FIFO_init+0x28>
    143e:	00 00       	nop
	_delay_us(10);
	FIFO_RCLK_SET;
    1440:	44 9a       	sbi	0x08, 4	; 8
    1442:	83 e0       	ldi	r24, 0x03	; 3
    1444:	8a 95       	dec	r24
    1446:	f1 f7       	brne	.-4      	; 0x1444 <FIFO_init+0x32>
    1448:	00 00       	nop
	_delay_us(10);
	FIFO_RCLK_CLR;
    144a:	44 98       	cbi	0x08, 4	; 8
	FIFO_nRRST_SET;
    144c:	47 9a       	sbi	0x08, 7	; 8
    144e:	83 e0       	ldi	r24, 0x03	; 3
    1450:	8a 95       	dec	r24
    1452:	f1 f7       	brne	.-4      	; 0x1450 <FIFO_init+0x3e>
    1454:	00 00       	nop
	_delay_us(10);
	FIFO_WRST_SET;
    1456:	43 9a       	sbi	0x08, 3	; 8
	return 0x01; //okay
}
    1458:	81 e0       	ldi	r24, 0x01	; 1
    145a:	08 95       	ret

0000145c <FIFO_TO_AVR>:
//Write one pixel in AVR
uint16_t FIFO_TO_AVR(void)
{
	uint16_t data = 0;
	
	FIFO_AVR_DPRT=0;
    145c:	11 b8       	out	0x01, r1	; 1
	
	FIFO_RCLK_SET;
    145e:	44 9a       	sbi	0x08, 4	; 8
	data = FIFO_AVR_PINP;
    1460:	80 b1       	in	r24, 0x00	; 0
	FIFO_RCLK_CLR;
    1462:	44 98       	cbi	0x08, 4	; 8

	data <<= 8;
    1464:	38 2f       	mov	r19, r24
    1466:	20 e0       	ldi	r18, 0x00	; 0
	
	FIFO_RCLK_SET;
    1468:	44 9a       	sbi	0x08, 4	; 8
	data |= FIFO_AVR_PINP;
    146a:	80 b1       	in	r24, 0x00	; 0
	FIFO_RCLK_CLR;
    146c:	44 98       	cbi	0x08, 4	; 8
	FIFO_RCLK_CLR;

	data <<= 8;
	
	FIFO_RCLK_SET;
	data |= FIFO_AVR_PINP;
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	82 2b       	or	r24, r18
    1472:	93 2b       	or	r25, r19
	//	FIFO_RCLK_CLR;
	//	FIFO_RCLK_SET;
	//	FIFO_RCLK_CLR;
	
	return(data);
}
    1474:	08 95       	ret

00001476 <GetImageIfAvailiable>:
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( int offset )
{
    1476:	ef 92       	push	r14
    1478:	ff 92       	push	r15
    147a:	0f 93       	push	r16
    147c:	1f 93       	push	r17
    147e:	cf 93       	push	r28
    1480:	df 93       	push	r29
	if (VSYNC_Count == 2)//if one full frame has elapsed.
    1482:	80 91 a2 02 	lds	r24, 0x02A2
    1486:	90 91 a3 02 	lds	r25, 0x02A3
    148a:	82 30       	cpi	r24, 0x02	; 2
    148c:	91 05       	cpc	r25, r1
    148e:	31 f5       	brne	.+76     	; 0x14dc <GetImageIfAvailiable+0x66>
		uint32_t p;
		unsigned long int pointer;
		//FRESULT fr;
		int i,j, ptr;
		uint16_t Temp;
		FIFO_nRRST_CLR; //Reset Read Pointer
    1490:	47 98       	cbi	0x08, 7	; 8
		FIFO_RCLK_SET;
    1492:	44 9a       	sbi	0x08, 4	; 8
		FIFO_RCLK_CLR;
    1494:	44 98       	cbi	0x08, 4	; 8
		FIFO_nRRST_SET;
    1496:	47 9a       	sbi	0x08, 7	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1498:	89 ef       	ldi	r24, 0xF9	; 249
    149a:	90 e0       	ldi	r25, 0x00	; 0
    149c:	01 97       	sbiw	r24, 0x01	; 1
    149e:	f1 f7       	brne	.-4      	; 0x149c <GetImageIfAvailiable+0x26>
    14a0:	00 c0       	rjmp	.+0      	; 0x14a2 <GetImageIfAvailiable+0x2c>
    14a2:	00 00       	nop
    14a4:	00 ef       	ldi	r16, 0xF0	; 240
    14a6:	10 e0       	ldi	r17, 0x00	; 0
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( int offset )
{
    14a8:	0f 2e       	mov	r0, r31
    14aa:	f0 e4       	ldi	r31, 0x40	; 64
    14ac:	ef 2e       	mov	r14, r31
    14ae:	f1 e0       	ldi	r31, 0x01	; 1
    14b0:	ff 2e       	mov	r15, r31
    14b2:	f0 2d       	mov	r31, r0
    14b4:	07 c0       	rjmp	.+14     	; 0x14c4 <GetImageIfAvailiable+0x4e>
		{
			ptr = 0;
			for (i=0; i < WIDTH; i++)
			{
				
				Temp=FIFO_TO_AVR();
    14b6:	0e 94 2e 0a 	call	0x145c	; 0x145c <FIFO_TO_AVR>
    14ba:	21 97       	sbiw	r28, 0x01	; 1
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=HEIGHT; j > 0; j--) //Read all data 
		{
			ptr = 0;
			for (i=0; i < WIDTH; i++)
    14bc:	e1 f7       	brne	.-8      	; 0x14b6 <GetImageIfAvailiable+0x40>
    14be:	01 50       	subi	r16, 0x01	; 1
    14c0:	10 40       	sbci	r17, 0x00	; 0
		FIFO_nRRST_CLR; //Reset Read Pointer
		FIFO_RCLK_SET;
		FIFO_RCLK_CLR;
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=HEIGHT; j > 0; j--) //Read all data 
    14c2:	11 f0       	breq	.+4      	; 0x14c8 <GetImageIfAvailiable+0x52>
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( int offset )
{
    14c4:	e7 01       	movw	r28, r14
    14c6:	f7 cf       	rjmp	.-18     	; 0x14b6 <GetImageIfAvailiable+0x40>
// 			}
			//xprintf(PSTR("%d:Write File Result %d, pointer location %u\n"), j, f_write(&File[0], Buff, WIDTH * 2, &p), pointer);
		}
		/*f_close(&File);*/
		/*FIFO_Reset();*/
		FIFO_nRRST_CLR; //Reset Read Pointer	
    14c8:	47 98       	cbi	0x08, 7	; 8
		FIFO_RCLK_SET;
    14ca:	44 9a       	sbi	0x08, 4	; 8
		FIFO_RCLK_CLR;
    14cc:	44 98       	cbi	0x08, 4	; 8
		FIFO_nRRST_SET;
    14ce:	47 9a       	sbi	0x08, 7	; 8
		VSYNC_Count = 0; //No image present in buffer
    14d0:	10 92 a3 02 	sts	0x02A3, r1
    14d4:	10 92 a2 02 	sts	0x02A2, r1
// 		xprintf(PSTR("Success!\n"));
// 		xprintf(PSTR("Closing File: %d\n"), f_close(&File[0]));
		return 1; //Success!
    14d8:	81 e0       	ldi	r24, 0x01	; 1
    14da:	01 c0       	rjmp	.+2      	; 0x14de <GetImageIfAvailiable+0x68>
	}
	else
	{
		return 0;// No image available
    14dc:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    14de:	df 91       	pop	r29
    14e0:	cf 91       	pop	r28
    14e2:	1f 91       	pop	r17
    14e4:	0f 91       	pop	r16
    14e6:	ff 90       	pop	r15
    14e8:	ef 90       	pop	r14
    14ea:	08 95       	ret

000014ec <TWI_Master_Initialise>:
		DDRC = 0x00;
		PORTC = (1 << PC0) | (1 << PC1);
	#else
		#pragma message("External I2C Pull Ups Required.")
	#endif
	TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
    14ec:	84 e3       	ldi	r24, 0x34	; 52
    14ee:	80 93 b8 00 	sts	0x00B8, r24
	// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
	TWDR = 0xFF;                                      // Default content = SDA released.
    14f2:	8f ef       	ldi	r24, 0xFF	; 255
    14f4:	80 93 bb 00 	sts	0x00BB, r24
	TWCR =	(1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
    14f8:	84 e0       	ldi	r24, 0x04	; 4
    14fa:	80 93 bc 00 	sts	0x00BC, r24
			(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
			(0<<TWWC);                                 //
}    
    14fe:	08 95       	ret

00001500 <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
    1500:	80 91 bc 00 	lds	r24, 0x00BC
}
    1504:	81 70       	andi	r24, 0x01	; 1
    1506:	08 95       	ret

00001508 <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
    1508:	0e 94 80 0a 	call	0x1500	; 0x1500 <TWI_Transceiver_Busy>
    150c:	88 23       	and	r24, r24
    150e:	e1 f7       	brne	.-8      	; 0x1508 <TWI_Get_State_Info>
  return ( TWI_state );                         // Return error state.
}
    1510:	80 91 a1 02 	lds	r24, 0x02A1
    1514:	08 95       	ret

00001516 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
    1516:	0f 93       	push	r16
    1518:	1f 93       	push	r17
    151a:	cf 93       	push	r28
    151c:	8c 01       	movw	r16, r24
    151e:	c6 2f       	mov	r28, r22
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    1520:	0e 94 80 0a 	call	0x1500	; 0x1500 <TWI_Transceiver_Busy>
    1524:	88 23       	and	r24, r24
    1526:	e1 f7       	brne	.-8      	; 0x1520 <TWI_Start_Transceiver_With_Data+0xa>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
    1528:	c0 93 ab 02 	sts	0x02AB, r28
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
    152c:	f8 01       	movw	r30, r16
    152e:	80 81       	ld	r24, Z
    1530:	80 93 ac 02 	sts	0x02AC, r24
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
    1534:	80 fd       	sbrc	r24, 0
    1536:	0c c0       	rjmp	.+24     	; 0x1550 <TWI_Start_Transceiver_With_Data+0x3a>
  {
    for ( temp = 1; temp < msgSize; temp++ )
    1538:	c2 30       	cpi	r28, 0x02	; 2
    153a:	50 f0       	brcs	.+20     	; 0x1550 <TWI_Start_Transceiver_With_Data+0x3a>
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    153c:	d8 01       	movw	r26, r16
    153e:	11 96       	adiw	r26, 0x01	; 1

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    1540:	ed ea       	ldi	r30, 0xAD	; 173
    1542:	f2 e0       	ldi	r31, 0x02	; 2
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    1544:	81 e0       	ldi	r24, 0x01	; 1
  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
      TWI_buf[ temp ] = msg[ temp ];
    1546:	9d 91       	ld	r25, X+
    1548:	91 93       	st	Z+, r25

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    154a:	8f 5f       	subi	r24, 0xFF	; 255
    154c:	8c 17       	cp	r24, r28
    154e:	d9 f7       	brne	.-10     	; 0x1546 <TWI_Start_Transceiver_With_Data+0x30>
      TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
    1550:	10 92 aa 02 	sts	0x02AA, r1
  TWI_state         = TWI_NO_STATE ;
    1554:	88 ef       	ldi	r24, 0xF8	; 248
    1556:	80 93 a1 02 	sts	0x02A1, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    155a:	85 ea       	ldi	r24, 0xA5	; 165
    155c:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    1560:	cf 91       	pop	r28
    1562:	1f 91       	pop	r17
    1564:	0f 91       	pop	r16
    1566:	08 95       	ret

00001568 <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    1568:	0e 94 80 0a 	call	0x1500	; 0x1500 <TWI_Transceiver_Busy>
    156c:	88 23       	and	r24, r24
    156e:	e1 f7       	brne	.-8      	; 0x1568 <TWI_Start_Transceiver>
  TWI_statusReg.all = 0;      
    1570:	10 92 aa 02 	sts	0x02AA, r1
  TWI_state         = TWI_NO_STATE ;
    1574:	88 ef       	ldi	r24, 0xF8	; 248
    1576:	80 93 a1 02 	sts	0x02A1, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    157a:	85 ea       	ldi	r24, 0xA5	; 165
    157c:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    1580:	08 95       	ret

00001582 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    1582:	1f 93       	push	r17
    1584:	cf 93       	push	r28
    1586:	df 93       	push	r29
    1588:	d8 2f       	mov	r29, r24
    158a:	19 2f       	mov	r17, r25
    158c:	c6 2f       	mov	r28, r22
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    158e:	0e 94 80 0a 	call	0x1500	; 0x1500 <TWI_Transceiver_Busy>
    1592:	88 23       	and	r24, r24
    1594:	e1 f7       	brne	.-8      	; 0x158e <TWI_Get_Data_From_Transceiver+0xc>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    1596:	80 91 aa 02 	lds	r24, 0x02AA
    159a:	80 ff       	sbrs	r24, 0
    159c:	0d c0       	rjmp	.+26     	; 0x15b8 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    159e:	cc 23       	and	r28, r28
    15a0:	59 f0       	breq	.+22     	; 0x15b8 <TWI_Get_Data_From_Transceiver+0x36>
    15a2:	ac ea       	ldi	r26, 0xAC	; 172
    15a4:	b2 e0       	ldi	r27, 0x02	; 2
    15a6:	9d 2f       	mov	r25, r29
    15a8:	ed 2f       	mov	r30, r29
    15aa:	f1 2f       	mov	r31, r17
    {
      msg[ i ] = TWI_buf[ i ];
    15ac:	8d 91       	ld	r24, X+
    15ae:	81 93       	st	Z+, r24

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    15b0:	8e 2f       	mov	r24, r30
    15b2:	89 1b       	sub	r24, r25
    15b4:	8c 17       	cp	r24, r28
    15b6:	d0 f3       	brcs	.-12     	; 0x15ac <TWI_Get_Data_From_Transceiver+0x2a>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    15b8:	80 91 aa 02 	lds	r24, 0x02AA
}
    15bc:	81 70       	andi	r24, 0x01	; 1
    15be:	df 91       	pop	r29
    15c0:	cf 91       	pop	r28
    15c2:	1f 91       	pop	r17
    15c4:	08 95       	ret

000015c6 <__vector_26>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/

ISR(TWI_vect)
{
    15c6:	1f 92       	push	r1
    15c8:	0f 92       	push	r0
    15ca:	0f b6       	in	r0, 0x3f	; 63
    15cc:	0f 92       	push	r0
    15ce:	11 24       	eor	r1, r1
    15d0:	2f 93       	push	r18
    15d2:	3f 93       	push	r19
    15d4:	8f 93       	push	r24
    15d6:	9f 93       	push	r25
    15d8:	ef 93       	push	r30
    15da:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    15dc:	80 91 b9 00 	lds	r24, 0x00B9
    15e0:	88 32       	cpi	r24, 0x28	; 40
    15e2:	d1 f0       	breq	.+52     	; 0x1618 <__vector_26+0x52>
    15e4:	89 32       	cpi	r24, 0x29	; 41
    15e6:	40 f4       	brcc	.+16     	; 0x15f8 <__vector_26+0x32>
    15e8:	80 31       	cpi	r24, 0x10	; 16
    15ea:	a1 f0       	breq	.+40     	; 0x1614 <__vector_26+0x4e>
    15ec:	88 31       	cpi	r24, 0x18	; 24
    15ee:	a1 f0       	breq	.+40     	; 0x1618 <__vector_26+0x52>
    15f0:	88 30       	cpi	r24, 0x08	; 8
    15f2:	09 f0       	breq	.+2      	; 0x15f6 <__vector_26+0x30>
    15f4:	61 c0       	rjmp	.+194    	; 0x16b8 <__vector_26+0xf2>
    15f6:	0e c0       	rjmp	.+28     	; 0x1614 <__vector_26+0x4e>
    15f8:	80 34       	cpi	r24, 0x40	; 64
    15fa:	b9 f1       	breq	.+110    	; 0x166a <__vector_26+0xa4>
    15fc:	81 34       	cpi	r24, 0x41	; 65
    15fe:	20 f4       	brcc	.+8      	; 0x1608 <__vector_26+0x42>
    1600:	88 33       	cpi	r24, 0x38	; 56
    1602:	09 f0       	breq	.+2      	; 0x1606 <__vector_26+0x40>
    1604:	59 c0       	rjmp	.+178    	; 0x16b8 <__vector_26+0xf2>
    1606:	54 c0       	rjmp	.+168    	; 0x16b0 <__vector_26+0xea>
    1608:	80 35       	cpi	r24, 0x50	; 80
    160a:	19 f1       	breq	.+70     	; 0x1652 <__vector_26+0x8c>
    160c:	88 35       	cpi	r24, 0x58	; 88
    160e:	09 f0       	breq	.+2      	; 0x1612 <__vector_26+0x4c>
    1610:	53 c0       	rjmp	.+166    	; 0x16b8 <__vector_26+0xf2>
    1612:	3d c0       	rjmp	.+122    	; 0x168e <__vector_26+0xc8>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    1614:	10 92 b0 02 	sts	0x02B0, r1
    case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    1618:	80 91 b0 02 	lds	r24, 0x02B0
    161c:	90 91 ab 02 	lds	r25, 0x02AB
    1620:	89 17       	cp	r24, r25
    1622:	70 f4       	brcc	.+28     	; 0x1640 <__vector_26+0x7a>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    1624:	e8 2f       	mov	r30, r24
    1626:	f0 e0       	ldi	r31, 0x00	; 0
    1628:	e4 55       	subi	r30, 0x54	; 84
    162a:	fd 4f       	sbci	r31, 0xFD	; 253
    162c:	90 81       	ld	r25, Z
    162e:	90 93 bb 00 	sts	0x00BB, r25
    1632:	8f 5f       	subi	r24, 0xFF	; 255
    1634:	80 93 b0 02 	sts	0x02B0, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1638:	85 e8       	ldi	r24, 0x85	; 133
    163a:	80 93 bc 00 	sts	0x00BC, r24
    163e:	43 c0       	rjmp	.+134    	; 0x16c6 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    1640:	80 91 aa 02 	lds	r24, 0x02AA
    1644:	81 60       	ori	r24, 0x01	; 1
    1646:	80 93 aa 02 	sts	0x02AA, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    164a:	84 e9       	ldi	r24, 0x94	; 148
    164c:	80 93 bc 00 	sts	0x00BC, r24
    1650:	3a c0       	rjmp	.+116    	; 0x16c6 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    1652:	80 91 b0 02 	lds	r24, 0x02B0
    1656:	90 91 bb 00 	lds	r25, 0x00BB
    165a:	e8 2f       	mov	r30, r24
    165c:	f0 e0       	ldi	r31, 0x00	; 0
    165e:	e4 55       	subi	r30, 0x54	; 84
    1660:	fd 4f       	sbci	r31, 0xFD	; 253
    1662:	90 83       	st	Z, r25
    1664:	8f 5f       	subi	r24, 0xFF	; 255
    1666:	80 93 b0 02 	sts	0x02B0, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    166a:	20 91 b0 02 	lds	r18, 0x02B0
    166e:	30 e0       	ldi	r19, 0x00	; 0
    1670:	80 91 ab 02 	lds	r24, 0x02AB
    1674:	90 e0       	ldi	r25, 0x00	; 0
    1676:	01 97       	sbiw	r24, 0x01	; 1
    1678:	28 17       	cp	r18, r24
    167a:	39 07       	cpc	r19, r25
    167c:	24 f4       	brge	.+8      	; 0x1686 <__vector_26+0xc0>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    167e:	85 ec       	ldi	r24, 0xC5	; 197
    1680:	80 93 bc 00 	sts	0x00BC, r24
    1684:	20 c0       	rjmp	.+64     	; 0x16c6 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1686:	85 e8       	ldi	r24, 0x85	; 133
    1688:	80 93 bc 00 	sts	0x00BC, r24
    168c:	1c c0       	rjmp	.+56     	; 0x16c6 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    168e:	80 91 bb 00 	lds	r24, 0x00BB
    1692:	e0 91 b0 02 	lds	r30, 0x02B0
    1696:	f0 e0       	ldi	r31, 0x00	; 0
    1698:	e4 55       	subi	r30, 0x54	; 84
    169a:	fd 4f       	sbci	r31, 0xFD	; 253
    169c:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    169e:	80 91 aa 02 	lds	r24, 0x02AA
    16a2:	81 60       	ori	r24, 0x01	; 1
    16a4:	80 93 aa 02 	sts	0x02AA, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    16a8:	84 e9       	ldi	r24, 0x94	; 148
    16aa:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    16ae:	0b c0       	rjmp	.+22     	; 0x16c6 <__vector_26+0x100>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    16b0:	85 ea       	ldi	r24, 0xA5	; 165
    16b2:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    16b6:	07 c0       	rjmp	.+14     	; 0x16c6 <__vector_26+0x100>
    case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    16b8:	80 91 b9 00 	lds	r24, 0x00B9
    16bc:	80 93 a1 02 	sts	0x02A1, r24
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    16c0:	84 e0       	ldi	r24, 0x04	; 4
    16c2:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    16c6:	ff 91       	pop	r31
    16c8:	ef 91       	pop	r30
    16ca:	9f 91       	pop	r25
    16cc:	8f 91       	pop	r24
    16ce:	3f 91       	pop	r19
    16d0:	2f 91       	pop	r18
    16d2:	0f 90       	pop	r0
    16d4:	0f be       	out	0x3f, r0	; 63
    16d6:	0f 90       	pop	r0
    16d8:	1f 90       	pop	r1
    16da:	18 95       	reti

000016dc <__mulsi3>:
    16dc:	62 9f       	mul	r22, r18
    16de:	d0 01       	movw	r26, r0
    16e0:	73 9f       	mul	r23, r19
    16e2:	f0 01       	movw	r30, r0
    16e4:	82 9f       	mul	r24, r18
    16e6:	e0 0d       	add	r30, r0
    16e8:	f1 1d       	adc	r31, r1
    16ea:	64 9f       	mul	r22, r20
    16ec:	e0 0d       	add	r30, r0
    16ee:	f1 1d       	adc	r31, r1
    16f0:	92 9f       	mul	r25, r18
    16f2:	f0 0d       	add	r31, r0
    16f4:	83 9f       	mul	r24, r19
    16f6:	f0 0d       	add	r31, r0
    16f8:	74 9f       	mul	r23, r20
    16fa:	f0 0d       	add	r31, r0
    16fc:	65 9f       	mul	r22, r21
    16fe:	f0 0d       	add	r31, r0
    1700:	99 27       	eor	r25, r25
    1702:	72 9f       	mul	r23, r18
    1704:	b0 0d       	add	r27, r0
    1706:	e1 1d       	adc	r30, r1
    1708:	f9 1f       	adc	r31, r25
    170a:	63 9f       	mul	r22, r19
    170c:	b0 0d       	add	r27, r0
    170e:	e1 1d       	adc	r30, r1
    1710:	f9 1f       	adc	r31, r25
    1712:	bd 01       	movw	r22, r26
    1714:	cf 01       	movw	r24, r30
    1716:	11 24       	eor	r1, r1
    1718:	08 95       	ret

0000171a <__divmodsi4>:
    171a:	97 fb       	bst	r25, 7
    171c:	09 2e       	mov	r0, r25
    171e:	05 26       	eor	r0, r21
    1720:	0e d0       	rcall	.+28     	; 0x173e <__divmodsi4_neg1>
    1722:	57 fd       	sbrc	r21, 7
    1724:	04 d0       	rcall	.+8      	; 0x172e <__divmodsi4_neg2>
    1726:	14 d0       	rcall	.+40     	; 0x1750 <__udivmodsi4>
    1728:	0a d0       	rcall	.+20     	; 0x173e <__divmodsi4_neg1>
    172a:	00 1c       	adc	r0, r0
    172c:	38 f4       	brcc	.+14     	; 0x173c <__divmodsi4_exit>

0000172e <__divmodsi4_neg2>:
    172e:	50 95       	com	r21
    1730:	40 95       	com	r20
    1732:	30 95       	com	r19
    1734:	21 95       	neg	r18
    1736:	3f 4f       	sbci	r19, 0xFF	; 255
    1738:	4f 4f       	sbci	r20, 0xFF	; 255
    173a:	5f 4f       	sbci	r21, 0xFF	; 255

0000173c <__divmodsi4_exit>:
    173c:	08 95       	ret

0000173e <__divmodsi4_neg1>:
    173e:	f6 f7       	brtc	.-4      	; 0x173c <__divmodsi4_exit>
    1740:	90 95       	com	r25
    1742:	80 95       	com	r24
    1744:	70 95       	com	r23
    1746:	61 95       	neg	r22
    1748:	7f 4f       	sbci	r23, 0xFF	; 255
    174a:	8f 4f       	sbci	r24, 0xFF	; 255
    174c:	9f 4f       	sbci	r25, 0xFF	; 255
    174e:	08 95       	ret

00001750 <__udivmodsi4>:
    1750:	a1 e2       	ldi	r26, 0x21	; 33
    1752:	1a 2e       	mov	r1, r26
    1754:	aa 1b       	sub	r26, r26
    1756:	bb 1b       	sub	r27, r27
    1758:	fd 01       	movw	r30, r26
    175a:	0d c0       	rjmp	.+26     	; 0x1776 <__udivmodsi4_ep>

0000175c <__udivmodsi4_loop>:
    175c:	aa 1f       	adc	r26, r26
    175e:	bb 1f       	adc	r27, r27
    1760:	ee 1f       	adc	r30, r30
    1762:	ff 1f       	adc	r31, r31
    1764:	a2 17       	cp	r26, r18
    1766:	b3 07       	cpc	r27, r19
    1768:	e4 07       	cpc	r30, r20
    176a:	f5 07       	cpc	r31, r21
    176c:	20 f0       	brcs	.+8      	; 0x1776 <__udivmodsi4_ep>
    176e:	a2 1b       	sub	r26, r18
    1770:	b3 0b       	sbc	r27, r19
    1772:	e4 0b       	sbc	r30, r20
    1774:	f5 0b       	sbc	r31, r21

00001776 <__udivmodsi4_ep>:
    1776:	66 1f       	adc	r22, r22
    1778:	77 1f       	adc	r23, r23
    177a:	88 1f       	adc	r24, r24
    177c:	99 1f       	adc	r25, r25
    177e:	1a 94       	dec	r1
    1780:	69 f7       	brne	.-38     	; 0x175c <__udivmodsi4_loop>
    1782:	60 95       	com	r22
    1784:	70 95       	com	r23
    1786:	80 95       	com	r24
    1788:	90 95       	com	r25
    178a:	9b 01       	movw	r18, r22
    178c:	ac 01       	movw	r20, r24
    178e:	bd 01       	movw	r22, r26
    1790:	cf 01       	movw	r24, r30
    1792:	08 95       	ret

00001794 <_exit>:
    1794:	f8 94       	cli

00001796 <__stop_program>:
    1796:	ff cf       	rjmp	.-2      	; 0x1796 <__stop_program>
