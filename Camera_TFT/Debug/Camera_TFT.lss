
Camera_TFT.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001a2  00800100  00001692  00001726  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001692  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000f  008002a2  008002a2  000018c8  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  000018c8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00001f94  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  00002020  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002b9d  00000000  00000000  00002180  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a8b  00000000  00000000  00004d1d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000fed  00000000  00000000  000057a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000069c  00000000  00000000  00006798  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007bf  00000000  00000000  00006e34  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000020f2  00000000  00000000  000075f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000070  00000000  00000000  000096e5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e5 01 	jmp	0x3ca	; 0x3ca <__ctors_end>
       4:	0c 94 b3 08 	jmp	0x1166	; 0x1166 <__vector_1>
       8:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
       c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      10:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      14:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      18:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      1c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      20:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      24:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      28:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      2c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      30:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      34:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      38:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      3c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      40:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      44:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      48:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      4c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      50:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      54:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      58:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      5c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      60:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      64:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      68:	0c 94 60 0a 	jmp	0x14c0	; 0x14c0 <__vector_26>
      6c:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      70:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      74:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>
      78:	0c 94 02 02 	jmp	0x404	; 0x404 <__bad_interrupt>

0000007c <Verdana_font_11>:
      7c:	00 0b 09 21 5f 3b 00 01 00 04 00 0b 00 10 00 1a     ...!_;..........
      8c:	00 21 00 22 00 25 00 28 00 2d 00 34 00 36 00 39     .!.".%.(.-.4.6.9
      9c:	00 3a 00 3f 00 44 00 49 00 4e 00 53 00 59 00 5e     .:.?.D.I.N.S.Y.^
      ac:	00 63 00 68 00 6d 00 72 00 73 00 75 00 7b 00 82     .c.h.m.r.s.u.{..
      bc:	00 88 00 8c 00 94 00 9a 00 a0 00 a7 00 ae 00 b3     ................
      cc:	00 b8 00 bf 00 c5 00 c8 00 cc 00 d2 00 d7 00 de     ................
      dc:	00 e4 00 eb 00 f0 00 f7 00 fd 01 03 01 0a 01 10     ................
      ec:	01 16 01 1f 01 25 01 2c 01 32 01 35 01 3a 01 3d     .....%.,.2.5.:.=
      fc:	01 44 01 4b 01 4d 01 52 01 57 01 5c 01 61 01 66     .D.K.M.R.W.\.a.f
     10c:	01 6a 01 6f 01 74 01 75 01 78 01 7d 01 7e 01 87     .j.o.t.u.x.}.~..
     11c:	01 8c 01 91 01 96 01 9b 01 9f 01 a3 01 a7 01 ac     ................
     12c:	01 b1 01 b8 01 bd 01 c2 01 c6 01 cb 01 cc 01 d1     ................
     13c:	01 d8 01 d8 50 04 00 00 4c 20 00 02 00 00 00 00     ....P...L ......
	...
     164:	00 00 3c 38 00 10 20 00 80 c1 09 84 00 00 00 00     ..<8.. .........
     174:	00 00 00 00 00 7c 00 d1 44 62 18 52 a8 00 02 e2     .....|..Db.R....
     184:	39 c1 7c df 73 80 00 00 e3 e3 3c 3d f3 ff 3d 0f     9.|.s.....<=..=.
     194:	78 61 8f 13 9e 39 e3 df e1 86 23 0c 1f e4 08 80     xa...9....#.....
     1a4:	08 20 00 81 01 00 84 00 00 00 00 08 00 00 00 00     . ..............
     1b4:	92 00 d1 4f 92 24 52 70 80 05 1e 46 23 41 01 8c     ...O.$Rp...F#A..
     1c4:	40 00 00 14 13 22 43 0a 10 43 0a 18 a1 8f 14 51     @...."C..C.....Q
     1d4:	45 14 22 21 86 23 0a 20 62 09 40 00 20 00 81 01     E."!.#. b.@. ...
     1e4:	00 84 00 00 00 00 08 00 00 00 00 92 00 87 f4 94     ................
     1f4:	24 21 a8 80 05 12 04 25 42 02 8c 68 60 30 19 d4     $!.....%B..h`0..
     204:	a2 81 06 10 81 0a 19 21 56 98 31 83 14 02 21 85     .......!V.1...!.
     214:	54 91 40 a2 0a 20 03 bc e7 bb df eb 8f dd e7 79     T.@.. .........y
     224:	f6 ff 18 c9 8c 7c 92 00 82 94 64 19 21 20 80 09     .....|....d.! ..
     234:	12 08 c9 7b c2 74 69 9f cc 2a 54 be 81 07 fe 81     ...{.ti..*T.....
     244:	fa 1a 21 56 98 31 83 13 02 21 49 54 60 81 21 0c     ..!V.1...!IT`.!.
     254:	10 00 63 18 c5 23 19 96 23 18 c6 39 09 18 c9 52     ..c..#..#..9...R
     264:	84 92 31 82 8e 09 a5 21 07 f3 89 12 10 31 06 24     ..1....!.....1.$
     274:	8b c6 00 03 4a 54 a1 81 06 10 8f 0a 1e 21 26 58     ....JT.......!&X
     284:	3e 83 e0 c2 21 49 54 60 82 21 08 00 03 e3 08 fd     >...!IT`.!......
     294:	23 19 a6 23 18 c6 31 89 15 55 22 8b 11 c9 8f c5     #..#..1..U".....
     2a4:	0a 62 21 00 80 11 12 20 3f 86 24 88 41 9f cc 4a     .b!.... ?.$.A..J
     2b4:	5f e1 81 06 10 83 0a 19 21 26 58 30 83 20 22 21     _.......!&X0. "!
     2c4:	49 54 90 84 20 88 00 04 63 08 c1 23 19 e6 23 18     IT.. ...c..#..#.
     2d4:	c6 30 69 15 55 22 90 92 46 05 05 12 63 21 00 84     .0i.U"..F...c!..
     2e4:	51 12 42 21 46 28 88 a8 60 30 09 a8 61 43 0a 10     Q.B!F(..`0..aC..
     2f4:	43 0a 18 a1 06 34 50 45 14 22 21 30 89 08 88 20     C....4PE."!0... 
     304:	88 00 04 63 18 c5 23 19 96 23 18 c6 30 29 12 22     ...c..#..#..0)."
     314:	51 20 92 00 85 1e 11 9c 92 00 84 60 ef fd c1 39     Q .........`...9
     324:	c8 73 28 00 00 44 08 7e 3d f3 f0 3d 0f e8 7f 06     .s(..D.~=..=....
     334:	33 90 39 0b c2 1e 30 89 08 8f e0 48 00 03 fc e7     3.9...0....H....
     344:	b9 1f 19 8e 23 17 79 f1 c6 f2 22 89 3c 92 00 00     ....#.y...".<...
     354:	04 00 00 12 00 04 20 00 00 00 00 00 00 08 00 00     ...... .........
     364:	03 c0 00 00 00 00 00 00 00 00 00 00 00 08 00 00     ................
     374:	00 00 00 00 00 20 48 00 00 00 00 00 02 01 00 00     ..... H.........
     384:	00 40 20 00 00 00 01 00 92 00 00 04 00 00 0c 00     .@ .............
     394:	08 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00     ................
	...
     3ac:	06 00 00 00 00 00 00 00 38 38 0f e0 00 00 00 1c     ........88......
     3bc:	06 00 00 00 40 20 00 00 00 02 00 7c 00 00           ....@ .....|..

000003ca <__ctors_end>:
     3ca:	11 24       	eor	r1, r1
     3cc:	1f be       	out	0x3f, r1	; 63
     3ce:	cf ef       	ldi	r28, 0xFF	; 255
     3d0:	d0 e1       	ldi	r29, 0x10	; 16
     3d2:	de bf       	out	0x3e, r29	; 62
     3d4:	cd bf       	out	0x3d, r28	; 61

000003d6 <__do_copy_data>:
     3d6:	12 e0       	ldi	r17, 0x02	; 2
     3d8:	a0 e0       	ldi	r26, 0x00	; 0
     3da:	b1 e0       	ldi	r27, 0x01	; 1
     3dc:	e2 e9       	ldi	r30, 0x92	; 146
     3de:	f6 e1       	ldi	r31, 0x16	; 22
     3e0:	02 c0       	rjmp	.+4      	; 0x3e6 <__do_copy_data+0x10>
     3e2:	05 90       	lpm	r0, Z+
     3e4:	0d 92       	st	X+, r0
     3e6:	a2 3a       	cpi	r26, 0xA2	; 162
     3e8:	b1 07       	cpc	r27, r17
     3ea:	d9 f7       	brne	.-10     	; 0x3e2 <__do_copy_data+0xc>

000003ec <__do_clear_bss>:
     3ec:	12 e0       	ldi	r17, 0x02	; 2
     3ee:	a2 ea       	ldi	r26, 0xA2	; 162
     3f0:	b2 e0       	ldi	r27, 0x02	; 2
     3f2:	01 c0       	rjmp	.+2      	; 0x3f6 <.do_clear_bss_start>

000003f4 <.do_clear_bss_loop>:
     3f4:	1d 92       	st	X+, r1

000003f6 <.do_clear_bss_start>:
     3f6:	a1 3b       	cpi	r26, 0xB1	; 177
     3f8:	b1 07       	cpc	r27, r17
     3fa:	e1 f7       	brne	.-8      	; 0x3f4 <.do_clear_bss_loop>
     3fc:	0e 94 05 02 	call	0x40a	; 0x40a <main>
     400:	0c 94 47 0b 	jmp	0x168e	; 0x168e <_exit>

00000404 <__bad_interrupt>:
     404:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000408 <_Z8SetPixeliit>:

void SetPixel(int x, int y, ushort colour ) 
{

	
}
     408:	08 95       	ret

0000040a <main>:

int main(void)
{
	TWI_Master_Initialise();
     40a:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <TWI_Master_Initialise>
	LCD::Init();
     40e:	0e 94 cb 04 	call	0x996	; 0x996 <_ZN3LCD4InitEv>
	sei();
     412:	78 94       	sei
	Graphics::Rectangle(0,0,240,320, _paletteW[0]);
     414:	00 91 00 01 	lds	r16, 0x0100
     418:	10 91 01 01 	lds	r17, 0x0101
     41c:	80 e0       	ldi	r24, 0x00	; 0
     41e:	90 e0       	ldi	r25, 0x00	; 0
     420:	60 e0       	ldi	r22, 0x00	; 0
     422:	70 e0       	ldi	r23, 0x00	; 0
     424:	40 ef       	ldi	r20, 0xF0	; 240
     426:	50 e0       	ldi	r21, 0x00	; 0
     428:	20 e4       	ldi	r18, 0x40	; 64
     42a:	31 e0       	ldi	r19, 0x01	; 1
     42c:	0e 94 3a 02 	call	0x474	; 0x474 <_ZN8Graphics9RectangleEiiiii>
	Graphics::BeginPixels();
     430:	0e 94 b9 02 	call	0x572	; 0x572 <_ZN8Graphics11BeginPixelsEv>
	int x,y;//,height,width;
	x = 0;
	y = 0;
		
	//LCD::SetPixel(x, y, colour);
	FIFO_init();
     434:	0e 94 86 09 	call	0x130c	; 0x130c <FIFO_init>
	if(OV7670_init() == 1)
     438:	0e 94 29 09 	call	0x1252	; 0x1252 <OV7670_init>
     43c:	81 30       	cpi	r24, 0x01	; 1
     43e:	29 f4       	brne	.+10     	; 0x44a <main+0x40>
		colour = _paletteW[12];//green
     440:	00 91 18 01 	lds	r16, 0x0118
     444:	10 91 19 01 	lds	r17, 0x0119
     448:	04 c0       	rjmp	.+8      	; 0x452 <main+0x48>
	else
		colour = _paletteW[1];
     44a:	00 91 02 01 	lds	r16, 0x0102
     44e:	10 91 03 01 	lds	r17, 0x0103
	Graphics::Rectangle(0,0, LCD::GetWidth(), LCD::GetHeight(), colour);
     452:	0e 94 3c 06 	call	0xc78	; 0xc78 <_ZN3LCD8GetWidthEv>
     456:	ec 01       	movw	r28, r24
     458:	0e 94 3f 06 	call	0xc7e	; 0xc7e <_ZN3LCD9GetHeightEv>
     45c:	9c 01       	movw	r18, r24
     45e:	80 e0       	ldi	r24, 0x00	; 0
     460:	90 e0       	ldi	r25, 0x00	; 0
     462:	60 e0       	ldi	r22, 0x00	; 0
     464:	70 e0       	ldi	r23, 0x00	; 0
     466:	ae 01       	movw	r20, r28
     468:	0e 94 3a 02 	call	0x474	; 0x474 <_ZN8Graphics9RectangleEiiiii>
     46c:	ff cf       	rjmp	.-2      	; 0x46c <main+0x62>

0000046e <_ZN8Graphics4InitEv>:
    DrawString(s,strlen(s),x,y);
}

void Graphics::Init()
{
    LCD::Init();
     46e:	0e 94 cb 04 	call	0x996	; 0x996 <_ZN3LCD4InitEv>
}
     472:	08 95       	ret

00000474 <_ZN8Graphics9RectangleEiiiii>:

void Graphics::Rectangle(int x, int y, int width, int height, int color)
{
     474:	8f 92       	push	r8
     476:	9f 92       	push	r9
     478:	af 92       	push	r10
     47a:	bf 92       	push	r11
     47c:	cf 92       	push	r12
     47e:	df 92       	push	r13
     480:	ef 92       	push	r14
     482:	ff 92       	push	r15
     484:	0f 93       	push	r16
     486:	1f 93       	push	r17
     488:	cf 93       	push	r28
     48a:	df 93       	push	r29
     48c:	ec 01       	movw	r28, r24
     48e:	5b 01       	movw	r10, r22
     490:	48 01       	movw	r8, r16
    int right = x + width;
     492:	8c 01       	movw	r16, r24
     494:	04 0f       	add	r16, r20
     496:	15 1f       	adc	r17, r21
    int bottom = y + height;
     498:	7b 01       	movw	r14, r22
     49a:	e2 0e       	add	r14, r18
     49c:	f3 1e       	adc	r15, r19
    right = min(right,(int)LCD::GetWidth());
     49e:	0e 94 3c 06 	call	0xc78	; 0xc78 <_ZN3LCD8GetWidthEv>
     4a2:	08 17       	cp	r16, r24
     4a4:	19 07       	cpc	r17, r25
     4a6:	24 f0       	brlt	.+8      	; 0x4b0 <_ZN8Graphics9RectangleEiiiii+0x3c>
     4a8:	0e 94 3c 06 	call	0xc78	; 0xc78 <_ZN3LCD8GetWidthEv>
     4ac:	08 2f       	mov	r16, r24
     4ae:	19 2f       	mov	r17, r25
    bottom = min(bottom,(int)LCD::GetHeight());
     4b0:	0e 94 3f 06 	call	0xc7e	; 0xc7e <_ZN3LCD9GetHeightEv>
     4b4:	e8 16       	cp	r14, r24
     4b6:	f9 06       	cpc	r15, r25
     4b8:	24 f0       	brlt	.+8      	; 0x4c2 <_ZN8Graphics9RectangleEiiiii+0x4e>
     4ba:	0e 94 3f 06 	call	0xc7e	; 0xc7e <_ZN3LCD9GetHeightEv>
     4be:	e8 2e       	mov	r14, r24
     4c0:	f9 2e       	mov	r15, r25
    x = max(x,0);
     4c2:	dd 23       	and	r29, r29
     4c4:	14 f4       	brge	.+4      	; 0x4ca <_ZN8Graphics9RectangleEiiiii+0x56>
     4c6:	c0 e0       	ldi	r28, 0x00	; 0
     4c8:	d0 e0       	ldi	r29, 0x00	; 0
    y = max(y,0);
    width = right - x;
     4ca:	68 01       	movw	r12, r16
     4cc:	cc 1a       	sub	r12, r28
     4ce:	dd 0a       	sbc	r13, r29
    height = bottom - y;
    if (width <= 0 || height <= 0)
     4d0:	1c 14       	cp	r1, r12
     4d2:	1d 04       	cpc	r1, r13
     4d4:	0c f0       	brlt	.+2      	; 0x4d8 <_ZN8Graphics9RectangleEiiiii+0x64>
     4d6:	3d c0       	rjmp	.+122    	; 0x552 <_ZN8Graphics9RectangleEiiiii+0xde>
    int right = x + width;
    int bottom = y + height;
    right = min(right,(int)LCD::GetWidth());
    bottom = min(bottom,(int)LCD::GetHeight());
    x = max(x,0);
    y = max(y,0);
     4d8:	85 01       	movw	r16, r10
     4da:	bb 20       	and	r11, r11
     4dc:	14 f4       	brge	.+4      	; 0x4e2 <_ZN8Graphics9RectangleEiiiii+0x6e>
     4de:	00 e0       	ldi	r16, 0x00	; 0
     4e0:	10 e0       	ldi	r17, 0x00	; 0
    width = right - x;
    height = bottom - y;
     4e2:	e0 1a       	sub	r14, r16
     4e4:	f1 0a       	sbc	r15, r17
    if (width <= 0 || height <= 0)
     4e6:	1e 14       	cp	r1, r14
     4e8:	1f 04       	cpc	r1, r15
     4ea:	9c f5       	brge	.+102    	; 0x552 <_ZN8Graphics9RectangleEiiiii+0xde>
        return;
        
    LCD::SetWrap(x,y,width,height);
     4ec:	ce 01       	movw	r24, r28
     4ee:	b8 01       	movw	r22, r16
     4f0:	a6 01       	movw	r20, r12
     4f2:	97 01       	movw	r18, r14
     4f4:	0e 94 08 06 	call	0xc10	; 0xc10 <_ZN3LCD7SetWrapEiiii>
    LCD::SetGRAM(x,y);
     4f8:	ce 01       	movw	r24, r28
     4fa:	b8 01       	movw	r22, r16
     4fc:	0e 94 34 06 	call	0xc68	; 0xc68 <_ZN3LCD7SetGRAMEii>
    LCD::SetColor(color);
     500:	c4 01       	movw	r24, r8
     502:	0e 94 42 06 	call	0xc84	; 0xc84 <_ZN3LCD8SetColorEt>
    
    // Keep 16 bit int range
    while (height > 128)
     506:	81 e8       	ldi	r24, 0x81	; 129
     508:	e8 16       	cp	r14, r24
     50a:	f1 04       	cpc	r15, r1
     50c:	cc f0       	brlt	.+50     	; 0x540 <_ZN8Graphics9RectangleEiiiii+0xcc>
    {
        LCD::SolidFill(width*128);
     50e:	86 01       	movw	r16, r12
     510:	16 95       	lsr	r17
     512:	10 2f       	mov	r17, r16
     514:	00 27       	eor	r16, r16
     516:	17 95       	ror	r17
     518:	07 95       	ror	r16
    right = min(right,(int)LCD::GetWidth());
    bottom = min(bottom,(int)LCD::GetHeight());
    x = max(x,0);
    y = max(y,0);
    width = right - x;
    height = bottom - y;
     51a:	e7 01       	movw	r28, r14
    LCD::SetColor(color);
    
    // Keep 16 bit int range
    while (height > 128)
    {
        LCD::SolidFill(width*128);
     51c:	c8 01       	movw	r24, r16
     51e:	0e 94 37 07 	call	0xe6e	; 0xe6e <_ZN3LCD9SolidFillEt>
        height -= 128;
     522:	c0 58       	subi	r28, 0x80	; 128
     524:	d0 40       	sbci	r29, 0x00	; 0
    LCD::SetWrap(x,y,width,height);
    LCD::SetGRAM(x,y);
    LCD::SetColor(color);
    
    // Keep 16 bit int range
    while (height > 128)
     526:	c1 38       	cpi	r28, 0x81	; 129
     528:	d1 05       	cpc	r29, r1
     52a:	c4 f7       	brge	.-16     	; 0x51c <_ZN8Graphics9RectangleEiiiii+0xa8>
void Graphics::Init()
{
    LCD::Init();
}

void Graphics::Rectangle(int x, int y, int width, int height, int color)
     52c:	c7 01       	movw	r24, r14
     52e:	80 58       	subi	r24, 0x80	; 128
     530:	90 40       	sbci	r25, 0x00	; 0
     532:	97 01       	movw	r18, r14
     534:	21 58       	subi	r18, 0x81	; 129
     536:	30 40       	sbci	r19, 0x00	; 0
     538:	20 78       	andi	r18, 0x80	; 128
     53a:	7c 01       	movw	r14, r24
     53c:	e2 1a       	sub	r14, r18
     53e:	f3 0a       	sbc	r15, r19
    while (height > 128)
    {
        LCD::SolidFill(width*128);
        height -= 128;
    }
    LCD::SolidFill(width*height);
     540:	ce 9c       	mul	r12, r14
     542:	c0 01       	movw	r24, r0
     544:	cf 9c       	mul	r12, r15
     546:	90 0d       	add	r25, r0
     548:	de 9c       	mul	r13, r14
     54a:	90 0d       	add	r25, r0
     54c:	11 24       	eor	r1, r1
     54e:	0e 94 37 07 	call	0xe6e	; 0xe6e <_ZN3LCD9SolidFillEt>
}
     552:	df 91       	pop	r29
     554:	cf 91       	pop	r28
     556:	1f 91       	pop	r17
     558:	0f 91       	pop	r16
     55a:	ff 90       	pop	r15
     55c:	ef 90       	pop	r14
     55e:	df 90       	pop	r13
     560:	cf 90       	pop	r12
     562:	bf 90       	pop	r11
     564:	af 90       	pop	r10
     566:	9f 90       	pop	r9
     568:	8f 90       	pop	r8
     56a:	08 95       	ret

0000056c <_ZN8Graphics8SetColorEt>:

void Graphics::SetColor(ushort color)
{
    LCD::SetColor(color);
     56c:	0e 94 42 06 	call	0xc84	; 0xc84 <_ZN3LCD8SetColorEt>
}
     570:	08 95       	ret

00000572 <_ZN8Graphics11BeginPixelsEv>:

void Graphics::BeginPixels()
{
    LCD::OpenWrap();
     572:	0e 94 47 06 	call	0xc8e	; 0xc8e <_ZN3LCD8OpenWrapEv>
    _ph = _pv = 0xFFFF;
     576:	8f ef       	ldi	r24, 0xFF	; 255
     578:	9f ef       	ldi	r25, 0xFF	; 255
     57a:	90 93 a5 02 	sts	0x02A5, r25
     57e:	80 93 a4 02 	sts	0x02A4, r24
     582:	90 93 a7 02 	sts	0x02A7, r25
     586:	80 93 a6 02 	sts	0x02A6, r24
}
     58a:	08 95       	ret

0000058c <_ZN8Graphics8PutPixelEtt>:

void Graphics::PutPixel(ushort x, ushort y)
{
     58c:	0f 93       	push	r16
     58e:	1f 93       	push	r17
     590:	cf 93       	push	r28
     592:	df 93       	push	r29
     594:	ec 01       	movw	r28, r24
     596:	8b 01       	movw	r16, r22
    if (x >= LCD::GetWidth() || y >= LCD::GetHeight())
     598:	0e 94 3c 06 	call	0xc78	; 0xc78 <_ZN3LCD8GetWidthEv>
     59c:	c8 17       	cp	r28, r24
     59e:	d9 07       	cpc	r29, r25
     5a0:	80 f5       	brcc	.+96     	; 0x602 <_ZN8Graphics8PutPixelEtt+0x76>
     5a2:	0e 94 3f 06 	call	0xc7e	; 0xc7e <_ZN3LCD9GetHeightEv>
     5a6:	08 17       	cp	r16, r24
     5a8:	19 07       	cpc	r17, r25
     5aa:	58 f5       	brcc	.+86     	; 0x602 <_ZN8Graphics8PutPixelEtt+0x76>
     5ac:	22 c0       	rjmp	.+68     	; 0x5f2 <_ZN8Graphics8PutPixelEtt+0x66>
        return; // Clip PutPixel to screen bounds
    if ((int)x != _ph || (int)y != _pv)
     5ae:	80 91 a4 02 	lds	r24, 0x02A4
     5b2:	90 91 a5 02 	lds	r25, 0x02A5
     5b6:	08 17       	cp	r16, r24
     5b8:	19 07       	cpc	r17, r25
     5ba:	69 f0       	breq	.+26     	; 0x5d6 <_ZN8Graphics8PutPixelEtt+0x4a>
    {
        LCD::SetGRAM(x,y);
     5bc:	ce 01       	movw	r24, r28
     5be:	60 2f       	mov	r22, r16
     5c0:	71 2f       	mov	r23, r17
     5c2:	0e 94 34 06 	call	0xc68	; 0xc68 <_ZN3LCD7SetGRAMEii>
        _ph = x;
     5c6:	d0 93 a7 02 	sts	0x02A7, r29
     5ca:	c0 93 a6 02 	sts	0x02A6, r28
        _pv = y;
     5ce:	00 93 a4 02 	sts	0x02A4, r16
     5d2:	10 93 a5 02 	sts	0x02A5, r17
    }
    LCD::SolidFill(1);
     5d6:	81 e0       	ldi	r24, 0x01	; 1
     5d8:	90 e0       	ldi	r25, 0x00	; 0
     5da:	0e 94 37 07 	call	0xe6e	; 0xe6e <_ZN3LCD9SolidFillEt>
    _ph++;
     5de:	80 91 a6 02 	lds	r24, 0x02A6
     5e2:	90 91 a7 02 	lds	r25, 0x02A7
     5e6:	01 96       	adiw	r24, 0x01	; 1
     5e8:	90 93 a7 02 	sts	0x02A7, r25
     5ec:	80 93 a6 02 	sts	0x02A6, r24
     5f0:	08 c0       	rjmp	.+16     	; 0x602 <_ZN8Graphics8PutPixelEtt+0x76>

void Graphics::PutPixel(ushort x, ushort y)
{
    if (x >= LCD::GetWidth() || y >= LCD::GetHeight())
        return; // Clip PutPixel to screen bounds
    if ((int)x != _ph || (int)y != _pv)
     5f2:	80 91 a6 02 	lds	r24, 0x02A6
     5f6:	90 91 a7 02 	lds	r25, 0x02A7
     5fa:	c8 17       	cp	r28, r24
     5fc:	d9 07       	cpc	r29, r25
     5fe:	f1 f6       	brne	.-68     	; 0x5bc <_ZN8Graphics8PutPixelEtt+0x30>
     600:	d6 cf       	rjmp	.-84     	; 0x5ae <_ZN8Graphics8PutPixelEtt+0x22>
        _ph = x;
        _pv = y;
    }
    LCD::SolidFill(1);
    _ph++;
}
     602:	df 91       	pop	r29
     604:	cf 91       	pop	r28
     606:	1f 91       	pop	r17
     608:	0f 91       	pop	r16
     60a:	08 95       	ret

0000060c <_Z8DrawChariii>:
#else
#define FNT(_x) Verdana_font_11[_x]
#endif

int DrawChar(int xx, int yy, int c)
{
     60c:	2f 92       	push	r2
     60e:	3f 92       	push	r3
     610:	4f 92       	push	r4
     612:	5f 92       	push	r5
     614:	6f 92       	push	r6
     616:	7f 92       	push	r7
     618:	8f 92       	push	r8
     61a:	9f 92       	push	r9
     61c:	af 92       	push	r10
     61e:	bf 92       	push	r11
     620:	cf 92       	push	r12
     622:	df 92       	push	r13
     624:	ef 92       	push	r14
     626:	ff 92       	push	r15
     628:	0f 93       	push	r16
     62a:	1f 93       	push	r17
     62c:	cf 93       	push	r28
     62e:	df 93       	push	r29
     630:	00 d0       	rcall	.+0      	; 0x632 <_Z8DrawChariii+0x26>
     632:	00 d0       	rcall	.+0      	; 0x634 <_Z8DrawChariii+0x28>
     634:	cd b7       	in	r28, 0x3d	; 61
     636:	de b7       	in	r29, 0x3e	; 62
     638:	2c 01       	movw	r4, r24
    //byte* f = Verdana_font_11;
    if (c == 32)
     63a:	40 32       	cpi	r20, 0x20	; 32
     63c:	51 05       	cpc	r21, r1
     63e:	51 f4       	brne	.+20     	; 0x654 <_Z8DrawChariii+0x48>
        return FNT(1)>>2;  // Space is 1/4 font height (yuk);
     640:	ed e7       	ldi	r30, 0x7D	; 125
     642:	f0 e0       	ldi	r31, 0x00	; 0
     644:	e4 91       	lpm	r30, Z
     646:	6e 2e       	mov	r6, r30
     648:	77 24       	eor	r7, r7
     64a:	75 94       	asr	r7
     64c:	67 94       	ror	r6
     64e:	75 94       	asr	r7
     650:	67 94       	ror	r6
     652:	c4 c0       	rjmp	.+392    	; 0x7dc <_Z8DrawChariii+0x1d0>

    int i = c - FNT(3);
     654:	ef e7       	ldi	r30, 0x7F	; 127
     656:	f0 e0       	ldi	r31, 0x00	; 0
     658:	e4 91       	lpm	r30, Z
     65a:	4e 1b       	sub	r20, r30
     65c:	51 09       	sbc	r21, r1
    if (i < 0 || i >= FNT(4)) return 0;
     65e:	55 23       	and	r21, r21
     660:	0c f4       	brge	.+2      	; 0x664 <_Z8DrawChariii+0x58>
     662:	b7 c0       	rjmp	.+366    	; 0x7d2 <_Z8DrawChariii+0x1c6>
     664:	a0 e8       	ldi	r26, 0x80	; 128
     666:	b0 e0       	ldi	r27, 0x00	; 0
     668:	fd 01       	movw	r30, r26
     66a:	84 91       	lpm	r24, Z
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	48 17       	cp	r20, r24
     670:	59 07       	cpc	r21, r25
     672:	0c f0       	brlt	.+2      	; 0x676 <_Z8DrawChariii+0x6a>
     674:	b1 c0       	rjmp	.+354    	; 0x7d8 <_Z8DrawChariii+0x1cc>

    int ci = 6 + i * 2;
     676:	ca 01       	movw	r24, r20
     678:	03 96       	adiw	r24, 0x03	; 3
     67a:	9c 01       	movw	r18, r24
     67c:	22 0f       	add	r18, r18
     67e:	33 1f       	adc	r19, r19
    int width = (FNT(ci) << 8) | FNT(ci + 1);   // simplify
     680:	f9 01       	movw	r30, r18
     682:	e4 58       	subi	r30, 0x84	; 132
     684:	ff 4f       	sbci	r31, 0xFF	; 255
     686:	94 91       	lpm	r25, Z
     688:	f9 01       	movw	r30, r18
     68a:	e3 58       	subi	r30, 0x83	; 131
     68c:	ff 4f       	sbci	r31, 0xFF	; 255
     68e:	84 91       	lpm	r24, Z
     690:	f9 2f       	mov	r31, r25
     692:	e0 e0       	ldi	r30, 0x00	; 0
     694:	90 e0       	ldi	r25, 0x00	; 0
     696:	3f 01       	movw	r6, r30
     698:	68 2a       	or	r6, r24
     69a:	79 2a       	or	r7, r25
    int height = FNT(1);
     69c:	0d e7       	ldi	r16, 0x7D	; 125
     69e:	10 e0       	ldi	r17, 0x00	; 0
     6a0:	f8 01       	movw	r30, r16
     6a2:	f4 91       	lpm	r31, Z
     6a4:	f9 83       	std	Y+1, r31	; 0x01
    int src = 0;
    if (i > 0)
     6a6:	14 16       	cp	r1, r20
     6a8:	15 06       	cpc	r1, r21
     6aa:	84 f4       	brge	.+32     	; 0x6cc <_Z8DrawChariii+0xc0>
    {
        src = (FNT(ci - 2) << 8) | FNT(ci - 1);
     6ac:	f9 01       	movw	r30, r18
     6ae:	e6 58       	subi	r30, 0x86	; 134
     6b0:	ff 4f       	sbci	r31, 0xFF	; 255
     6b2:	94 91       	lpm	r25, Z
     6b4:	f9 01       	movw	r30, r18
     6b6:	e5 58       	subi	r30, 0x85	; 133
     6b8:	ff 4f       	sbci	r31, 0xFF	; 255
     6ba:	84 91       	lpm	r24, Z
     6bc:	59 2f       	mov	r21, r25
     6be:	40 e0       	ldi	r20, 0x00	; 0
     6c0:	90 e0       	ldi	r25, 0x00	; 0
     6c2:	48 2b       	or	r20, r24
     6c4:	59 2b       	or	r21, r25
        width -= src;
     6c6:	64 1a       	sub	r6, r20
     6c8:	75 0a       	sbc	r7, r21
     6ca:	02 c0       	rjmp	.+4      	; 0x6d0 <_Z8DrawChariii+0xc4>
    if (i < 0 || i >= FNT(4)) return 0;

    int ci = 6 + i * 2;
    int width = (FNT(ci) << 8) | FNT(ci + 1);   // simplify
    int height = FNT(1);
    int src = 0;
     6cc:	40 e0       	ldi	r20, 0x00	; 0
     6ce:	50 e0       	ldi	r21, 0x00	; 0
        src = (FNT(ci - 2) << 8) | FNT(ci - 1);
        width -= src;
    }
    
    //  clip?
    src += (6 + 2 * FNT(4)) * 8;    // start of pixels (roll into cols) 
     6d0:	fd 01       	movw	r30, r26
     6d2:	84 91       	lpm	r24, Z
     6d4:	90 e0       	ldi	r25, 0x00	; 0
     6d6:	03 96       	adiw	r24, 0x03	; 3
     6d8:	82 95       	swap	r24
     6da:	92 95       	swap	r25
     6dc:	90 7f       	andi	r25, 0xF0	; 240
     6de:	98 27       	eor	r25, r24
     6e0:	80 7f       	andi	r24, 0xF0	; 240
     6e2:	98 27       	eor	r25, r24
     6e4:	48 0f       	add	r20, r24
     6e6:	59 1f       	adc	r21, r25
    byte mask = 0x80 >> (src & 7);  // Mask at start of line
     6e8:	9a 01       	movw	r18, r20
     6ea:	27 70       	andi	r18, 0x07	; 7
     6ec:	30 70       	andi	r19, 0x00	; 0
     6ee:	80 e8       	ldi	r24, 0x80	; 128
     6f0:	90 e0       	ldi	r25, 0x00	; 0
     6f2:	02 c0       	rjmp	.+4      	; 0x6f8 <_Z8DrawChariii+0xec>
     6f4:	95 95       	asr	r25
     6f6:	87 95       	ror	r24
     6f8:	2a 95       	dec	r18
     6fa:	e2 f7       	brpl	.-8      	; 0x6f4 <_Z8DrawChariii+0xe8>
     6fc:	a8 2f       	mov	r26, r24
    int end = (src+width) >> 3;     // number of bytes read
    src >>= 3;
     6fe:	9a 01       	movw	r18, r20
     700:	35 95       	asr	r19
     702:	27 95       	ror	r18
     704:	35 95       	asr	r19
     706:	27 95       	ror	r18
     708:	35 95       	asr	r19
     70a:	27 95       	ror	r18
    int makeup = FNT(5) - (end + 1 - src);
     70c:	e1 e8       	ldi	r30, 0x81	; 129
     70e:	f0 e0       	ldi	r31, 0x00	; 0
     710:	e4 91       	lpm	r30, Z
    }
    
    //  clip?
    src += (6 + 2 * FNT(4)) * 8;    // start of pixels (roll into cols) 
    byte mask = 0x80 >> (src & 7);  // Mask at start of line
    int end = (src+width) >> 3;     // number of bytes read
     712:	ca 01       	movw	r24, r20
     714:	86 0d       	add	r24, r6
     716:	97 1d       	adc	r25, r7
     718:	95 95       	asr	r25
     71a:	87 95       	ror	r24
     71c:	95 95       	asr	r25
     71e:	87 95       	ror	r24
     720:	95 95       	asr	r25
     722:	87 95       	ror	r24
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
     724:	80 95       	com	r24
     726:	90 95       	com	r25
     728:	82 0f       	add	r24, r18
     72a:	93 1f       	adc	r25, r19
     72c:	1c 01       	movw	r2, r24
     72e:	2e 0e       	add	r2, r30
     730:	31 1c       	adc	r3, r1
    for (byte y = 0; y < (byte)height; y++)
     732:	f9 81       	ldd	r31, Y+1	; 0x01
     734:	ff 23       	and	r31, r31
     736:	09 f4       	brne	.+2      	; 0x73a <_Z8DrawChariii+0x12e>
     738:	51 c0       	rjmp	.+162    	; 0x7dc <_Z8DrawChariii+0x1d0>
     73a:	a6 2e       	mov	r10, r22
     73c:	b7 2e       	mov	r11, r23
     73e:	88 24       	eor	r8, r8
    {
        byte p = FNT(src++);
        byte m = mask;
        for (byte x = 0; x < (byte)width; x++)
     740:	d6 2c       	mov	r13, r6
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
    {
        byte p = FNT(src++);
        byte m = mask;
     742:	aa 83       	std	Y+2, r26	; 0x02
            if (m == 0)
            {
                p = FNT(src++);
                if (p == 0 && (width-x) <= 8)   // early out
                    break;
                m = 0x80;
     744:	0f 2e       	mov	r0, r31
     746:	f0 e8       	ldi	r31, 0x80	; 128
     748:	cf 2e       	mov	r12, r31
     74a:	f0 2d       	mov	r31, r0
            if (p & m)
                Graphics::PutPixel(x + xx, y + yy);
            m >>= 1;
            if (m == 0)
            {
                p = FNT(src++);
     74c:	99 24       	eor	r9, r9
    int end = (src+width) >> 3;     // number of bytes read
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
    {
        byte p = FNT(src++);
     74e:	79 01       	movw	r14, r18
     750:	08 94       	sec
     752:	e1 1c       	adc	r14, r1
     754:	f1 1c       	adc	r15, r1
     756:	f9 01       	movw	r30, r18
     758:	e4 58       	subi	r30, 0x84	; 132
     75a:	ff 4f       	sbci	r31, 0xFF	; 255
     75c:	e4 91       	lpm	r30, Z
        byte m = mask;
        for (byte x = 0; x < (byte)width; x++)
     75e:	dd 20       	and	r13, r13
     760:	61 f1       	breq	.+88     	; 0x7ba <_Z8DrawChariii+0x1ae>
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
    {
        byte p = FNT(src++);
        byte m = mask;
     762:	8a 81       	ldd	r24, Y+2	; 0x02
     764:	8b 83       	std	Y+3, r24	; 0x03
    int end = (src+width) >> 3;     // number of bytes read
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
    {
        byte p = FNT(src++);
     766:	ec 83       	std	Y+4, r30	; 0x04
        byte m = mask;
        for (byte x = 0; x < (byte)width; x++)
     768:	00 e0       	ldi	r16, 0x00	; 0
     76a:	10 e0       	ldi	r17, 0x00	; 0
        {
            if (p & m)
     76c:	8b 81       	ldd	r24, Y+3	; 0x03
     76e:	9c 81       	ldd	r25, Y+4	; 0x04
     770:	89 23       	and	r24, r25
     772:	31 f0       	breq	.+12     	; 0x780 <_Z8DrawChariii+0x174>
                Graphics::PutPixel(x + xx, y + yy);
     774:	c8 01       	movw	r24, r16
     776:	84 0d       	add	r24, r4
     778:	95 1d       	adc	r25, r5
     77a:	b5 01       	movw	r22, r10
     77c:	0e 94 c6 02 	call	0x58c	; 0x58c <_ZN8Graphics8PutPixelEtt>
            m >>= 1;
     780:	eb 81       	ldd	r30, Y+3	; 0x03
     782:	e6 95       	lsr	r30
     784:	eb 83       	std	Y+3, r30	; 0x03
            if (m == 0)
     786:	ee 23       	and	r30, r30
     788:	a1 f4       	brne	.+40     	; 0x7b2 <_Z8DrawChariii+0x1a6>
            {
                p = FNT(src++);
     78a:	f7 01       	movw	r30, r14
     78c:	e4 58       	subi	r30, 0x84	; 132
     78e:	ff 4f       	sbci	r31, 0xFF	; 255
     790:	08 94       	sec
     792:	e1 1c       	adc	r14, r1
     794:	f1 1c       	adc	r15, r1
     796:	e4 91       	lpm	r30, Z
                if (p == 0 && (width-x) <= 8)   // early out
     798:	ee 23       	and	r30, r30
     79a:	49 f4       	brne	.+18     	; 0x7ae <_Z8DrawChariii+0x1a2>
#define FNT(_x) pgm_read_byte(Verdana_font_11 + (_x))
#else
#define FNT(_x) Verdana_font_11[_x]
#endif

int DrawChar(int xx, int yy, int c)
     79c:	c3 01       	movw	r24, r6
     79e:	80 1b       	sub	r24, r16
     7a0:	91 0b       	sbc	r25, r17
                Graphics::PutPixel(x + xx, y + yy);
            m >>= 1;
            if (m == 0)
            {
                p = FNT(src++);
                if (p == 0 && (width-x) <= 8)   // early out
     7a2:	89 30       	cpi	r24, 0x09	; 9
     7a4:	91 05       	cpc	r25, r1
     7a6:	4c f0       	brlt	.+18     	; 0x7ba <_Z8DrawChariii+0x1ae>
                    break;
                m = 0x80;
     7a8:	cb 82       	std	Y+3, r12	; 0x03
            if (p & m)
                Graphics::PutPixel(x + xx, y + yy);
            m >>= 1;
            if (m == 0)
            {
                p = FNT(src++);
     7aa:	9c 82       	std	Y+4, r9	; 0x04
     7ac:	02 c0       	rjmp	.+4      	; 0x7b2 <_Z8DrawChariii+0x1a6>
     7ae:	ec 83       	std	Y+4, r30	; 0x04
                if (p == 0 && (width-x) <= 8)   // early out
                    break;
                m = 0x80;
     7b0:	cb 82       	std	Y+3, r12	; 0x03
                Graphics::PutPixel(x + xx, y + yy);
            m >>= 1;
            if (m == 0)
            {
                p = FNT(src++);
                if (p == 0 && (width-x) <= 8)   // early out
     7b2:	0f 5f       	subi	r16, 0xFF	; 255
     7b4:	1f 4f       	sbci	r17, 0xFF	; 255
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
    {
        byte p = FNT(src++);
        byte m = mask;
        for (byte x = 0; x < (byte)width; x++)
     7b6:	0d 15       	cp	r16, r13
     7b8:	c8 f2       	brcs	.-78     	; 0x76c <_Z8DrawChariii+0x160>
                if (p == 0 && (width-x) <= 8)   // early out
                    break;
                m = 0x80;
            }
        }
        src += makeup;
     7ba:	97 01       	movw	r18, r14
     7bc:	22 0d       	add	r18, r2
     7be:	33 1d       	adc	r19, r3
    src += (6 + 2 * FNT(4)) * 8;    // start of pixels (roll into cols) 
    byte mask = 0x80 >> (src & 7);  // Mask at start of line
    int end = (src+width) >> 3;     // number of bytes read
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
     7c0:	83 94       	inc	r8
     7c2:	08 94       	sec
     7c4:	a1 1c       	adc	r10, r1
     7c6:	b1 1c       	adc	r11, r1
     7c8:	f9 81       	ldd	r31, Y+1	; 0x01
     7ca:	8f 16       	cp	r8, r31
     7cc:	09 f0       	breq	.+2      	; 0x7d0 <_Z8DrawChariii+0x1c4>
     7ce:	bf cf       	rjmp	.-130    	; 0x74e <_Z8DrawChariii+0x142>
     7d0:	05 c0       	rjmp	.+10     	; 0x7dc <_Z8DrawChariii+0x1d0>
    //byte* f = Verdana_font_11;
    if (c == 32)
        return FNT(1)>>2;  // Space is 1/4 font height (yuk);

    int i = c - FNT(3);
    if (i < 0 || i >= FNT(4)) return 0;
     7d2:	66 24       	eor	r6, r6
     7d4:	77 24       	eor	r7, r7
     7d6:	02 c0       	rjmp	.+4      	; 0x7dc <_Z8DrawChariii+0x1d0>
     7d8:	66 24       	eor	r6, r6
     7da:	77 24       	eor	r7, r7
            }
        }
        src += makeup;
    }
    return width;
}
     7dc:	86 2d       	mov	r24, r6
     7de:	97 2d       	mov	r25, r7
     7e0:	0f 90       	pop	r0
     7e2:	0f 90       	pop	r0
     7e4:	0f 90       	pop	r0
     7e6:	0f 90       	pop	r0
     7e8:	df 91       	pop	r29
     7ea:	cf 91       	pop	r28
     7ec:	1f 91       	pop	r17
     7ee:	0f 91       	pop	r16
     7f0:	ff 90       	pop	r15
     7f2:	ef 90       	pop	r14
     7f4:	df 90       	pop	r13
     7f6:	cf 90       	pop	r12
     7f8:	bf 90       	pop	r11
     7fa:	af 90       	pop	r10
     7fc:	9f 90       	pop	r9
     7fe:	8f 90       	pop	r8
     800:	7f 90       	pop	r7
     802:	6f 90       	pop	r6
     804:	5f 90       	pop	r5
     806:	4f 90       	pop	r4
     808:	3f 90       	pop	r3
     80a:	2f 90       	pop	r2
     80c:	08 95       	ret

0000080e <_ZN8Graphics10DrawStringEPKciii>:

void Graphics::DrawString(const char* s, int len, int x, int y)
{
     80e:	af 92       	push	r10
     810:	bf 92       	push	r11
     812:	cf 92       	push	r12
     814:	df 92       	push	r13
     816:	ef 92       	push	r14
     818:	ff 92       	push	r15
     81a:	0f 93       	push	r16
     81c:	1f 93       	push	r17
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	08 2f       	mov	r16, r24
     824:	19 2f       	mov	r17, r25
     826:	6b 01       	movw	r12, r22
     828:	ea 01       	movw	r28, r20
     82a:	59 01       	movw	r10, r18
    BeginPixels();
     82c:	0e 94 b9 02 	call	0x572	; 0x572 <_ZN8Graphics11BeginPixelsEv>
    for (int i = 0; i < len; i++)
     830:	1c 14       	cp	r1, r12
     832:	1d 04       	cpc	r1, r13
     834:	a4 f4       	brge	.+40     	; 0x85e <_ZN8Graphics10DrawStringEPKciii+0x50>
     836:	e0 2e       	mov	r14, r16
     838:	f1 2e       	mov	r15, r17
     83a:	00 e0       	ldi	r16, 0x00	; 0
     83c:	10 e0       	ldi	r17, 0x00	; 0
        x += DrawChar(x,y,s[i]) + 1;
     83e:	f7 01       	movw	r30, r14
     840:	41 91       	ld	r20, Z+
     842:	7f 01       	movw	r14, r30
     844:	ce 01       	movw	r24, r28
     846:	b5 01       	movw	r22, r10
     848:	50 e0       	ldi	r21, 0x00	; 0
     84a:	0e 94 06 03 	call	0x60c	; 0x60c <_Z8DrawChariii>
     84e:	01 96       	adiw	r24, 0x01	; 1
     850:	c8 0f       	add	r28, r24
     852:	d9 1f       	adc	r29, r25
}

void Graphics::DrawString(const char* s, int len, int x, int y)
{
    BeginPixels();
    for (int i = 0; i < len; i++)
     854:	0f 5f       	subi	r16, 0xFF	; 255
     856:	1f 4f       	sbci	r17, 0xFF	; 255
     858:	0c 15       	cp	r16, r12
     85a:	1d 05       	cpc	r17, r13
     85c:	81 f7       	brne	.-32     	; 0x83e <_ZN8Graphics10DrawStringEPKciii+0x30>
        x += DrawChar(x,y,s[i]) + 1;
}
     85e:	df 91       	pop	r29
     860:	cf 91       	pop	r28
     862:	1f 91       	pop	r17
     864:	0f 91       	pop	r16
     866:	ff 90       	pop	r15
     868:	ef 90       	pop	r14
     86a:	df 90       	pop	r13
     86c:	cf 90       	pop	r12
     86e:	bf 90       	pop	r11
     870:	af 90       	pop	r10
     872:	08 95       	ret

00000874 <_ZN8Graphics10DrawStringEPKcii>:

void Graphics::DrawString(const char* s, int x, int y)
{
     874:	cf 93       	push	r28
     876:	df 93       	push	r29
     878:	9b 01       	movw	r18, r22
     87a:	ea 01       	movw	r28, r20
    DrawString(s,strlen(s),x,y);
     87c:	e8 2f       	mov	r30, r24
     87e:	f9 2f       	mov	r31, r25
     880:	df 01       	movw	r26, r30
     882:	0d 90       	ld	r0, X+
     884:	00 20       	and	r0, r0
     886:	e9 f7       	brne	.-6      	; 0x882 <_ZN8Graphics10DrawStringEPKcii+0xe>
     888:	11 97       	sbiw	r26, 0x01	; 1
     88a:	bd 01       	movw	r22, r26
     88c:	6e 1b       	sub	r22, r30
     88e:	7f 0b       	sbc	r23, r31
     890:	a9 01       	movw	r20, r18
     892:	9e 01       	movw	r18, r28
     894:	0e 94 07 04 	call	0x80e	; 0x80e <_ZN8Graphics10DrawStringEPKciii>
}
     898:	df 91       	pop	r29
     89a:	cf 91       	pop	r28
     89c:	08 95       	ret

0000089e <_Z3cmpPKhPKc>:
     }
 }
	    
*/
bool cmp(const byte* d, const char* s)
{
     89e:	fc 01       	movw	r30, r24
    while (*s)
        if (*d++ != *s++)
            return false;
    return true;
     8a0:	a6 2f       	mov	r26, r22
     8a2:	b7 2f       	mov	r27, r23
 }
	    
*/
bool cmp(const byte* d, const char* s)
{
    while (*s)
     8a4:	03 c0       	rjmp	.+6      	; 0x8ac <_Z3cmpPKhPKc+0xe>
        if (*d++ != *s++)
     8a6:	91 91       	ld	r25, Z+
     8a8:	89 17       	cp	r24, r25
     8aa:	29 f4       	brne	.+10     	; 0x8b6 <_Z3cmpPKhPKc+0x18>
 }
	    
*/
bool cmp(const byte* d, const char* s)
{
    while (*s)
     8ac:	8d 91       	ld	r24, X+
     8ae:	88 23       	and	r24, r24
     8b0:	d1 f7       	brne	.-12     	; 0x8a6 <_Z3cmpPKhPKc+0x8>
        if (*d++ != *s++)
            return false;
    return true;
     8b2:	81 e0       	ldi	r24, 0x01	; 1
     8b4:	08 95       	ret
*/
bool cmp(const byte* d, const char* s)
{
    while (*s)
        if (*d++ != *s++)
            return false;
     8b6:	80 e0       	ldi	r24, 0x00	; 0
    return true;
}
     8b8:	08 95       	ret

000008ba <_Z5Draw8hPt>:
        }
    }
}
*/
void Draw8(byte c, ushort* color)
{
     8ba:	1f 93       	push	r17
     8bc:	cf 93       	push	r28
     8be:	df 93       	push	r29
     8c0:	eb 01       	movw	r28, r22
    if (c == 0 || c == 0xFF)
     8c2:	98 2f       	mov	r25, r24
     8c4:	91 50       	subi	r25, 0x01	; 1
     8c6:	9e 3f       	cpi	r25, 0xFE	; 254
     8c8:	90 f0       	brcs	.+36     	; 0x8ee <_Z5Draw8hPt+0x34>
    {
        LCD::SetColor(color[c == 0 ? 0 : 1]);
     8ca:	88 23       	and	r24, r24
     8cc:	19 f0       	breq	.+6      	; 0x8d4 <_Z5Draw8hPt+0x1a>
     8ce:	82 e0       	ldi	r24, 0x02	; 2
     8d0:	90 e0       	ldi	r25, 0x00	; 0
     8d2:	02 c0       	rjmp	.+4      	; 0x8d8 <_Z5Draw8hPt+0x1e>
     8d4:	80 e0       	ldi	r24, 0x00	; 0
     8d6:	90 e0       	ldi	r25, 0x00	; 0
     8d8:	c8 0f       	add	r28, r24
     8da:	d9 1f       	adc	r29, r25
     8dc:	88 81       	ld	r24, Y
     8de:	99 81       	ldd	r25, Y+1	; 0x01
     8e0:	0e 94 42 06 	call	0xc84	; 0xc84 <_ZN3LCD8SetColorEt>
        LCD::SolidFill(8);
     8e4:	88 e0       	ldi	r24, 0x08	; 8
     8e6:	90 e0       	ldi	r25, 0x00	; 0
     8e8:	0e 94 37 07 	call	0xe6e	; 0xe6e <_ZN3LCD9SolidFillEt>
        return;
     8ec:	0b c0       	rjmp	.+22     	; 0x904 <_Z5Draw8hPt+0x4a>
    }
}
*/
void Draw8(byte c, ushort* color)
{
    if (c == 0 || c == 0xFF)
     8ee:	18 e0       	ldi	r17, 0x08	; 8
        return;
    }
    char s = c;
    for (byte i = 0; i < 8; i++)
    {
        LCD::SetColor(color[s < 0 ? 1 : 0]);
     8f0:	88 81       	ld	r24, Y
     8f2:	99 81       	ldd	r25, Y+1	; 0x01
     8f4:	0e 94 42 06 	call	0xc84	; 0xc84 <_ZN3LCD8SetColorEt>
        LCD::SolidFill(1);
     8f8:	81 e0       	ldi	r24, 0x01	; 1
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	0e 94 37 07 	call	0xe6e	; 0xe6e <_ZN3LCD9SolidFillEt>
     900:	11 50       	subi	r17, 0x01	; 1
        LCD::SetColor(color[c == 0 ? 0 : 1]);
        LCD::SolidFill(8);
        return;
    }
    char s = c;
    for (byte i = 0; i < 8; i++)
     902:	b1 f7       	brne	.-20     	; 0x8f0 <_Z5Draw8hPt+0x36>
    {
        LCD::SetColor(color[s < 0 ? 1 : 0]);
        LCD::SolidFill(1);
        s <<= 1;
    }
}
     904:	df 91       	pop	r29
     906:	cf 91       	pop	r28
     908:	1f 91       	pop	r17
     90a:	08 95       	ret

0000090c <_ZN8Graphics9Draw8x8x1EiiPKhPt>:

void Graphics::Draw8x8x1(int x, int y, const byte* t, ushort* color)
{
     90c:	cf 92       	push	r12
     90e:	df 92       	push	r13
     910:	ef 92       	push	r14
     912:	ff 92       	push	r15
     914:	0f 93       	push	r16
     916:	1f 93       	push	r17
     918:	cf 93       	push	r28
     91a:	df 93       	push	r29
     91c:	8c 01       	movw	r16, r24
     91e:	6b 01       	movw	r12, r22
     920:	ea 01       	movw	r28, r20
     922:	79 01       	movw	r14, r18
    LCD::SetWrap(x,y,8,8);
     924:	48 e0       	ldi	r20, 0x08	; 8
     926:	50 e0       	ldi	r21, 0x00	; 0
     928:	28 e0       	ldi	r18, 0x08	; 8
     92a:	30 e0       	ldi	r19, 0x00	; 0
     92c:	0e 94 08 06 	call	0xc10	; 0xc10 <_ZN3LCD7SetWrapEiiii>
    LCD::SetGRAM(x,y);
     930:	c8 01       	movw	r24, r16
     932:	b6 01       	movw	r22, r12
     934:	0e 94 34 06 	call	0xc68	; 0xc68 <_ZN3LCD7SetGRAMEii>
        LCD::SolidFill(1);
        s <<= 1;
    }
}

void Graphics::Draw8x8x1(int x, int y, const byte* t, ushort* color)
     938:	8e 01       	movw	r16, r28
     93a:	08 5f       	subi	r16, 0xF8	; 248
     93c:	1f 4f       	sbci	r17, 0xFF	; 255
{
    LCD::SetWrap(x,y,8,8);
    LCD::SetGRAM(x,y);
    for (int i = 0; i < 8; i++)
        Draw8(*t++,color);
     93e:	89 91       	ld	r24, Y+
     940:	b7 01       	movw	r22, r14
     942:	0e 94 5d 04 	call	0x8ba	; 0x8ba <_Z5Draw8hPt>

void Graphics::Draw8x8x1(int x, int y, const byte* t, ushort* color)
{
    LCD::SetWrap(x,y,8,8);
    LCD::SetGRAM(x,y);
    for (int i = 0; i < 8; i++)
     946:	c0 17       	cp	r28, r16
     948:	d1 07       	cpc	r29, r17
     94a:	c9 f7       	brne	.-14     	; 0x93e <_ZN8Graphics9Draw8x8x1EiiPKhPt+0x32>
        Draw8(*t++,color);
}
     94c:	df 91       	pop	r29
     94e:	cf 91       	pop	r28
     950:	1f 91       	pop	r17
     952:	0f 91       	pop	r16
     954:	ff 90       	pop	r15
     956:	ef 90       	pop	r14
     958:	df 90       	pop	r13
     95a:	cf 90       	pop	r12
     95c:	08 95       	ret

0000095e <_ZN8Graphics9Draw8x8x8EiiPKhPt>:

void Graphics::Draw8x8x8(int x, int y, const byte* t, ushort* color)
{
}
     95e:	08 95       	ret

00000960 <_Z10init_portsv>:

void init_ports()
{
	/* Disable JTAG in software, so that it does not interfere with Port C  */
	/* It will be re-enabled after a power cycle if the JTAGEN fuse is set. */
	MCUCR |=(1<<JTD);
     960:	85 b7       	in	r24, 0x35	; 53
     962:	80 68       	ori	r24, 0x80	; 128
     964:	85 bf       	out	0x35, r24	; 53
	MCUCR |=(1<<JTD);
     966:	85 b7       	in	r24, 0x35	; 53
     968:	80 68       	ori	r24, 0x80	; 128
     96a:	85 bf       	out	0x35, r24	; 53
	
	CTRL_DDR = 0x7F;
     96c:	8f e7       	ldi	r24, 0x7F	; 127
     96e:	8a b9       	out	0x0a, r24	; 10
	DATA_DDR = 0xFF;
     970:	8f ef       	ldi	r24, 0xFF	; 255
     972:	84 b9       	out	0x04, r24	; 4
}
     974:	08 95       	ret

00000976 <_Z8delay_msj>:

void delay_ms(uint16_t m)
{
	uint16_t i;
	for(i=0; i<m; i++)
     976:	00 97       	sbiw	r24, 0x00	; 0
     978:	69 f0       	breq	.+26     	; 0x994 <_Z8delay_msj+0x1e>
     97a:	20 e0       	ldi	r18, 0x00	; 0
     97c:	30 e0       	ldi	r19, 0x00	; 0
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     97e:	e9 ef       	ldi	r30, 0xF9	; 249
     980:	f0 e0       	ldi	r31, 0x00	; 0
     982:	31 97       	sbiw	r30, 0x01	; 1
     984:	f1 f7       	brne	.-4      	; 0x982 <_Z8delay_msj+0xc>
     986:	00 c0       	rjmp	.+0      	; 0x988 <_Z8delay_msj+0x12>
     988:	00 00       	nop
     98a:	2f 5f       	subi	r18, 0xFF	; 255
     98c:	3f 4f       	sbci	r19, 0xFF	; 255
     98e:	28 17       	cp	r18, r24
     990:	39 07       	cpc	r19, r25
     992:	a9 f7       	brne	.-22     	; 0x97e <_Z8delay_msj+0x8>
     994:	08 95       	ret

00000996 <_ZN3LCD4InitEv>:
}

void LCD::Init()
{
	uint16_t x, y;
	init_ports();
     996:	0e 94 b0 04 	call	0x960	; 0x960 <_Z10init_portsv>
	RESET_lo();
     99a:	5a 98       	cbi	0x0b, 2	; 11
	delay_ms(100);
     99c:	84 e6       	ldi	r24, 0x64	; 100
     99e:	90 e0       	ldi	r25, 0x00	; 0
     9a0:	0e 94 bb 04 	call	0x976	; 0x976 <_Z8delay_msj>
	RESET_hi();
     9a4:	5a 9a       	sbi	0x0b, 2	; 11
	delay_ms(100);
     9a6:	84 e6       	ldi	r24, 0x64	; 100
     9a8:	90 e0       	ldi	r25, 0x00	; 0
     9aa:	0e 94 bb 04 	call	0x976	; 0x976 <_Z8delay_msj>
	RS_hi();
     9ae:	5c 9a       	sbi	0x0b, 4	; 11
	WR_hi();
     9b0:	5b 9a       	sbi	0x0b, 3	; 11
	RD_hi(); 
     9b2:	5d 9a       	sbi	0x0b, 5	; 11
	CS_lo();
     9b4:	58 98       	cbi	0x0b, 0	; 11
	BLC_lo();
     9b6:	59 98       	cbi	0x0b, 1	; 11
	VSYNC_hi();
     9b8:	5e 9a       	sbi	0x0b, 6	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     9ba:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     9bc:	88 e2       	ldi	r24, 0x28	; 40
     9be:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     9c0:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     9c2:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     9c4:	5c 9a       	sbi	0x0b, 4	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     9c6:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     9c8:	81 e1       	ldi	r24, 0x11	; 17
     9ca:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     9cc:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     9ce:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     9d0:	5c 9a       	sbi	0x0b, 4	; 11
	CS_lo();
	BLC_lo();
	VSYNC_hi();
	write_cmd(DISPLAY_OFF);
	write_cmd(SLEEP_OUT);
	delay_ms(60);
     9d2:	8c e3       	ldi	r24, 0x3C	; 60
     9d4:	90 e0       	ldi	r25, 0x00	; 0
     9d6:	0e 94 bb 04 	call	0x976	; 0x976 <_Z8delay_msj>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     9da:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     9dc:	8b ec       	ldi	r24, 0xCB	; 203
     9de:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     9e0:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     9e2:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     9e4:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     9e6:	81 e0       	ldi	r24, 0x01	; 1
     9e8:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     9ea:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     9ec:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     9ee:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     9f0:	80 ec       	ldi	r24, 0xC0	; 192
     9f2:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     9f4:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     9f6:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     9f8:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     9fa:	86 e2       	ldi	r24, 0x26	; 38
     9fc:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     9fe:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a00:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     a02:	88 e0       	ldi	r24, 0x08	; 8
     a04:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a06:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a08:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     a0a:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     a0c:	81 ec       	ldi	r24, 0xC1	; 193
     a0e:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a10:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a12:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     a14:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     a16:	80 e1       	ldi	r24, 0x10	; 16
     a18:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a1a:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a1c:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     a1e:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     a20:	85 ec       	ldi	r24, 0xC5	; 197
     a22:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a24:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a26:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     a28:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     a2a:	85 e3       	ldi	r24, 0x35	; 53
     a2c:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a2e:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a30:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     a32:	8e e3       	ldi	r24, 0x3E	; 62
     a34:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a36:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a38:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     a3a:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     a3c:	86 e3       	ldi	r24, 0x36	; 54
     a3e:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a40:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a42:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     a44:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     a46:	80 e4       	ldi	r24, 0x40	; 64
     a48:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a4a:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a4c:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     a4e:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     a50:	80 eb       	ldi	r24, 0xB0	; 176
     a52:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a54:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a56:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     a58:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     a5a:	8a e4       	ldi	r24, 0x4A	; 74
     a5c:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a5e:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a60:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     a62:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     a64:	81 eb       	ldi	r24, 0xB1	; 177
     a66:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a68:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a6a:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     a6c:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     a6e:	15 b8       	out	0x05, r1	; 5
	WR_lo();
     a70:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a72:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     a74:	8b e1       	ldi	r24, 0x1B	; 27
     a76:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a78:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a7a:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     a7c:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     a7e:	86 eb       	ldi	r24, 0xB6	; 182
     a80:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     a82:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a84:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     a86:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     a88:	ee e4       	ldi	r30, 0x4E	; 78
     a8a:	f1 e0       	ldi	r31, 0x01	; 1
     a8c:	cf 01       	movw	r24, r30
     a8e:	04 96       	adiw	r24, 0x04	; 4
__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
     a90:	21 91       	ld	r18, Z+
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     a92:	25 b9       	out	0x05, r18	; 5
	WR_lo();
     a94:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     a96:	5b 9a       	sbi	0x0b, 3	; 11

__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
     a98:	e8 17       	cp	r30, r24
     a9a:	f9 07       	cpc	r31, r25
     a9c:	c9 f7       	brne	.-14     	; 0xa90 <_ZN3LCD4InitEv+0xfa>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     a9e:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     aa0:	87 ec       	ldi	r24, 0xC7	; 199
     aa2:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     aa4:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     aa6:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     aa8:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     aaa:	85 eb       	ldi	r24, 0xB5	; 181
     aac:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     aae:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     ab0:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     ab2:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     ab4:	86 ef       	ldi	r24, 0xF6	; 246
     ab6:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     ab8:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     aba:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     abc:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     abe:	ea e4       	ldi	r30, 0x4A	; 74
     ac0:	f1 e0       	ldi	r31, 0x01	; 1
     ac2:	cf 01       	movw	r24, r30
     ac4:	03 96       	adiw	r24, 0x03	; 3
__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
     ac6:	21 91       	ld	r18, Z+
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     ac8:	25 b9       	out	0x05, r18	; 5
	WR_lo();
     aca:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     acc:	5b 9a       	sbi	0x0b, 3	; 11

__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
     ace:	e8 17       	cp	r30, r24
     ad0:	f9 07       	cpc	r31, r25
     ad2:	c9 f7       	brne	.-14     	; 0xac6 <_ZN3LCD4InitEv+0x130>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     ad4:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     ad6:	82 ef       	ldi	r24, 0xF2	; 242
     ad8:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     ada:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     adc:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     ade:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     ae0:	15 b8       	out	0x05, r1	; 5
	WR_lo();
     ae2:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     ae4:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     ae6:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     ae8:	86 e2       	ldi	r24, 0x26	; 38
     aea:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     aec:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     aee:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     af0:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     af2:	81 e0       	ldi	r24, 0x01	; 1
     af4:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     af6:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     af8:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     afa:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     afc:	8a e3       	ldi	r24, 0x3A	; 58
     afe:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b00:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b02:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     b04:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b06:	85 e5       	ldi	r24, 0x55	; 85
     b08:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b0a:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b0c:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     b0e:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     b10:	80 ee       	ldi	r24, 0xE0	; 224
     b12:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b14:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b16:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     b18:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     b1a:	ea e3       	ldi	r30, 0x3A	; 58
     b1c:	f1 e0       	ldi	r31, 0x01	; 1
     b1e:	cf 01       	movw	r24, r30
     b20:	0f 96       	adiw	r24, 0x0f	; 15
__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
     b22:	21 91       	ld	r18, Z+
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b24:	25 b9       	out	0x05, r18	; 5
	WR_lo();
     b26:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b28:	5b 9a       	sbi	0x0b, 3	; 11

__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
     b2a:	e8 17       	cp	r30, r24
     b2c:	f9 07       	cpc	r31, r25
     b2e:	c9 f7       	brne	.-14     	; 0xb22 <_ZN3LCD4InitEv+0x18c>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     b30:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     b32:	81 ee       	ldi	r24, 0xE1	; 225
     b34:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b36:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b38:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     b3a:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     b3c:	ea e2       	ldi	r30, 0x2A	; 42
     b3e:	f1 e0       	ldi	r31, 0x01	; 1
     b40:	cf 01       	movw	r24, r30
     b42:	0f 96       	adiw	r24, 0x0f	; 15
__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
     b44:	21 91       	ld	r18, Z+
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b46:	25 b9       	out	0x05, r18	; 5
	WR_lo();
     b48:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b4a:	5b 9a       	sbi	0x0b, 3	; 11

__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
     b4c:	e8 17       	cp	r30, r24
     b4e:	f9 07       	cpc	r31, r25
     b50:	c9 f7       	brne	.-14     	; 0xb44 <_ZN3LCD4InitEv+0x1ae>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     b52:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     b54:	8a e2       	ldi	r24, 0x2A	; 42
     b56:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b58:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b5a:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     b5c:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     b5e:	e5 e2       	ldi	r30, 0x25	; 37
     b60:	f1 e0       	ldi	r31, 0x01	; 1
     b62:	cf 01       	movw	r24, r30
     b64:	04 96       	adiw	r24, 0x04	; 4
__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
     b66:	21 91       	ld	r18, Z+
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b68:	25 b9       	out	0x05, r18	; 5
	WR_lo();
     b6a:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b6c:	5b 9a       	sbi	0x0b, 3	; 11

__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
     b6e:	e8 17       	cp	r30, r24
     b70:	f9 07       	cpc	r31, r25
     b72:	c9 f7       	brne	.-14     	; 0xb66 <_ZN3LCD4InitEv+0x1d0>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     b74:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     b76:	8b e2       	ldi	r24, 0x2B	; 43
     b78:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b7a:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b7c:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     b7e:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     b80:	e0 e2       	ldi	r30, 0x20	; 32
     b82:	f1 e0       	ldi	r31, 0x01	; 1
     b84:	cf 01       	movw	r24, r30
     b86:	04 96       	adiw	r24, 0x04	; 4
__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
     b88:	21 91       	ld	r18, Z+
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     b8a:	25 b9       	out	0x05, r18	; 5
	WR_lo();
     b8c:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b8e:	5b 9a       	sbi	0x0b, 3	; 11

__inline__ void write_cmd_data(uint8_t cmd, uint8_t ndata, char* data)
{
	uint8_t i;
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
     b90:	e8 17       	cp	r30, r24
     b92:	f9 07       	cpc	r31, r25
     b94:	c9 f7       	brne	.-14     	; 0xb88 <_ZN3LCD4InitEv+0x1f2>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     b96:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     b98:	84 e3       	ldi	r24, 0x34	; 52
     b9a:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     b9c:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     b9e:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     ba0:	5c 9a       	sbi	0x0b, 4	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     ba2:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     ba4:	84 eb       	ldi	r24, 0xB4	; 180
     ba6:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     ba8:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     baa:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     bac:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     bae:	15 b8       	out	0x05, r1	; 5
	WR_lo();
     bb0:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     bb2:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     bb4:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     bb6:	87 eb       	ldi	r24, 0xB7	; 183
     bb8:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     bba:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     bbc:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     bbe:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     bc0:	87 e0       	ldi	r24, 0x07	; 7
     bc2:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     bc4:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     bc6:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     bc8:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     bca:	8c e2       	ldi	r24, 0x2C	; 44
     bcc:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     bce:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     bd0:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     bd2:	5c 9a       	sbi	0x0b, 4	; 11
     bd4:	20 ef       	ldi	r18, 0xF0	; 240
     bd6:	30 e0       	ldi	r19, 0x00	; 0
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     bd8:	40 e4       	ldi	r20, 0x40	; 64
     bda:	51 e0       	ldi	r21, 0x01	; 1
     bdc:	0b c0       	rjmp	.+22     	; 0xbf4 <_ZN3LCD4InitEv+0x25e>
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     bde:	15 b8       	out	0x05, r1	; 5
	WR_lo();
     be0:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     be2:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     be4:	15 b8       	out	0x05, r1	; 5
	WR_lo();
     be6:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     be8:	5b 9a       	sbi	0x0b, 3	; 11
     bea:	01 97       	sbiw	r24, 0x01	; 1
    write_cmd(TEARING_EFFECT_LINE_OFF);
    write_cmd_data(DISPLAY_INVERSION_CONTROL,	 1, "\x00");
    write_cmd_data(ENTRY_MODE_SET,				 1, "\x07");
	write_cmd(MEMORY_WRITE);
	for(x=0; x<240; x++)
		for(y=0; y<320; y++)
     bec:	c1 f7       	brne	.-16     	; 0xbde <_ZN3LCD4InitEv+0x248>
     bee:	21 50       	subi	r18, 0x01	; 1
     bf0:	30 40       	sbci	r19, 0x00	; 0
    write_cmd_data(PAGE_ADDRESS_SET,			 4, "\x00\x00\x01\x3F");
    write_cmd(TEARING_EFFECT_LINE_OFF);
    write_cmd_data(DISPLAY_INVERSION_CONTROL,	 1, "\x00");
    write_cmd_data(ENTRY_MODE_SET,				 1, "\x07");
	write_cmd(MEMORY_WRITE);
	for(x=0; x<240; x++)
     bf2:	11 f0       	breq	.+4      	; 0xbf8 <_ZN3LCD4InitEv+0x262>
	write_cmd(cmd);
	for(i=0; i<ndata; i++)
		write_data(*data++);
}

void LCD::Init()
     bf4:	ca 01       	movw	r24, r20
     bf6:	f3 cf       	rjmp	.-26     	; 0xbde <_ZN3LCD4InitEv+0x248>

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     bf8:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     bfa:	89 e2       	ldi	r24, 0x29	; 41
     bfc:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     bfe:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c00:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     c02:	5c 9a       	sbi	0x0b, 4	; 11
	write_cmd(MEMORY_WRITE);
	for(x=0; x<240; x++)
		for(y=0; y<320; y++)
			write_data16(0x0000);
	write_cmd(DISPLAY_ON);
	delay_ms(50);
     c04:	82 e3       	ldi	r24, 0x32	; 50
     c06:	90 e0       	ldi	r25, 0x00	; 0
     c08:	0e 94 bb 04 	call	0x976	; 0x976 <_Z8delay_msj>
	BLC_hi();
     c0c:	59 9a       	sbi	0x0b, 1	; 11
};
     c0e:	08 95       	ret

00000c10 <_ZN3LCD7SetWrapEiiii>:

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     c10:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     c12:	ea e2       	ldi	r30, 0x2A	; 42
     c14:	e5 b9       	out	0x05, r30	; 5
	WR_lo();
     c16:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c18:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     c1a:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c1c:	95 b9       	out	0x05, r25	; 5
	WR_lo();
     c1e:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c20:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c22:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     c24:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c26:	5b 9a       	sbi	0x0b, 3	; 11
 //   WriteLcdReg(0x44,((x + width - 1) << 8) | x);   //  Horizontal RAM start and end address
 //   WriteLcdReg(0x45,y);                            //  Vertical RAM start address
 //   WriteLcdReg(0x46,y + height-1);                 //  Vertical RAM end address
	write_cmd(COLUMN_ADDRESS_SET);
	write_data16(x);
	write_data16(x + width-1);
     c28:	84 0f       	add	r24, r20
     c2a:	95 1f       	adc	r25, r21
     c2c:	01 97       	sbiw	r24, 0x01	; 1
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c2e:	95 b9       	out	0x05, r25	; 5
	WR_lo();
     c30:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c32:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c34:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     c36:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c38:	5b 9a       	sbi	0x0b, 3	; 11

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     c3a:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     c3c:	8b e2       	ldi	r24, 0x2B	; 43
     c3e:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     c40:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c42:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     c44:	5c 9a       	sbi	0x0b, 4	; 11
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c46:	75 b9       	out	0x05, r23	; 5
	WR_lo();
     c48:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c4a:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c4c:	65 b9       	out	0x05, r22	; 5
	WR_lo();
     c4e:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c50:	5b 9a       	sbi	0x0b, 3	; 11
	write_cmd(COLUMN_ADDRESS_SET);
	write_data16(x);
	write_data16(x + width-1);
	write_cmd(PAGE_ADDRESS_SET);
	write_data16(y);
	write_data16(y + height-1);
     c52:	62 0f       	add	r22, r18
     c54:	73 1f       	adc	r23, r19
     c56:	61 50       	subi	r22, 0x01	; 1
     c58:	70 40       	sbci	r23, 0x00	; 0
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c5a:	75 b9       	out	0x05, r23	; 5
	WR_lo();
     c5c:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c5e:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
}

__inline__ void write_data(uint8_t data)
{
   	WRITE(data);                                
     c60:	65 b9       	out	0x05, r22	; 5
	WR_lo();
     c62:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c64:	5b 9a       	sbi	0x0b, 3	; 11
	write_data16(x);
	write_data16(x + width-1);
	write_cmd(PAGE_ADDRESS_SET);
	write_data16(y);
	write_data16(y + height-1);
}
     c66:	08 95       	ret

00000c68 <_ZN3LCD7SetGRAMEii>:

#include "avrlcd.h"

__inline__ void write_cmd(uint8_t cmd)
{
	RS_lo();
     c68:	5c 98       	cbi	0x0b, 4	; 11
	WRITE(cmd);
     c6a:	8c e2       	ldi	r24, 0x2C	; 44
     c6c:	85 b9       	out	0x05, r24	; 5
	WR_lo();
     c6e:	5b 98       	cbi	0x0b, 3	; 11
	WR_hi();
     c70:	5b 9a       	sbi	0x0b, 3	; 11
	RS_hi(); 
     c72:	5c 9a       	sbi	0x0b, 4	; 11
{
//      WriteLcdReg(LCD_GRAM_HOR_AD,x);  //  GDDRAM X
//      WriteLcdReg(LCD_GRAM_VER_AD,y);  //  GDDRAM Y
//      WriteLcdRegAddress(LCD_RW_GRAM);
	write_cmd(MEMORY_WRITE);
}
     c74:	08 95       	ret

00000c76 <_ZN3LCD14HardwareScrollEi>:
/*    while (y < 0)
        y += 320;
    while (y >= 320)
        y -= 320;
    WriteLcdReg(0x41,y); */
}
     c76:	08 95       	ret

00000c78 <_ZN3LCD8GetWidthEv>:
}
*/
ushort LCD::GetWidth()
{
    return 240;
}
     c78:	80 ef       	ldi	r24, 0xF0	; 240
     c7a:	90 e0       	ldi	r25, 0x00	; 0
     c7c:	08 95       	ret

00000c7e <_ZN3LCD9GetHeightEv>:

ushort LCD::GetHeight()
{
    return 320;
}
     c7e:	80 e4       	ldi	r24, 0x40	; 64
     c80:	91 e0       	ldi	r25, 0x01	; 1
     c82:	08 95       	ret

00000c84 <_ZN3LCD8SetColorEt>:

void LCD::SetColor(ushort color)
{
    _color = color;
     c84:	90 93 a9 02 	sts	0x02A9, r25
     c88:	80 93 a8 02 	sts	0x02A8, r24
}
     c8c:	08 95       	ret

00000c8e <_ZN3LCD8OpenWrapEv>:
{
    Blit(count, _color >> 8, _color);
}

void LCD::OpenWrap()
{
     c8e:	cf 93       	push	r28
     c90:	df 93       	push	r29
    SetWrap(0,0,GetWidth(),GetHeight());
     c92:	0e 94 3c 06 	call	0xc78	; 0xc78 <_ZN3LCD8GetWidthEv>
     c96:	ec 01       	movw	r28, r24
     c98:	0e 94 3f 06 	call	0xc7e	; 0xc7e <_ZN3LCD9GetHeightEv>
     c9c:	9c 01       	movw	r18, r24
     c9e:	80 e0       	ldi	r24, 0x00	; 0
     ca0:	90 e0       	ldi	r25, 0x00	; 0
     ca2:	60 e0       	ldi	r22, 0x00	; 0
     ca4:	70 e0       	ldi	r23, 0x00	; 0
     ca6:	ae 01       	movw	r20, r28
     ca8:	0e 94 08 06 	call	0xc10	; 0xc10 <_ZN3LCD7SetWrapEiiii>
}
     cac:	df 91       	pop	r29
     cae:	cf 91       	pop	r28
     cb0:	08 95       	ret

00000cb2 <_ZN3LCD6PixelsEiPKh>:

void LCD::Pixels(int count, const byte* d)
{
     cb2:	fb 01       	movw	r30, r22
    DATAOUT;
     cb4:	2f ef       	ldi	r18, 0xFF	; 255
     cb6:	24 b9       	out	0x04, r18	; 4
    byte w1 = CONTROLPORT;
     cb8:	42 b1       	in	r20, 0x02	; 2
    byte w0 = w1 & ~(1 << WR);
     cba:	54 2f       	mov	r21, r20
     cbc:	57 7f       	andi	r21, 0xF7	; 247

    byte slow = count & 0x03;
     cbe:	28 2f       	mov	r18, r24
     cc0:	23 70       	andi	r18, 0x03	; 3
    if (slow)
     cc2:	b9 f0       	breq	.+46     	; 0xcf2 <_ZN3LCD6PixelsEiPKh+0x40>
     cc4:	32 2f       	mov	r19, r18
     cc6:	db 01       	movw	r26, r22
    {
        do {
        	DATA_PORT = d[0];
     cc8:	6c 91       	ld	r22, X
     cca:	65 b9       	out	0x05, r22	; 5
            CONTROLPORT = w0;
     ccc:	52 b9       	out	0x02, r21	; 2
            CONTROLPORT = w1;
     cce:	42 b9       	out	0x02, r20	; 2
            DATA_PORT = d[1];
     cd0:	11 96       	adiw	r26, 0x01	; 1
     cd2:	6c 91       	ld	r22, X
     cd4:	11 97       	sbiw	r26, 0x01	; 1
     cd6:	65 b9       	out	0x05, r22	; 5
            CONTROLPORT = w0;
     cd8:	52 b9       	out	0x02, r21	; 2
            CONTROLPORT = w1;
     cda:	42 b9       	out	0x02, r20	; 2
            d+=2;
     cdc:	12 96       	adiw	r26, 0x02	; 2
    byte w0 = w1 & ~(1 << WR);

    byte slow = count & 0x03;
    if (slow)
    {
        do {
     cde:	31 50       	subi	r19, 0x01	; 1
     ce0:	99 f7       	brne	.-26     	; 0xcc8 <_ZN3LCD6PixelsEiPKh+0x16>
void LCD::OpenWrap()
{
    SetWrap(0,0,GetWidth(),GetHeight());
}

void LCD::Pixels(int count, const byte* d)
     ce2:	21 50       	subi	r18, 0x01	; 1
     ce4:	30 e0       	ldi	r19, 0x00	; 0
     ce6:	2f 5f       	subi	r18, 0xFF	; 255
     ce8:	3f 4f       	sbci	r19, 0xFF	; 255
     cea:	22 0f       	add	r18, r18
     cec:	33 1f       	adc	r19, r19
    byte w0 = w1 & ~(1 << WR);

    byte slow = count & 0x03;
    if (slow)
    {
        do {
     cee:	e2 0f       	add	r30, r18
     cf0:	f3 1f       	adc	r31, r19
            d+=2;
        } while (--slow);
    }
    
    // x4 unrolled
    count >>= 2;
     cf2:	95 95       	asr	r25
     cf4:	87 95       	ror	r24
     cf6:	95 95       	asr	r25
     cf8:	87 95       	ror	r24
    if (count)
     cfa:	00 97       	sbiw	r24, 0x00	; 0
     cfc:	31 f1       	breq	.+76     	; 0xd4a <_ZN3LCD6PixelsEiPKh+0x98>
    {
        byte w1 = CONTROLPORT;
     cfe:	22 b1       	in	r18, 0x02	; 2
        byte w0 = w1 & ~(1 << WR);
     d00:	32 2f       	mov	r19, r18
     d02:	37 7f       	andi	r19, 0xF7	; 247
        do {
        	DATA_PORT = d[0];
     d04:	40 81       	ld	r20, Z
     d06:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     d08:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     d0a:	22 b9       	out	0x02, r18	; 2
            DATA_PORT = d[1];
     d0c:	41 81       	ldd	r20, Z+1	; 0x01
     d0e:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     d10:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     d12:	22 b9       	out	0x02, r18	; 2
        	DATA_PORT = d[2];
     d14:	42 81       	ldd	r20, Z+2	; 0x02
     d16:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     d18:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     d1a:	22 b9       	out	0x02, r18	; 2
            DATA_PORT = d[3];
     d1c:	43 81       	ldd	r20, Z+3	; 0x03
     d1e:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     d20:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     d22:	22 b9       	out	0x02, r18	; 2
        	DATA_PORT = d[4];
     d24:	44 81       	ldd	r20, Z+4	; 0x04
     d26:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     d28:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     d2a:	22 b9       	out	0x02, r18	; 2
            DATA_PORT = d[5];
     d2c:	45 81       	ldd	r20, Z+5	; 0x05
     d2e:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     d30:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     d32:	22 b9       	out	0x02, r18	; 2
        	DATA_PORT = d[6];
     d34:	46 81       	ldd	r20, Z+6	; 0x06
     d36:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     d38:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     d3a:	22 b9       	out	0x02, r18	; 2
            DATA_PORT = d[7];
     d3c:	47 81       	ldd	r20, Z+7	; 0x07
     d3e:	45 b9       	out	0x05, r20	; 5
            CONTROLPORT = w0;
     d40:	32 b9       	out	0x02, r19	; 2
            CONTROLPORT = w1;
     d42:	22 b9       	out	0x02, r18	; 2
            d += 8;
     d44:	38 96       	adiw	r30, 0x08	; 8
    count >>= 2;
    if (count)
    {
        byte w1 = CONTROLPORT;
        byte w0 = w1 & ~(1 << WR);
        do {
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	e9 f6       	brne	.-70     	; 0xd04 <_ZN3LCD6PixelsEiPKh+0x52>
     d4a:	08 95       	ret

00000d4c <_ZN3LCD13PixelsIndexedEiPKhS1_>:
        } while (--count);
    }
}

void LCD::PixelsIndexed(int count, const byte* d, const byte* palette)
{
     d4c:	ff 92       	push	r15
     d4e:	0f 93       	push	r16
     d50:	1f 93       	push	r17
     d52:	cf 93       	push	r28
     d54:	df 93       	push	r29
     d56:	8c 01       	movw	r16, r24
     d58:	eb 01       	movw	r28, r22
     d5a:	ba 01       	movw	r22, r20
    byte w1 = CONTROLPORT;
     d5c:	22 b1       	in	r18, 0x02	; 2
    byte w0 = w1 & ~(1 << WR);
     d5e:	32 2f       	mov	r19, r18
     d60:	37 7f       	andi	r19, 0xF7	; 247

    // Looks fussy but it attempts to be fast
    while (count)
     d62:	00 97       	sbiw	r24, 0x00	; 0
     d64:	91 f1       	breq	.+100    	; 0xdca <_ZN3LCD13PixelsIndexedEiPKhS1_+0x7e>
    {
        byte c = 255;
     d66:	ff 24       	eor	r15, r15
     d68:	fa 94       	dec	r15
        if (count < c)
            c = count;
        byte p = d[0];
        byte i = 0;
     d6a:	50 e0       	ldi	r21, 0x00	; 0

    // Looks fussy but it attempts to be fast
    while (count)
    {
        byte c = 255;
        if (count < c)
     d6c:	0f 3f       	cpi	r16, 0xFF	; 255
     d6e:	11 05       	cpc	r17, r1
     d70:	14 f4       	brge	.+4      	; 0xd76 <_ZN3LCD13PixelsIndexedEiPKhS1_+0x2a>
            c = count;
     d72:	80 2f       	mov	r24, r16
     d74:	01 c0       	rjmp	.+2      	; 0xd78 <_ZN3LCD13PixelsIndexedEiPKhS1_+0x2c>
    byte w0 = w1 & ~(1 << WR);

    // Looks fussy but it attempts to be fast
    while (count)
    {
        byte c = 255;
     d76:	8f 2d       	mov	r24, r15
        if (count < c)
            c = count;
        byte p = d[0];
     d78:	48 81       	ld	r20, Y
        byte i = 0;
     d7a:	95 2f       	mov	r25, r21
     d7c:	01 c0       	rjmp	.+2      	; 0xd80 <_ZN3LCD13PixelsIndexedEiPKhS1_+0x34>
                CONTROLPORT = w0;
                CONTROLPORT = w1;
                DATA_PORT = b[1];
                CONTROLPORT = w0;
                CONTROLPORT = w1;
                n = d[++i];
     d7e:	4e 2f       	mov	r20, r30
            c = count;
        byte p = d[0];
        byte i = 0;
        do
        {
            const byte* b = palette + p*2;
     d80:	a4 2f       	mov	r26, r20
     d82:	b0 e0       	ldi	r27, 0x00	; 0
     d84:	aa 0f       	add	r26, r26
     d86:	bb 1f       	adc	r27, r27
     d88:	a6 0f       	add	r26, r22
     d8a:	b7 1f       	adc	r27, r23
            byte n;
            do
            {
                DATA_PORT = b[0];
     d8c:	ec 91       	ld	r30, X
     d8e:	e5 b9       	out	0x05, r30	; 5
                CONTROLPORT = w0;
     d90:	32 b9       	out	0x02, r19	; 2
                CONTROLPORT = w1;
     d92:	22 b9       	out	0x02, r18	; 2
                DATA_PORT = b[1];
     d94:	11 96       	adiw	r26, 0x01	; 1
     d96:	ec 91       	ld	r30, X
     d98:	11 97       	sbiw	r26, 0x01	; 1
     d9a:	e5 b9       	out	0x05, r30	; 5
                CONTROLPORT = w0;
     d9c:	32 b9       	out	0x02, r19	; 2
                CONTROLPORT = w1;
     d9e:	22 b9       	out	0x02, r18	; 2
                n = d[++i];
     da0:	9f 5f       	subi	r25, 0xFF	; 255
     da2:	fe 01       	movw	r30, r28
     da4:	e9 0f       	add	r30, r25
     da6:	f1 1d       	adc	r31, r1
     da8:	e0 81       	ld	r30, Z
        byte i = 0;
        do
        {
            const byte* b = palette + p*2;
            byte n;
            do
     daa:	4e 17       	cp	r20, r30
     dac:	59 f4       	brne	.+22     	; 0xdc4 <_ZN3LCD13PixelsIndexedEiPKhS1_+0x78>
     dae:	98 17       	cp	r25, r24
     db0:	68 f3       	brcs	.-38     	; 0xd8c <_ZN3LCD13PixelsIndexedEiPKhS1_+0x40>
                CONTROLPORT = w1;
                n = d[++i];
            } while (p == n && i < c);
            p = n;
        } while (i < c);
        count -= c;
     db2:	90 e0       	ldi	r25, 0x00	; 0
     db4:	08 1b       	sub	r16, r24
     db6:	19 0b       	sbc	r17, r25
        d += c;
     db8:	c8 0f       	add	r28, r24
     dba:	d9 1f       	adc	r29, r25
{
    byte w1 = CONTROLPORT;
    byte w0 = w1 & ~(1 << WR);

    // Looks fussy but it attempts to be fast
    while (count)
     dbc:	01 15       	cp	r16, r1
     dbe:	11 05       	cpc	r17, r1
     dc0:	a9 f6       	brne	.-86     	; 0xd6c <_ZN3LCD13PixelsIndexedEiPKhS1_+0x20>
     dc2:	03 c0       	rjmp	.+6      	; 0xdca <_ZN3LCD13PixelsIndexedEiPKhS1_+0x7e>
        byte c = 255;
        if (count < c)
            c = count;
        byte p = d[0];
        byte i = 0;
        do
     dc4:	98 17       	cp	r25, r24
     dc6:	d8 f2       	brcs	.-74     	; 0xd7e <_ZN3LCD13PixelsIndexedEiPKhS1_+0x32>
     dc8:	f4 cf       	rjmp	.-24     	; 0xdb2 <_ZN3LCD13PixelsIndexedEiPKhS1_+0x66>
            p = n;
        } while (i < c);
        count -= c;
        d += c;
    }
}
     dca:	df 91       	pop	r29
     dcc:	cf 91       	pop	r28
     dce:	1f 91       	pop	r17
     dd0:	0f 91       	pop	r16
     dd2:	ff 90       	pop	r15
     dd4:	08 95       	ret

00000dd6 <_Z4Blitjhh>:
    LCD::SolidFill(count);
}

void Blit(uint16_t count, byte a, byte b)
{
    DATAOUT;
     dd6:	2f ef       	ldi	r18, 0xFF	; 255
     dd8:	24 b9       	out	0x04, r18	; 4
    
    byte slow = count & 0x07;
     dda:	28 2f       	mov	r18, r24
     ddc:	27 70       	andi	r18, 0x07	; 7
    if (slow)
     dde:	41 f0       	breq	.+16     	; 0xdf0 <_Z4Blitjhh+0x1a>
    {
        do {
            DATA_PORT = a;
     de0:	65 b9       	out	0x05, r22	; 5
            WR0;
     de2:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     de4:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     de6:	45 b9       	out	0x05, r20	; 5
            WR0;
     de8:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     dea:	5b 9a       	sbi	0x0b, 3	; 11
    DATAOUT;
    
    byte slow = count & 0x07;
    if (slow)
    {
        do {
     dec:	21 50       	subi	r18, 0x01	; 1
     dee:	c1 f7       	brne	.-16     	; 0xde0 <_Z4Blitjhh+0xa>
            WR1;
        } while (--slow);
    }
    
    // x8 unrolled
    count >>= 3;
     df0:	96 95       	lsr	r25
     df2:	87 95       	ror	r24
     df4:	96 95       	lsr	r25
     df6:	87 95       	ror	r24
     df8:	96 95       	lsr	r25
     dfa:	87 95       	ror	r24
    if (count)
     dfc:	00 97       	sbiw	r24, 0x00	; 0
     dfe:	99 f1       	breq	.+102    	; 0xe66 <_Z4Blitjhh+0x90>
    {
        byte w1 = CONTROLPORT;
     e00:	22 b1       	in	r18, 0x02	; 2
        byte w0 = w1 & ~(1 << WR);
        do {
            DATA_PORT = a;
     e02:	65 b9       	out	0x05, r22	; 5
            WR0;
     e04:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e06:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     e08:	45 b9       	out	0x05, r20	; 5
            WR0;
     e0a:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e0c:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = a;
     e0e:	65 b9       	out	0x05, r22	; 5
            WR0;
     e10:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e12:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     e14:	45 b9       	out	0x05, r20	; 5
            WR0;
     e16:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e18:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = a;
     e1a:	65 b9       	out	0x05, r22	; 5
            WR0;
     e1c:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e1e:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     e20:	45 b9       	out	0x05, r20	; 5
            WR0;
     e22:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e24:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = a;
     e26:	65 b9       	out	0x05, r22	; 5
            WR0;
     e28:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e2a:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     e2c:	45 b9       	out	0x05, r20	; 5
            WR0;
     e2e:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e30:	5b 9a       	sbi	0x0b, 3	; 11

            DATA_PORT = a;
     e32:	65 b9       	out	0x05, r22	; 5
            WR0;
     e34:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e36:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     e38:	45 b9       	out	0x05, r20	; 5
            WR0;
     e3a:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e3c:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = a;
     e3e:	65 b9       	out	0x05, r22	; 5
            WR0;
     e40:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e42:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     e44:	45 b9       	out	0x05, r20	; 5
            WR0;
     e46:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e48:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = a;
     e4a:	65 b9       	out	0x05, r22	; 5
            WR0;
     e4c:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e4e:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     e50:	45 b9       	out	0x05, r20	; 5
            WR0;
     e52:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e54:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = a;
     e56:	65 b9       	out	0x05, r22	; 5
            WR0;
     e58:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e5a:	5b 9a       	sbi	0x0b, 3	; 11
            DATA_PORT = b;
     e5c:	45 b9       	out	0x05, r20	; 5
            WR0;
     e5e:	5b 98       	cbi	0x0b, 3	; 11
            WR1;
     e60:	5b 9a       	sbi	0x0b, 3	; 11
    count >>= 3;
    if (count)
    {
        byte w1 = CONTROLPORT;
        byte w0 = w1 & ~(1 << WR);
        do {
     e62:	01 97       	sbiw	r24, 0x01	; 1
     e64:	71 f6       	brne	.-100    	; 0xe02 <_Z4Blitjhh+0x2c>
     e66:	08 95       	ret

00000e68 <_ZN3LCD6PixelsEihh>:
    }
}

void LCD::Pixels(int count, byte a, byte b)
{
    Blit(count,a,b);
     e68:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <_Z4Blitjhh>
}
     e6c:	08 95       	ret

00000e6e <_ZN3LCD9SolidFillEt>:
    _color = color;
}

void LCD::SolidFill(ushort count)
{
    Blit(count, _color >> 8, _color);
     e6e:	40 91 a8 02 	lds	r20, 0x02A8
     e72:	60 91 a9 02 	lds	r22, 0x02A9
     e76:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <_Z4Blitjhh>
}
     e7a:	08 95       	ret

00000e7c <_ZN3LCD6PixelsEii>:
{
    Blit(count,a,b);
}

void LCD::Pixels(int count, int color)
{
     e7c:	cf 93       	push	r28
     e7e:	df 93       	push	r29
     e80:	ec 01       	movw	r28, r24
     e82:	cb 01       	movw	r24, r22
    LCD::SetColor(color);
     e84:	0e 94 42 06 	call	0xc84	; 0xc84 <_ZN3LCD8SetColorEt>
    LCD::SolidFill(count);
     e88:	ce 01       	movw	r24, r28
     e8a:	0e 94 37 07 	call	0xe6e	; 0xe6e <_ZN3LCD9SolidFillEt>
}
     e8e:	df 91       	pop	r29
     e90:	cf 91       	pop	r28
     e92:	08 95       	ret

00000e94 <_Z13WritePixelPosiiPh>:
    PORTC = d[2];
    CONTROLPORT = w0;
    CONTROLPORT = w1;
    
    CS1;  // deelect chip*/
}
     e94:	08 95       	ret

00000e96 <_Z7InitADCv>:
//====================================================================
//  Touch stuff in LCD

void InitADC()
{
    ADMUX = 1<<REFS0;
     e96:	80 e4       	ldi	r24, 0x40	; 64
     e98:	80 93 7c 00 	sts	0x007C, r24
    ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); //Rrescalar div factor =128
     e9c:	87 e8       	ldi	r24, 0x87	; 135
     e9e:	80 93 7a 00 	sts	0x007A, r24
}
     ea2:	08 95       	ret

00000ea4 <_Z7ReadADChPih>:

void ReadADC(uint8_t ch, int* dst, byte count)
{
     ea4:	ef 92       	push	r14
     ea6:	ff 92       	push	r15
     ea8:	0f 93       	push	r16
     eaa:	1f 93       	push	r17
     eac:	cf 93       	push	r28
     eae:	df 93       	push	r29
     eb0:	db 01       	movw	r26, r22
    //Select ADC Channel ch must be 0-7
    ADMUX &= ~7;
     eb2:	ec e7       	ldi	r30, 0x7C	; 124
     eb4:	f0 e0       	ldi	r31, 0x00	; 0
     eb6:	90 81       	ld	r25, Z
     eb8:	98 7f       	andi	r25, 0xF8	; 248
     eba:	90 83       	st	Z, r25
    ADMUX |= ch & 7;
     ebc:	90 81       	ld	r25, Z
     ebe:	87 70       	andi	r24, 0x07	; 7
     ec0:	98 2b       	or	r25, r24
     ec2:	90 83       	st	Z, r25
    ADCSRA |= 1 << ADEN;
     ec4:	ea e7       	ldi	r30, 0x7A	; 122
     ec6:	f0 e0       	ldi	r31, 0x00	; 0
     ec8:	80 81       	ld	r24, Z
     eca:	80 68       	ori	r24, 0x80	; 128
     ecc:	80 83       	st	Z, r24
    ADCSRA |= 1 << ADSC;
     ece:	80 81       	ld	r24, Z
     ed0:	80 64       	ori	r24, 0x40	; 64
     ed2:	80 83       	st	Z, r24
    while(!(ADCSRA & 0x10));
     ed4:	80 81       	ld	r24, Z
     ed6:	84 ff       	sbrs	r24, 4
     ed8:	fd cf       	rjmp	.-6      	; 0xed4 <_Z7ReadADChPih+0x30>

    for (byte i = 0; i < count; i++)
     eda:	44 23       	and	r20, r20
     edc:	31 f1       	breq	.+76     	; 0xf2a <_Z7ReadADChPih+0x86>
{
    ADMUX = 1<<REFS0;
    ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); //Rrescalar div factor =128
}

void ReadADC(uint8_t ch, int* dst, byte count)
     ede:	cd 01       	movw	r24, r26
     ee0:	02 96       	adiw	r24, 0x02	; 2
     ee2:	41 50       	subi	r20, 0x01	; 1
     ee4:	24 2f       	mov	r18, r20
     ee6:	30 e0       	ldi	r19, 0x00	; 0
     ee8:	22 0f       	add	r18, r18
     eea:	33 1f       	adc	r19, r19
     eec:	28 0f       	add	r18, r24
     eee:	39 1f       	adc	r19, r25
    ADCSRA |= 1 << ADSC;
    while(!(ADCSRA & 0x10));

    for (byte i = 0; i < count; i++)
    {
        ADCSRA |= 1<<ADSC;
     ef0:	ea e7       	ldi	r30, 0x7A	; 122
     ef2:	f0 e0       	ldi	r31, 0x00	; 0
        while(!(ADCSRA & 0x10));
        int v = ADCL;
     ef4:	0f 2e       	mov	r0, r31
     ef6:	f8 e7       	ldi	r31, 0x78	; 120
     ef8:	ef 2e       	mov	r14, r31
     efa:	ff 24       	eor	r15, r15
     efc:	f0 2d       	mov	r31, r0
        v += ADCH << 8;
     efe:	49 e7       	ldi	r20, 0x79	; 121
     f00:	50 e0       	ldi	r21, 0x00	; 0
    ADCSRA |= 1 << ADSC;
    while(!(ADCSRA & 0x10));

    for (byte i = 0; i < count; i++)
    {
        ADCSRA |= 1<<ADSC;
     f02:	80 81       	ld	r24, Z
     f04:	80 64       	ori	r24, 0x40	; 64
     f06:	80 83       	st	Z, r24
        while(!(ADCSRA & 0x10));
     f08:	80 81       	ld	r24, Z
     f0a:	84 ff       	sbrs	r24, 4
     f0c:	fd cf       	rjmp	.-6      	; 0xf08 <_Z7ReadADChPih+0x64>
        int v = ADCL;
     f0e:	e7 01       	movw	r28, r14
     f10:	88 81       	ld	r24, Y
        v += ADCH << 8;
     f12:	ea 01       	movw	r28, r20
     f14:	98 81       	ld	r25, Y
     f16:	19 2f       	mov	r17, r25
     f18:	00 e0       	ldi	r16, 0x00	; 0
     f1a:	b8 01       	movw	r22, r16
     f1c:	68 0f       	add	r22, r24
     f1e:	71 1d       	adc	r23, r1
        *dst++ = v;
     f20:	6d 93       	st	X+, r22
     f22:	7d 93       	st	X+, r23
    ADMUX |= ch & 7;
    ADCSRA |= 1 << ADEN;
    ADCSRA |= 1 << ADSC;
    while(!(ADCSRA & 0x10));

    for (byte i = 0; i < count; i++)
     f24:	a2 17       	cp	r26, r18
     f26:	b3 07       	cpc	r27, r19
     f28:	61 f7       	brne	.-40     	; 0xf02 <_Z7ReadADChPih+0x5e>
        while(!(ADCSRA & 0x10));
        int v = ADCL;
        v += ADCH << 8;
        *dst++ = v;
    }
    ADCSRA &= ~(1 << ADEN);
     f2a:	ea e7       	ldi	r30, 0x7A	; 122
     f2c:	f0 e0       	ldi	r31, 0x00	; 0
     f2e:	80 81       	ld	r24, Z
     f30:	8f 77       	andi	r24, 0x7F	; 127
     f32:	80 83       	st	Z, r24
}
     f34:	df 91       	pop	r29
     f36:	cf 91       	pop	r28
     f38:	1f 91       	pop	r17
     f3a:	0f 91       	pop	r16
     f3c:	ff 90       	pop	r15
     f3e:	ef 90       	pop	r14
     f40:	08 95       	ret

00000f42 <_Z4mappllll>:

int mapp(long v, long a, long b, long range)
{
     f42:	4f 92       	push	r4
     f44:	5f 92       	push	r5
     f46:	6f 92       	push	r6
     f48:	7f 92       	push	r7
     f4a:	8f 92       	push	r8
     f4c:	9f 92       	push	r9
     f4e:	af 92       	push	r10
     f50:	bf 92       	push	r11
     f52:	cf 92       	push	r12
     f54:	df 92       	push	r13
     f56:	ef 92       	push	r14
     f58:	ff 92       	push	r15
     f5a:	0f 93       	push	r16
     f5c:	1f 93       	push	r17
     f5e:	2b 01       	movw	r4, r22
     f60:	3c 01       	movw	r6, r24
     f62:	ba 01       	movw	r22, r20
     f64:	a9 01       	movw	r20, r18
     f66:	d8 01       	movw	r26, r16
     f68:	c7 01       	movw	r24, r14
     f6a:	96 01       	movw	r18, r12
     f6c:	85 01       	movw	r16, r10
    b -= a;
     f6e:	6c 01       	movw	r12, r24
     f70:	7d 01       	movw	r14, r26
     f72:	c4 1a       	sub	r12, r20
     f74:	d5 0a       	sbc	r13, r21
     f76:	e6 0a       	sbc	r14, r22
     f78:	f7 0a       	sbc	r15, r23
    return (int)(((v - a)*range + (b>>1))/b);
     f7a:	53 01       	movw	r10, r6
     f7c:	42 01       	movw	r8, r4
     f7e:	84 1a       	sub	r8, r20
     f80:	95 0a       	sbc	r9, r21
     f82:	a6 0a       	sbc	r10, r22
     f84:	b7 0a       	sbc	r11, r23
     f86:	c5 01       	movw	r24, r10
     f88:	b4 01       	movw	r22, r8
     f8a:	a9 01       	movw	r20, r18
     f8c:	98 01       	movw	r18, r16
     f8e:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <__mulsi3>
     f92:	ab 01       	movw	r20, r22
     f94:	bc 01       	movw	r22, r24
     f96:	d7 01       	movw	r26, r14
     f98:	c6 01       	movw	r24, r12
     f9a:	b5 95       	asr	r27
     f9c:	a7 95       	ror	r26
     f9e:	97 95       	ror	r25
     fa0:	87 95       	ror	r24
     fa2:	8a 01       	movw	r16, r20
     fa4:	9b 01       	movw	r18, r22
     fa6:	08 0f       	add	r16, r24
     fa8:	19 1f       	adc	r17, r25
     faa:	2a 1f       	adc	r18, r26
     fac:	3b 1f       	adc	r19, r27
     fae:	c9 01       	movw	r24, r18
     fb0:	b8 01       	movw	r22, r16
     fb2:	a7 01       	movw	r20, r14
     fb4:	96 01       	movw	r18, r12
     fb6:	0e 94 0a 0b 	call	0x1614	; 0x1614 <__divmodsi4>
}
     fba:	82 2f       	mov	r24, r18
     fbc:	93 2f       	mov	r25, r19
     fbe:	1f 91       	pop	r17
     fc0:	0f 91       	pop	r16
     fc2:	ff 90       	pop	r15
     fc4:	ef 90       	pop	r14
     fc6:	df 90       	pop	r13
     fc8:	cf 90       	pop	r12
     fca:	bf 90       	pop	r11
     fcc:	af 90       	pop	r10
     fce:	9f 90       	pop	r9
     fd0:	8f 90       	pop	r8
     fd2:	7f 90       	pop	r7
     fd4:	6f 90       	pop	r6
     fd6:	5f 90       	pop	r5
     fd8:	4f 90       	pop	r4
     fda:	08 95       	ret

00000fdc <_Z9quicksortPiii>:

void quicksort(int arr[], int left, int right)
{
     fdc:	af 92       	push	r10
     fde:	bf 92       	push	r11
     fe0:	cf 92       	push	r12
     fe2:	df 92       	push	r13
     fe4:	ef 92       	push	r14
     fe6:	ff 92       	push	r15
     fe8:	0f 93       	push	r16
     fea:	1f 93       	push	r17
     fec:	cf 93       	push	r28
     fee:	df 93       	push	r29
     ff0:	7c 01       	movw	r14, r24
     ff2:	6b 01       	movw	r12, r22
     ff4:	5a 01       	movw	r10, r20
    int i = left, j = right;
    int tmp;
    int pivot = arr[(left + right) >> 1];
     ff6:	fb 01       	movw	r30, r22
     ff8:	e4 0f       	add	r30, r20
     ffa:	f5 1f       	adc	r31, r21
     ffc:	ee 7f       	andi	r30, 0xFE	; 254
     ffe:	e8 0f       	add	r30, r24
    1000:	f9 1f       	adc	r31, r25
    1002:	60 81       	ld	r22, Z
    1004:	71 81       	ldd	r23, Z+1	; 0x01
    return (int)(((v - a)*range + (b>>1))/b);
}

void quicksort(int arr[], int left, int right)
{
    int i = left, j = right;
    1006:	e6 01       	movw	r28, r12
    int tmp;
    int pivot = arr[(left + right) >> 1];

    while (i <= j) {
    1008:	2e c0       	rjmp	.+92     	; 0x1066 <_Z9quicksortPiii+0x8a>
        while (arr[i] < pivot)
            i++;
    100a:	21 96       	adiw	r28, 0x01	; 1
    int i = left, j = right;
    int tmp;
    int pivot = arr[(left + right) >> 1];

    while (i <= j) {
        while (arr[i] < pivot)
    100c:	8f 01       	movw	r16, r30
    100e:	21 91       	ld	r18, Z+
    1010:	31 91       	ld	r19, Z+
    1012:	26 17       	cp	r18, r22
    1014:	37 07       	cpc	r19, r23
    1016:	cc f3       	brlt	.-14     	; 0x100a <_Z9quicksortPiii+0x2e>
            i++;
        while (arr[j] > pivot)
    1018:	ca 01       	movw	r24, r20
    101a:	88 0f       	add	r24, r24
    101c:	99 1f       	adc	r25, r25
    101e:	d7 01       	movw	r26, r14
    1020:	a8 0f       	add	r26, r24
    1022:	b9 1f       	adc	r27, r25
    1024:	8d 91       	ld	r24, X+
    1026:	9c 91       	ld	r25, X
    1028:	11 97       	sbiw	r26, 0x01	; 1
    102a:	68 17       	cp	r22, r24
    102c:	79 07       	cpc	r23, r25
    102e:	7c f4       	brge	.+30     	; 0x104e <_Z9quicksortPiii+0x72>
{
    b -= a;
    return (int)(((v - a)*range + (b>>1))/b);
}

void quicksort(int arr[], int left, int right)
    1030:	fa 01       	movw	r30, r20
    1032:	31 97       	sbiw	r30, 0x01	; 1
    1034:	ee 0f       	add	r30, r30
    1036:	ff 1f       	adc	r31, r31
    1038:	ee 0d       	add	r30, r14
    103a:	ff 1d       	adc	r31, r15

    while (i <= j) {
        while (arr[i] < pivot)
            i++;
        while (arr[j] > pivot)
            j--;
    103c:	41 50       	subi	r20, 0x01	; 1
    103e:	50 40       	sbci	r21, 0x00	; 0
    int pivot = arr[(left + right) >> 1];

    while (i <= j) {
        while (arr[i] < pivot)
            i++;
        while (arr[j] > pivot)
    1040:	df 01       	movw	r26, r30
    1042:	32 97       	sbiw	r30, 0x02	; 2
    1044:	82 81       	ldd	r24, Z+2	; 0x02
    1046:	93 81       	ldd	r25, Z+3	; 0x03
    1048:	68 17       	cp	r22, r24
    104a:	79 07       	cpc	r23, r25
    104c:	bc f3       	brlt	.-18     	; 0x103c <_Z9quicksortPiii+0x60>
            j--;
        if (i <= j)
    104e:	4c 17       	cp	r20, r28
    1050:	5d 07       	cpc	r21, r29
    1052:	fc f0       	brlt	.+62     	; 0x1092 <_Z9quicksortPiii+0xb6>
        {
            tmp = arr[i];
            arr[i] = arr[j];
    1054:	f8 01       	movw	r30, r16
    1056:	91 83       	std	Z+1, r25	; 0x01
    1058:	80 83       	st	Z, r24
            arr[j] = tmp;
    105a:	11 96       	adiw	r26, 0x01	; 1
    105c:	3c 93       	st	X, r19
    105e:	2e 93       	st	-X, r18
            i++;
    1060:	21 96       	adiw	r28, 0x01	; 1
            j--;
    1062:	41 50       	subi	r20, 0x01	; 1
    1064:	50 40       	sbci	r21, 0x00	; 0
{
    int i = left, j = right;
    int tmp;
    int pivot = arr[(left + right) >> 1];

    while (i <= j) {
    1066:	4c 17       	cp	r20, r28
    1068:	5d 07       	cpc	r21, r29
    106a:	9c f0       	brlt	.+38     	; 0x1092 <_Z9quicksortPiii+0xb6>
        while (arr[i] < pivot)
    106c:	ce 01       	movw	r24, r28
    106e:	88 0f       	add	r24, r24
    1070:	99 1f       	adc	r25, r25
    1072:	87 01       	movw	r16, r14
    1074:	08 0f       	add	r16, r24
    1076:	19 1f       	adc	r17, r25
    1078:	f8 01       	movw	r30, r16
    107a:	20 81       	ld	r18, Z
    107c:	31 81       	ldd	r19, Z+1	; 0x01
    107e:	26 17       	cp	r18, r22
    1080:	37 07       	cpc	r19, r23
    1082:	54 f6       	brge	.-108    	; 0x1018 <_Z9quicksortPiii+0x3c>
{
    b -= a;
    return (int)(((v - a)*range + (b>>1))/b);
}

void quicksort(int arr[], int left, int right)
    1084:	fe 01       	movw	r30, r28
    1086:	31 96       	adiw	r30, 0x01	; 1
    1088:	ee 0f       	add	r30, r30
    108a:	ff 1f       	adc	r31, r31
    108c:	ee 0d       	add	r30, r14
    108e:	ff 1d       	adc	r31, r15
    1090:	bc cf       	rjmp	.-136    	; 0x100a <_Z9quicksortPiii+0x2e>
            i++;
            j--;
        }
    }

    if (left < j)
    1092:	c4 16       	cp	r12, r20
    1094:	d5 06       	cpc	r13, r21
    1096:	24 f4       	brge	.+8      	; 0x10a0 <_Z9quicksortPiii+0xc4>
        quicksort(arr, left, j);
    1098:	c7 01       	movw	r24, r14
    109a:	b6 01       	movw	r22, r12
    109c:	0e 94 ee 07 	call	0xfdc	; 0xfdc <_Z9quicksortPiii>
    if (i < right)
    10a0:	ca 15       	cp	r28, r10
    10a2:	db 05       	cpc	r29, r11
    10a4:	2c f4       	brge	.+10     	; 0x10b0 <_Z9quicksortPiii+0xd4>
        quicksort(arr, i, right);
    10a6:	c7 01       	movw	r24, r14
    10a8:	be 01       	movw	r22, r28
    10aa:	a5 01       	movw	r20, r10
    10ac:	0e 94 ee 07 	call	0xfdc	; 0xfdc <_Z9quicksortPiii>
}
    10b0:	df 91       	pop	r29
    10b2:	cf 91       	pop	r28
    10b4:	1f 91       	pop	r17
    10b6:	0f 91       	pop	r16
    10b8:	ff 90       	pop	r15
    10ba:	ef 90       	pop	r14
    10bc:	df 90       	pop	r13
    10be:	cf 90       	pop	r12
    10c0:	bf 90       	pop	r11
    10c2:	af 90       	pop	r10
    10c4:	08 95       	ret

000010c6 <_Z6filterPi>:

int filter(int* d)
{
    10c6:	cf 93       	push	r28
    10c8:	df 93       	push	r29
    10ca:	ec 01       	movw	r28, r24
    quicksort(d,0,7);
    10cc:	60 e0       	ldi	r22, 0x00	; 0
    10ce:	70 e0       	ldi	r23, 0x00	; 0
    10d0:	47 e0       	ldi	r20, 0x07	; 7
    10d2:	50 e0       	ldi	r21, 0x00	; 0
    10d4:	0e 94 ee 07 	call	0xfdc	; 0xfdc <_Z9quicksortPiii>
    int n = 0;
    for (byte i = 2; i < 6; i++)
        n += d[i];
    10d8:	8c 81       	ldd	r24, Y+4	; 0x04
    10da:	9d 81       	ldd	r25, Y+5	; 0x05
    10dc:	2e 81       	ldd	r18, Y+6	; 0x06
    10de:	3f 81       	ldd	r19, Y+7	; 0x07
    10e0:	82 0f       	add	r24, r18
    10e2:	93 1f       	adc	r25, r19
    10e4:	28 85       	ldd	r18, Y+8	; 0x08
    10e6:	39 85       	ldd	r19, Y+9	; 0x09
    10e8:	82 0f       	add	r24, r18
    10ea:	93 1f       	adc	r25, r19
    10ec:	2a 85       	ldd	r18, Y+10	; 0x0a
    10ee:	3b 85       	ldd	r19, Y+11	; 0x0b
    10f0:	82 0f       	add	r24, r18
    10f2:	93 1f       	adc	r25, r19
    return n;
}
    10f4:	df 91       	pop	r29
    10f6:	cf 91       	pop	r28
    10f8:	08 95       	ret

000010fa <_ZN3LCD8SetPixelEiit>:

void LCD::SetPixel(int x, int y, ushort colour)
{
    10fa:	cf 92       	push	r12
    10fc:	df 92       	push	r13
    10fe:	ef 92       	push	r14
    1100:	ff 92       	push	r15
    1102:	0f 93       	push	r16
    1104:	1f 93       	push	r17
    1106:	cf 93       	push	r28
    1108:	df 93       	push	r29
    110a:	8c 01       	movw	r16, r24
    110c:	7b 01       	movw	r14, r22
    110e:	6a 01       	movw	r12, r20
		
	width = LCD::GetWidth();
	height = LCD::GetHeight();
	int right = x + width;
	int bottom = y + height;
	right = LCD::GetWidth();
    1110:	0e 94 3c 06 	call	0xc78	; 0xc78 <_ZN3LCD8GetWidthEv>
    1114:	ec 01       	movw	r28, r24
	bottom = LCD::GetHeight();
    1116:	0e 94 3f 06 	call	0xc7e	; 0xc7e <_ZN3LCD9GetHeightEv>
	width = right - x;
    111a:	c0 1b       	sub	r28, r16
    111c:	d1 0b       	sbc	r29, r17
	height = bottom - y;
	if (width <= 0 || height <= 0)
    111e:	1c 16       	cp	r1, r28
    1120:	1d 06       	cpc	r1, r29
    1122:	c4 f4       	brge	.+48     	; 0x1154 <__stack+0x55>
	int right = x + width;
	int bottom = y + height;
	right = LCD::GetWidth();
	bottom = LCD::GetHeight();
	width = right - x;
	height = bottom - y;
    1124:	8e 19       	sub	r24, r14
    1126:	9f 09       	sbc	r25, r15
	if (width <= 0 || height <= 0)
    1128:	18 16       	cp	r1, r24
    112a:	19 06       	cpc	r1, r25
    112c:	9c f4       	brge	.+38     	; 0x1154 <__stack+0x55>
		return;
		
	LCD::SetWrap(x,y,1,1);
    112e:	c8 01       	movw	r24, r16
    1130:	b7 01       	movw	r22, r14
    1132:	41 e0       	ldi	r20, 0x01	; 1
    1134:	50 e0       	ldi	r21, 0x00	; 0
    1136:	21 e0       	ldi	r18, 0x01	; 1
    1138:	30 e0       	ldi	r19, 0x00	; 0
    113a:	0e 94 08 06 	call	0xc10	; 0xc10 <_ZN3LCD7SetWrapEiiii>
	LCD::SetGRAM(x,y);
    113e:	c8 01       	movw	r24, r16
    1140:	b7 01       	movw	r22, r14
    1142:	0e 94 34 06 	call	0xc68	; 0xc68 <_ZN3LCD7SetGRAMEii>
	LCD::SetColor(colour);
    1146:	c6 01       	movw	r24, r12
    1148:	0e 94 42 06 	call	0xc84	; 0xc84 <_ZN3LCD8SetColorEt>
		
	LCD::SolidFill(2);
    114c:	82 e0       	ldi	r24, 0x02	; 2
    114e:	90 e0       	ldi	r25, 0x00	; 0
    1150:	0e 94 37 07 	call	0xe6e	; 0xe6e <_ZN3LCD9SolidFillEt>
}
    1154:	df 91       	pop	r29
    1156:	cf 91       	pop	r28
    1158:	1f 91       	pop	r17
    115a:	0f 91       	pop	r16
    115c:	ff 90       	pop	r15
    115e:	ef 90       	pop	r14
    1160:	df 90       	pop	r13
    1162:	cf 90       	pop	r12
    1164:	08 95       	ret

00001166 <__vector_1>:
	
};
#endif
//ISR for controlling WEN.
ISR(INT0_vect)
{
    1166:	1f 92       	push	r1
    1168:	0f 92       	push	r0
    116a:	0f b6       	in	r0, 0x3f	; 63
    116c:	0f 92       	push	r0
    116e:	11 24       	eor	r1, r1
    1170:	8f 93       	push	r24
    1172:	9f 93       	push	r25
	//xprintf(PSTR("ISR Entered"));
	if (VSYNC_Count==1)//start a frame read
    1174:	80 91 a2 02 	lds	r24, 0x02A2
    1178:	90 91 a3 02 	lds	r25, 0x02A3
    117c:	81 30       	cpi	r24, 0x01	; 1
    117e:	91 05       	cpc	r25, r1
    1180:	59 f4       	brne	.+22     	; 0x1198 <__vector_1+0x32>
	{
		/*xprintf(PSTR("WEN Set\n"));*/
		FIFO_WEN_SET;
    1182:	46 9a       	sbi	0x08, 6	; 8
		VSYNC_Count++;
    1184:	80 91 a2 02 	lds	r24, 0x02A2
    1188:	90 91 a3 02 	lds	r25, 0x02A3
    118c:	01 96       	adiw	r24, 0x01	; 1
    118e:	90 93 a3 02 	sts	0x02A3, r25
    1192:	80 93 a2 02 	sts	0x02A2, r24
    1196:	0d c0       	rjmp	.+26     	; 0x11b2 <__vector_1+0x4c>
	}
	else if (VSYNC_Count==2)//end a frame read
    1198:	80 91 a2 02 	lds	r24, 0x02A2
    119c:	90 91 a3 02 	lds	r25, 0x02A3
    11a0:	82 30       	cpi	r24, 0x02	; 2
    11a2:	91 05       	cpc	r25, r1
    11a4:	11 f4       	brne	.+4      	; 0x11aa <__vector_1+0x44>
	{
		FIFO_WEN_CLR;
    11a6:	46 98       	cbi	0x08, 6	; 8
    11a8:	04 c0       	rjmp	.+8      	; 0x11b2 <__vector_1+0x4c>
		/*xprintf(PSTR("WEN Clear\n"));*/
	}
	else
	{
		VSYNC_Count = 0;//wait for a read to be started
    11aa:	10 92 a3 02 	sts	0x02A3, r1
    11ae:	10 92 a2 02 	sts	0x02A2, r1
	}
}
    11b2:	9f 91       	pop	r25
    11b4:	8f 91       	pop	r24
    11b6:	0f 90       	pop	r0
    11b8:	0f be       	out	0x3f, r0	; 63
    11ba:	0f 90       	pop	r0
    11bc:	1f 90       	pop	r1
    11be:	18 95       	reti

000011c0 <wrOV7670Reg>:

//Write Register Method
unsigned char wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
    11c0:	cf 93       	push	r28
    11c2:	df 93       	push	r29
    11c4:	00 d0       	rcall	.+0      	; 0x11c6 <wrOV7670Reg+0x6>
    11c6:	00 d0       	rcall	.+0      	; 0x11c8 <wrOV7670Reg+0x8>
    11c8:	cd b7       	in	r28, 0x3d	; 61
    11ca:	de b7       	in	r29, 0x3e	; 62
	/*	I2C Traffic Generated:
	 *	S | OV_7670 + W | A | RegID | A | Data | A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (OV7670_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
    11cc:	92 e4       	ldi	r25, 0x42	; 66
    11ce:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for commands.
    11d0:	8a 83       	std	Y+2, r24	; 0x02
	messageBuf[2] = regDat;                        // The second byte is used for the data.
    11d2:	6b 83       	std	Y+3, r22	; 0x03
	TWI_Start_Transceiver_With_Data( messageBuf, 3 );
    11d4:	ce 01       	movw	r24, r28
    11d6:	01 96       	adiw	r24, 0x01	; 1
    11d8:	63 e0       	ldi	r22, 0x03	; 3
    11da:	0e 94 08 0a 	call	0x1410	; 0x1410 <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
    11de:	0e 94 fd 09 	call	0x13fa	; 0x13fa <TWI_Transceiver_Busy>
    11e2:	88 23       	and	r24, r24
    11e4:	e1 f7       	brne	.-8      	; 0x11de <wrOV7670Reg+0x1e>
	
	return TWI_statusReg.lastTransOK;
    11e6:	80 91 aa 02 	lds	r24, 0x02AA
}
    11ea:	81 70       	andi	r24, 0x01	; 1
    11ec:	0f 90       	pop	r0
    11ee:	0f 90       	pop	r0
    11f0:	0f 90       	pop	r0
    11f2:	0f 90       	pop	r0
    11f4:	df 91       	pop	r29
    11f6:	cf 91       	pop	r28
    11f8:	08 95       	ret

000011fa <rdOV7670Reg>:

//Read Register Method
unsigned char rdOV7670Reg(unsigned char regID, unsigned char *regDat)
{
    11fa:	0f 93       	push	r16
    11fc:	1f 93       	push	r17
    11fe:	cf 93       	push	r28
    1200:	df 93       	push	r29
    1202:	00 d0       	rcall	.+0      	; 0x1204 <rdOV7670Reg+0xa>
    1204:	00 d0       	rcall	.+0      	; 0x1206 <rdOV7670Reg+0xc>
    1206:	cd b7       	in	r28, 0x3d	; 61
    1208:	de b7       	in	r29, 0x3e	; 62
    120a:	8b 01       	movw	r16, r22
	 *	S	|	OV_ADDR + W	| A | RegID | A | P |
	 *	S	|	OV_ADDR + R | A | Data	|~A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
    120c:	92 e4       	ldi	r25, 0x42	; 66
    120e:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for Address Pointer.
    1210:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
    1212:	ce 01       	movw	r24, r28
    1214:	01 96       	adiw	r24, 0x01	; 1
    1216:	62 e0       	ldi	r22, 0x02	; 2
    1218:	0e 94 08 0a 	call	0x1410	; 0x1410 <TWI_Start_Transceiver_With_Data>
	
	// Request/collect the data from the Slave
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
    121c:	83 e4       	ldi	r24, 0x43	; 67
    121e:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );              
    1220:	ce 01       	movw	r24, r28
    1222:	01 96       	adiw	r24, 0x01	; 1
    1224:	62 e0       	ldi	r22, 0x02	; 2
    1226:	0e 94 08 0a 	call	0x1410	; 0x1410 <TWI_Start_Transceiver_With_Data>
    
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
    122a:	ce 01       	movw	r24, r28
    122c:	01 96       	adiw	r24, 0x01	; 1
    122e:	62 e0       	ldi	r22, 0x02	; 2
    1230:	0e 94 3e 0a 	call	0x147c	; 0x147c <TWI_Get_Data_From_Transceiver>
	*regDat = messageBuf[1];       
    1234:	8a 81       	ldd	r24, Y+2	; 0x02
    1236:	f8 01       	movw	r30, r16
    1238:	80 83       	st	Z, r24
	return TWI_statusReg.lastTransOK;
    123a:	80 91 aa 02 	lds	r24, 0x02AA
}
    123e:	81 70       	andi	r24, 0x01	; 1
    1240:	0f 90       	pop	r0
    1242:	0f 90       	pop	r0
    1244:	0f 90       	pop	r0
    1246:	0f 90       	pop	r0
    1248:	df 91       	pop	r29
    124a:	cf 91       	pop	r28
    124c:	1f 91       	pop	r17
    124e:	0f 91       	pop	r16
    1250:	08 95       	ret

00001252 <OV7670_init>:

// Initial OV7670 - TWI_Master Must be initialised before hand.
unsigned char OV7670_init(void)
{
    1252:	0f 93       	push	r16
    1254:	1f 93       	push	r17
    1256:	cf 93       	push	r28
    1258:	df 93       	push	r29
	
	VSYNC_Count = 0;
    125a:	10 92 a3 02 	sts	0x02A3, r1
    125e:	10 92 a2 02 	sts	0x02A2, r1
	unsigned char temp;
	
	unsigned int i=0;
	
	// initial the int0 interrupt for WEN
	DDRD &= ~(1<<OV7670_VSYNC);		//set OV7670_SYNC as input for INT0
    1262:	52 98       	cbi	0x0a, 2	; 10
	PORTD |= (1<<OV7670_VSYNC);		//Enable OV7670_SYNC pull-up resistor
    1264:	5a 9a       	sbi	0x0b, 2	; 11
	
	EIMSK = 1<<INT0;				//Enable INT0
    1266:	81 e0       	ldi	r24, 0x01	; 1
    1268:	8d bb       	out	0x1d, r24	; 29
	EICRA = 1<<ISC01;				//Trigger INT0 on the falling edge
    126a:	82 e0       	ldi	r24, 0x02	; 2
    126c:	80 93 69 00 	sts	0x0069, r24
	
	temp=0x80;
	if(0==wrOV7670Reg(OV_COM7, temp)) //Reset Camera
    1270:	82 e1       	ldi	r24, 0x12	; 18
    1272:	60 e8       	ldi	r22, 0x80	; 128
    1274:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <wrOV7670Reg>
    1278:	88 23       	and	r24, r24
    127a:	f1 f0       	breq	.+60     	; 0x12b8 <OV7670_init+0x66>
    127c:	83 ec       	ldi	r24, 0xC3	; 195
    127e:	99 e0       	ldi	r25, 0x09	; 9
    1280:	01 97       	sbiw	r24, 0x01	; 1
    1282:	f1 f7       	brne	.-4      	; 0x1280 <OV7670_init+0x2e>
    1284:	00 c0       	rjmp	.+0      	; 0x1286 <OV7670_init+0x34>
    1286:	00 00       	nop
    1288:	c4 e5       	ldi	r28, 0x54	; 84
    128a:	d1 e0       	ldi	r29, 0x01	; 1
	*regDat = messageBuf[1];       
	return TWI_statusReg.lastTransOK;
}

// Initial OV7670 - TWI_Master Must be initialised before hand.
unsigned char OV7670_init(void)
    128c:	02 ea       	ldi	r16, 0xA2	; 162
    128e:	12 e0       	ldi	r17, 0x02	; 2
    1290:	fe 01       	movw	r30, r28
    1292:	31 97       	sbiw	r30, 0x01	; 1
	}
	_delay_ms(10);
#if SETTINGS == PGM_SPACE
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
    1294:	80 81       	ld	r24, Z
    1296:	68 81       	ld	r22, Y
    1298:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <wrOV7670Reg>
    129c:	88 23       	and	r24, r24
    129e:	71 f0       	breq	.+28     	; 0x12bc <OV7670_init+0x6a>
    12a0:	89 ef       	ldi	r24, 0xF9	; 249
    12a2:	90 e0       	ldi	r25, 0x00	; 0
    12a4:	01 97       	sbiw	r24, 0x01	; 1
    12a6:	f1 f7       	brne	.-4      	; 0x12a4 <OV7670_init+0x52>
    12a8:	00 c0       	rjmp	.+0      	; 0x12aa <OV7670_init+0x58>
    12aa:	00 00       	nop
    12ac:	22 96       	adiw	r28, 0x02	; 2
	{
		return 0;
	}
	_delay_ms(10);
#if SETTINGS == PGM_SPACE
	for(i=0; i<SETTINGS_LENGTH; i++)
    12ae:	c0 17       	cp	r28, r16
    12b0:	d1 07       	cpc	r29, r17
    12b2:	71 f7       	brne	.-36     	; 0x1290 <OV7670_init+0x3e>
			return 0;
		}
		_delay_ms(1);
	}	
#endif
	return 1; //ok
    12b4:	81 e0       	ldi	r24, 0x01	; 1
    12b6:	03 c0       	rjmp	.+6      	; 0x12be <OV7670_init+0x6c>
	EICRA = 1<<ISC01;				//Trigger INT0 on the falling edge
	
	temp=0x80;
	if(0==wrOV7670Reg(OV_COM7, temp)) //Reset Camera
	{
		return 0;
    12b8:	80 e0       	ldi	r24, 0x00	; 0
    12ba:	01 c0       	rjmp	.+2      	; 0x12be <OV7670_init+0x6c>
#if SETTINGS == PGM_SPACE
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
		{
			return 0;
    12bc:	80 e0       	ldi	r24, 0x00	; 0
		}
		_delay_ms(1);
	}	
#endif
	return 1; //ok
}
    12be:	df 91       	pop	r29
    12c0:	cf 91       	pop	r28
    12c2:	1f 91       	pop	r17
    12c4:	0f 91       	pop	r16
    12c6:	08 95       	ret

000012c8 <FIFO_Reset>:

//Resets both pointers
void FIFO_Reset() 
{
	FIFO_WRST_CLR;
    12c8:	43 98       	cbi	0x08, 3	; 8
	FIFO_nRRST_CLR;
    12ca:	47 98       	cbi	0x08, 7	; 8
	FIFO_RCLK_SET;
    12cc:	44 9a       	sbi	0x08, 4	; 8
	FIFO_RCLK_CLR;
    12ce:	44 98       	cbi	0x08, 4	; 8
	FIFO_nRRST_SET;
    12d0:	47 9a       	sbi	0x08, 7	; 8
	FIFO_WRST_SET;
    12d2:	43 9a       	sbi	0x08, 3	; 8
}
    12d4:	08 95       	ret

000012d6 <LoadImageToBuffer>:
}


void LoadImageToBuffer( void )
{
	while(VSYNC_Count != 0); //wait for any frame to be written to complete
    12d6:	80 91 a2 02 	lds	r24, 0x02A2
    12da:	90 91 a3 02 	lds	r25, 0x02A3
    12de:	00 97       	sbiw	r24, 0x00	; 0
    12e0:	d1 f7       	brne	.-12     	; 0x12d6 <LoadImageToBuffer>
	FIFO_WRST_CLR;//Reset the write pointer
    12e2:	43 98       	cbi	0x08, 3	; 8
    12e4:	89 ef       	ldi	r24, 0xF9	; 249
    12e6:	90 e0       	ldi	r25, 0x00	; 0
    12e8:	01 97       	sbiw	r24, 0x01	; 1
    12ea:	f1 f7       	brne	.-4      	; 0x12e8 <LoadImageToBuffer+0x12>
    12ec:	00 c0       	rjmp	.+0      	; 0x12ee <LoadImageToBuffer+0x18>
    12ee:	00 00       	nop
	_delay_ms(1);//wait a few clock cycles of the internal oscillator
	FIFO_WRST_SET;
    12f0:	43 9a       	sbi	0x08, 3	; 8
    12f2:	89 ef       	ldi	r24, 0xF9	; 249
    12f4:	90 e0       	ldi	r25, 0x00	; 0
    12f6:	01 97       	sbiw	r24, 0x01	; 1
    12f8:	f1 f7       	brne	.-4      	; 0x12f6 <LoadImageToBuffer+0x20>
    12fa:	00 c0       	rjmp	.+0      	; 0x12fc <LoadImageToBuffer+0x26>
    12fc:	00 00       	nop
	_delay_ms(1);
	VSYNC_Count = 1;
    12fe:	81 e0       	ldi	r24, 0x01	; 1
    1300:	90 e0       	ldi	r25, 0x00	; 0
    1302:	90 93 a3 02 	sts	0x02A3, r25
    1306:	80 93 a2 02 	sts	0x02A2, r24
}
    130a:	08 95       	ret

0000130c <FIFO_init>:

//Initial FIFO
unsigned char FIFO_init(void)
{
	
	OV7670_CTRL_DDR |=(1<<FIFO_WEN)|(1<<FIFO_nRRST)|(1<<FIFO_RCLK)|(1 << FIFO_WRST) | (1 << FIFO_nOE);
    130c:	87 b1       	in	r24, 0x07	; 7
    130e:	88 6f       	ori	r24, 0xF8	; 248
    1310:	87 b9       	out	0x07, r24	; 7
	FIFO_WRST_CLR;
    1312:	43 98       	cbi	0x08, 3	; 8
	
	FIFO_RCLK_CLR;
    1314:	44 98       	cbi	0x08, 4	; 8
	FIFO_nOE_CLR;
    1316:	45 98       	cbi	0x08, 5	; 8
	FIFO_nRRST_SET;
    1318:	47 9a       	sbi	0x08, 7	; 8
	FIFO_WEN_CLR;
    131a:	46 98       	cbi	0x08, 6	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    131c:	83 e0       	ldi	r24, 0x03	; 3
    131e:	8a 95       	dec	r24
    1320:	f1 f7       	brne	.-4      	; 0x131e <FIFO_init+0x12>
    1322:	00 00       	nop
	_delay_us(10);
	FIFO_RCLK_SET;
    1324:	44 9a       	sbi	0x08, 4	; 8
    1326:	83 e0       	ldi	r24, 0x03	; 3
    1328:	8a 95       	dec	r24
    132a:	f1 f7       	brne	.-4      	; 0x1328 <FIFO_init+0x1c>
    132c:	00 00       	nop
	_delay_us(10);
	FIFO_RCLK_CLR;
    132e:	44 98       	cbi	0x08, 4	; 8
	FIFO_nRRST_CLR;
    1330:	47 98       	cbi	0x08, 7	; 8
    1332:	83 e0       	ldi	r24, 0x03	; 3
    1334:	8a 95       	dec	r24
    1336:	f1 f7       	brne	.-4      	; 0x1334 <FIFO_init+0x28>
    1338:	00 00       	nop
	_delay_us(10);
	FIFO_RCLK_SET;
    133a:	44 9a       	sbi	0x08, 4	; 8
    133c:	83 e0       	ldi	r24, 0x03	; 3
    133e:	8a 95       	dec	r24
    1340:	f1 f7       	brne	.-4      	; 0x133e <FIFO_init+0x32>
    1342:	00 00       	nop
	_delay_us(10);
	FIFO_RCLK_CLR;
    1344:	44 98       	cbi	0x08, 4	; 8
	FIFO_nRRST_SET;
    1346:	47 9a       	sbi	0x08, 7	; 8
    1348:	83 e0       	ldi	r24, 0x03	; 3
    134a:	8a 95       	dec	r24
    134c:	f1 f7       	brne	.-4      	; 0x134a <FIFO_init+0x3e>
    134e:	00 00       	nop
	_delay_us(10);
	FIFO_WRST_SET;
    1350:	43 9a       	sbi	0x08, 3	; 8
	return 0x01; //okay
}
    1352:	81 e0       	ldi	r24, 0x01	; 1
    1354:	08 95       	ret

00001356 <FIFO_TO_AVR>:
//Write one pixel in AVR
uint16_t FIFO_TO_AVR(void)
{
	uint16_t data = 0;
	
	FIFO_AVR_DPRT=0;
    1356:	11 b8       	out	0x01, r1	; 1
	
	FIFO_RCLK_SET;
    1358:	44 9a       	sbi	0x08, 4	; 8
	data = FIFO_AVR_PINP;
    135a:	80 b1       	in	r24, 0x00	; 0
	FIFO_RCLK_CLR;
    135c:	44 98       	cbi	0x08, 4	; 8

	data <<= 8;
    135e:	38 2f       	mov	r19, r24
    1360:	20 e0       	ldi	r18, 0x00	; 0
	
	FIFO_RCLK_SET;
    1362:	44 9a       	sbi	0x08, 4	; 8
	data |= FIFO_AVR_PINP;
    1364:	80 b1       	in	r24, 0x00	; 0
	FIFO_RCLK_CLR;
    1366:	44 98       	cbi	0x08, 4	; 8
	FIFO_RCLK_CLR;

	data <<= 8;
	
	FIFO_RCLK_SET;
	data |= FIFO_AVR_PINP;
    1368:	90 e0       	ldi	r25, 0x00	; 0
    136a:	82 2b       	or	r24, r18
    136c:	93 2b       	or	r25, r19
	//	FIFO_RCLK_CLR;
	//	FIFO_RCLK_SET;
	//	FIFO_RCLK_CLR;
	
	return(data);
}
    136e:	08 95       	ret

00001370 <GetImageIfAvailiable>:
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( int offset )
{
    1370:	ef 92       	push	r14
    1372:	ff 92       	push	r15
    1374:	0f 93       	push	r16
    1376:	1f 93       	push	r17
    1378:	cf 93       	push	r28
    137a:	df 93       	push	r29
	if (VSYNC_Count == 2)//if one full frame has elapsed.
    137c:	80 91 a2 02 	lds	r24, 0x02A2
    1380:	90 91 a3 02 	lds	r25, 0x02A3
    1384:	82 30       	cpi	r24, 0x02	; 2
    1386:	91 05       	cpc	r25, r1
    1388:	31 f5       	brne	.+76     	; 0x13d6 <GetImageIfAvailiable+0x66>
		uint32_t p;
		unsigned long int pointer;
		//FRESULT fr;
		int i,j, ptr;
		uint16_t Temp;
		FIFO_nRRST_CLR; //Reset Read Pointer
    138a:	47 98       	cbi	0x08, 7	; 8
		FIFO_RCLK_SET;
    138c:	44 9a       	sbi	0x08, 4	; 8
		FIFO_RCLK_CLR;
    138e:	44 98       	cbi	0x08, 4	; 8
		FIFO_nRRST_SET;
    1390:	47 9a       	sbi	0x08, 7	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1392:	89 ef       	ldi	r24, 0xF9	; 249
    1394:	90 e0       	ldi	r25, 0x00	; 0
    1396:	01 97       	sbiw	r24, 0x01	; 1
    1398:	f1 f7       	brne	.-4      	; 0x1396 <GetImageIfAvailiable+0x26>
    139a:	00 c0       	rjmp	.+0      	; 0x139c <GetImageIfAvailiable+0x2c>
    139c:	00 00       	nop
    139e:	00 ef       	ldi	r16, 0xF0	; 240
    13a0:	10 e0       	ldi	r17, 0x00	; 0
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( int offset )
{
    13a2:	0f 2e       	mov	r0, r31
    13a4:	f0 e4       	ldi	r31, 0x40	; 64
    13a6:	ef 2e       	mov	r14, r31
    13a8:	f1 e0       	ldi	r31, 0x01	; 1
    13aa:	ff 2e       	mov	r15, r31
    13ac:	f0 2d       	mov	r31, r0
    13ae:	07 c0       	rjmp	.+14     	; 0x13be <GetImageIfAvailiable+0x4e>
		{
			ptr = 0;
			for (i=0; i < WIDTH; i++)
			{
				
				Temp=FIFO_TO_AVR();
    13b0:	0e 94 ab 09 	call	0x1356	; 0x1356 <FIFO_TO_AVR>
    13b4:	21 97       	sbiw	r28, 0x01	; 1
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=HEIGHT; j > 0; j--) //Read all data 
		{
			ptr = 0;
			for (i=0; i < WIDTH; i++)
    13b6:	e1 f7       	brne	.-8      	; 0x13b0 <GetImageIfAvailiable+0x40>
    13b8:	01 50       	subi	r16, 0x01	; 1
    13ba:	10 40       	sbci	r17, 0x00	; 0
		FIFO_nRRST_CLR; //Reset Read Pointer
		FIFO_RCLK_SET;
		FIFO_RCLK_CLR;
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=HEIGHT; j > 0; j--) //Read all data 
    13bc:	11 f0       	breq	.+4      	; 0x13c2 <GetImageIfAvailiable+0x52>
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( int offset )
{
    13be:	e7 01       	movw	r28, r14
    13c0:	f7 cf       	rjmp	.-18     	; 0x13b0 <GetImageIfAvailiable+0x40>
// 			}
			//xprintf(PSTR("%d:Write File Result %d, pointer location %u\n"), j, f_write(&File[0], Buff, WIDTH * 2, &p), pointer);
		}
		/*f_close(&File);*/
		/*FIFO_Reset();*/
		FIFO_nRRST_CLR; //Reset Read Pointer	
    13c2:	47 98       	cbi	0x08, 7	; 8
		FIFO_RCLK_SET;
    13c4:	44 9a       	sbi	0x08, 4	; 8
		FIFO_RCLK_CLR;
    13c6:	44 98       	cbi	0x08, 4	; 8
		FIFO_nRRST_SET;
    13c8:	47 9a       	sbi	0x08, 7	; 8
		VSYNC_Count = 0; //No image present in buffer
    13ca:	10 92 a3 02 	sts	0x02A3, r1
    13ce:	10 92 a2 02 	sts	0x02A2, r1
// 		xprintf(PSTR("Success!\n"));
// 		xprintf(PSTR("Closing File: %d\n"), f_close(&File[0]));
		return 1; //Success!
    13d2:	81 e0       	ldi	r24, 0x01	; 1
    13d4:	01 c0       	rjmp	.+2      	; 0x13d8 <GetImageIfAvailiable+0x68>
	}
	else
	{
		return 0;// No image available
    13d6:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    13d8:	df 91       	pop	r29
    13da:	cf 91       	pop	r28
    13dc:	1f 91       	pop	r17
    13de:	0f 91       	pop	r16
    13e0:	ff 90       	pop	r15
    13e2:	ef 90       	pop	r14
    13e4:	08 95       	ret

000013e6 <TWI_Master_Initialise>:
		DDRC = 0x00;
		PORTC = (1 << PC0) | (1 << PC1);
	#else
		#pragma message("External I2C Pull Ups Required.")
	#endif
	TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
    13e6:	84 e3       	ldi	r24, 0x34	; 52
    13e8:	80 93 b8 00 	sts	0x00B8, r24
	// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
	TWDR = 0xFF;                                      // Default content = SDA released.
    13ec:	8f ef       	ldi	r24, 0xFF	; 255
    13ee:	80 93 bb 00 	sts	0x00BB, r24
	TWCR =	(1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
    13f2:	84 e0       	ldi	r24, 0x04	; 4
    13f4:	80 93 bc 00 	sts	0x00BC, r24
			(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
			(0<<TWWC);                                 //
}    
    13f8:	08 95       	ret

000013fa <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
    13fa:	80 91 bc 00 	lds	r24, 0x00BC
}
    13fe:	81 70       	andi	r24, 0x01	; 1
    1400:	08 95       	ret

00001402 <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
    1402:	0e 94 fd 09 	call	0x13fa	; 0x13fa <TWI_Transceiver_Busy>
    1406:	88 23       	and	r24, r24
    1408:	e1 f7       	brne	.-8      	; 0x1402 <TWI_Get_State_Info>
  return ( TWI_state );                         // Return error state.
}
    140a:	80 91 a1 02 	lds	r24, 0x02A1
    140e:	08 95       	ret

00001410 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
    1410:	0f 93       	push	r16
    1412:	1f 93       	push	r17
    1414:	cf 93       	push	r28
    1416:	8c 01       	movw	r16, r24
    1418:	c6 2f       	mov	r28, r22
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    141a:	0e 94 fd 09 	call	0x13fa	; 0x13fa <TWI_Transceiver_Busy>
    141e:	88 23       	and	r24, r24
    1420:	e1 f7       	brne	.-8      	; 0x141a <TWI_Start_Transceiver_With_Data+0xa>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
    1422:	c0 93 ab 02 	sts	0x02AB, r28
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
    1426:	f8 01       	movw	r30, r16
    1428:	80 81       	ld	r24, Z
    142a:	80 93 ac 02 	sts	0x02AC, r24
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
    142e:	80 fd       	sbrc	r24, 0
    1430:	0c c0       	rjmp	.+24     	; 0x144a <TWI_Start_Transceiver_With_Data+0x3a>
  {
    for ( temp = 1; temp < msgSize; temp++ )
    1432:	c2 30       	cpi	r28, 0x02	; 2
    1434:	50 f0       	brcs	.+20     	; 0x144a <TWI_Start_Transceiver_With_Data+0x3a>
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    1436:	d8 01       	movw	r26, r16
    1438:	11 96       	adiw	r26, 0x01	; 1

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    143a:	ed ea       	ldi	r30, 0xAD	; 173
    143c:	f2 e0       	ldi	r31, 0x02	; 2
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    143e:	81 e0       	ldi	r24, 0x01	; 1
  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
      TWI_buf[ temp ] = msg[ temp ];
    1440:	9d 91       	ld	r25, X+
    1442:	91 93       	st	Z+, r25

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    1444:	8f 5f       	subi	r24, 0xFF	; 255
    1446:	8c 17       	cp	r24, r28
    1448:	d9 f7       	brne	.-10     	; 0x1440 <TWI_Start_Transceiver_With_Data+0x30>
      TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
    144a:	10 92 aa 02 	sts	0x02AA, r1
  TWI_state         = TWI_NO_STATE ;
    144e:	88 ef       	ldi	r24, 0xF8	; 248
    1450:	80 93 a1 02 	sts	0x02A1, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    1454:	85 ea       	ldi	r24, 0xA5	; 165
    1456:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    145a:	cf 91       	pop	r28
    145c:	1f 91       	pop	r17
    145e:	0f 91       	pop	r16
    1460:	08 95       	ret

00001462 <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    1462:	0e 94 fd 09 	call	0x13fa	; 0x13fa <TWI_Transceiver_Busy>
    1466:	88 23       	and	r24, r24
    1468:	e1 f7       	brne	.-8      	; 0x1462 <TWI_Start_Transceiver>
  TWI_statusReg.all = 0;      
    146a:	10 92 aa 02 	sts	0x02AA, r1
  TWI_state         = TWI_NO_STATE ;
    146e:	88 ef       	ldi	r24, 0xF8	; 248
    1470:	80 93 a1 02 	sts	0x02A1, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    1474:	85 ea       	ldi	r24, 0xA5	; 165
    1476:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    147a:	08 95       	ret

0000147c <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    147c:	1f 93       	push	r17
    147e:	cf 93       	push	r28
    1480:	df 93       	push	r29
    1482:	d8 2f       	mov	r29, r24
    1484:	19 2f       	mov	r17, r25
    1486:	c6 2f       	mov	r28, r22
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    1488:	0e 94 fd 09 	call	0x13fa	; 0x13fa <TWI_Transceiver_Busy>
    148c:	88 23       	and	r24, r24
    148e:	e1 f7       	brne	.-8      	; 0x1488 <TWI_Get_Data_From_Transceiver+0xc>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    1490:	80 91 aa 02 	lds	r24, 0x02AA
    1494:	80 ff       	sbrs	r24, 0
    1496:	0d c0       	rjmp	.+26     	; 0x14b2 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    1498:	cc 23       	and	r28, r28
    149a:	59 f0       	breq	.+22     	; 0x14b2 <TWI_Get_Data_From_Transceiver+0x36>
    149c:	ac ea       	ldi	r26, 0xAC	; 172
    149e:	b2 e0       	ldi	r27, 0x02	; 2
    14a0:	9d 2f       	mov	r25, r29
    14a2:	ed 2f       	mov	r30, r29
    14a4:	f1 2f       	mov	r31, r17
    {
      msg[ i ] = TWI_buf[ i ];
    14a6:	8d 91       	ld	r24, X+
    14a8:	81 93       	st	Z+, r24

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    14aa:	8e 2f       	mov	r24, r30
    14ac:	89 1b       	sub	r24, r25
    14ae:	8c 17       	cp	r24, r28
    14b0:	d0 f3       	brcs	.-12     	; 0x14a6 <TWI_Get_Data_From_Transceiver+0x2a>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    14b2:	80 91 aa 02 	lds	r24, 0x02AA
}
    14b6:	81 70       	andi	r24, 0x01	; 1
    14b8:	df 91       	pop	r29
    14ba:	cf 91       	pop	r28
    14bc:	1f 91       	pop	r17
    14be:	08 95       	ret

000014c0 <__vector_26>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/

ISR(TWI_vect)
{
    14c0:	1f 92       	push	r1
    14c2:	0f 92       	push	r0
    14c4:	0f b6       	in	r0, 0x3f	; 63
    14c6:	0f 92       	push	r0
    14c8:	11 24       	eor	r1, r1
    14ca:	2f 93       	push	r18
    14cc:	3f 93       	push	r19
    14ce:	8f 93       	push	r24
    14d0:	9f 93       	push	r25
    14d2:	ef 93       	push	r30
    14d4:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    14d6:	80 91 b9 00 	lds	r24, 0x00B9
    14da:	88 32       	cpi	r24, 0x28	; 40
    14dc:	d1 f0       	breq	.+52     	; 0x1512 <__vector_26+0x52>
    14de:	89 32       	cpi	r24, 0x29	; 41
    14e0:	40 f4       	brcc	.+16     	; 0x14f2 <__vector_26+0x32>
    14e2:	80 31       	cpi	r24, 0x10	; 16
    14e4:	a1 f0       	breq	.+40     	; 0x150e <__vector_26+0x4e>
    14e6:	88 31       	cpi	r24, 0x18	; 24
    14e8:	a1 f0       	breq	.+40     	; 0x1512 <__vector_26+0x52>
    14ea:	88 30       	cpi	r24, 0x08	; 8
    14ec:	09 f0       	breq	.+2      	; 0x14f0 <__vector_26+0x30>
    14ee:	61 c0       	rjmp	.+194    	; 0x15b2 <__vector_26+0xf2>
    14f0:	0e c0       	rjmp	.+28     	; 0x150e <__vector_26+0x4e>
    14f2:	80 34       	cpi	r24, 0x40	; 64
    14f4:	b9 f1       	breq	.+110    	; 0x1564 <__vector_26+0xa4>
    14f6:	81 34       	cpi	r24, 0x41	; 65
    14f8:	20 f4       	brcc	.+8      	; 0x1502 <__vector_26+0x42>
    14fa:	88 33       	cpi	r24, 0x38	; 56
    14fc:	09 f0       	breq	.+2      	; 0x1500 <__vector_26+0x40>
    14fe:	59 c0       	rjmp	.+178    	; 0x15b2 <__vector_26+0xf2>
    1500:	54 c0       	rjmp	.+168    	; 0x15aa <__vector_26+0xea>
    1502:	80 35       	cpi	r24, 0x50	; 80
    1504:	19 f1       	breq	.+70     	; 0x154c <__vector_26+0x8c>
    1506:	88 35       	cpi	r24, 0x58	; 88
    1508:	09 f0       	breq	.+2      	; 0x150c <__vector_26+0x4c>
    150a:	53 c0       	rjmp	.+166    	; 0x15b2 <__vector_26+0xf2>
    150c:	3d c0       	rjmp	.+122    	; 0x1588 <__vector_26+0xc8>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    150e:	10 92 b0 02 	sts	0x02B0, r1
    case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    1512:	80 91 b0 02 	lds	r24, 0x02B0
    1516:	90 91 ab 02 	lds	r25, 0x02AB
    151a:	89 17       	cp	r24, r25
    151c:	70 f4       	brcc	.+28     	; 0x153a <__vector_26+0x7a>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    151e:	e8 2f       	mov	r30, r24
    1520:	f0 e0       	ldi	r31, 0x00	; 0
    1522:	e4 55       	subi	r30, 0x54	; 84
    1524:	fd 4f       	sbci	r31, 0xFD	; 253
    1526:	90 81       	ld	r25, Z
    1528:	90 93 bb 00 	sts	0x00BB, r25
    152c:	8f 5f       	subi	r24, 0xFF	; 255
    152e:	80 93 b0 02 	sts	0x02B0, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1532:	85 e8       	ldi	r24, 0x85	; 133
    1534:	80 93 bc 00 	sts	0x00BC, r24
    1538:	43 c0       	rjmp	.+134    	; 0x15c0 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    153a:	80 91 aa 02 	lds	r24, 0x02AA
    153e:	81 60       	ori	r24, 0x01	; 1
    1540:	80 93 aa 02 	sts	0x02AA, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1544:	84 e9       	ldi	r24, 0x94	; 148
    1546:	80 93 bc 00 	sts	0x00BC, r24
    154a:	3a c0       	rjmp	.+116    	; 0x15c0 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    154c:	80 91 b0 02 	lds	r24, 0x02B0
    1550:	90 91 bb 00 	lds	r25, 0x00BB
    1554:	e8 2f       	mov	r30, r24
    1556:	f0 e0       	ldi	r31, 0x00	; 0
    1558:	e4 55       	subi	r30, 0x54	; 84
    155a:	fd 4f       	sbci	r31, 0xFD	; 253
    155c:	90 83       	st	Z, r25
    155e:	8f 5f       	subi	r24, 0xFF	; 255
    1560:	80 93 b0 02 	sts	0x02B0, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    1564:	20 91 b0 02 	lds	r18, 0x02B0
    1568:	30 e0       	ldi	r19, 0x00	; 0
    156a:	80 91 ab 02 	lds	r24, 0x02AB
    156e:	90 e0       	ldi	r25, 0x00	; 0
    1570:	01 97       	sbiw	r24, 0x01	; 1
    1572:	28 17       	cp	r18, r24
    1574:	39 07       	cpc	r19, r25
    1576:	24 f4       	brge	.+8      	; 0x1580 <__vector_26+0xc0>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1578:	85 ec       	ldi	r24, 0xC5	; 197
    157a:	80 93 bc 00 	sts	0x00BC, r24
    157e:	20 c0       	rjmp	.+64     	; 0x15c0 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1580:	85 e8       	ldi	r24, 0x85	; 133
    1582:	80 93 bc 00 	sts	0x00BC, r24
    1586:	1c c0       	rjmp	.+56     	; 0x15c0 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    1588:	80 91 bb 00 	lds	r24, 0x00BB
    158c:	e0 91 b0 02 	lds	r30, 0x02B0
    1590:	f0 e0       	ldi	r31, 0x00	; 0
    1592:	e4 55       	subi	r30, 0x54	; 84
    1594:	fd 4f       	sbci	r31, 0xFD	; 253
    1596:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    1598:	80 91 aa 02 	lds	r24, 0x02AA
    159c:	81 60       	ori	r24, 0x01	; 1
    159e:	80 93 aa 02 	sts	0x02AA, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    15a2:	84 e9       	ldi	r24, 0x94	; 148
    15a4:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    15a8:	0b c0       	rjmp	.+22     	; 0x15c0 <__vector_26+0x100>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    15aa:	85 ea       	ldi	r24, 0xA5	; 165
    15ac:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    15b0:	07 c0       	rjmp	.+14     	; 0x15c0 <__vector_26+0x100>
    case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    15b2:	80 91 b9 00 	lds	r24, 0x00B9
    15b6:	80 93 a1 02 	sts	0x02A1, r24
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    15ba:	84 e0       	ldi	r24, 0x04	; 4
    15bc:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    15c0:	ff 91       	pop	r31
    15c2:	ef 91       	pop	r30
    15c4:	9f 91       	pop	r25
    15c6:	8f 91       	pop	r24
    15c8:	3f 91       	pop	r19
    15ca:	2f 91       	pop	r18
    15cc:	0f 90       	pop	r0
    15ce:	0f be       	out	0x3f, r0	; 63
    15d0:	0f 90       	pop	r0
    15d2:	1f 90       	pop	r1
    15d4:	18 95       	reti

000015d6 <__mulsi3>:
    15d6:	62 9f       	mul	r22, r18
    15d8:	d0 01       	movw	r26, r0
    15da:	73 9f       	mul	r23, r19
    15dc:	f0 01       	movw	r30, r0
    15de:	82 9f       	mul	r24, r18
    15e0:	e0 0d       	add	r30, r0
    15e2:	f1 1d       	adc	r31, r1
    15e4:	64 9f       	mul	r22, r20
    15e6:	e0 0d       	add	r30, r0
    15e8:	f1 1d       	adc	r31, r1
    15ea:	92 9f       	mul	r25, r18
    15ec:	f0 0d       	add	r31, r0
    15ee:	83 9f       	mul	r24, r19
    15f0:	f0 0d       	add	r31, r0
    15f2:	74 9f       	mul	r23, r20
    15f4:	f0 0d       	add	r31, r0
    15f6:	65 9f       	mul	r22, r21
    15f8:	f0 0d       	add	r31, r0
    15fa:	99 27       	eor	r25, r25
    15fc:	72 9f       	mul	r23, r18
    15fe:	b0 0d       	add	r27, r0
    1600:	e1 1d       	adc	r30, r1
    1602:	f9 1f       	adc	r31, r25
    1604:	63 9f       	mul	r22, r19
    1606:	b0 0d       	add	r27, r0
    1608:	e1 1d       	adc	r30, r1
    160a:	f9 1f       	adc	r31, r25
    160c:	bd 01       	movw	r22, r26
    160e:	cf 01       	movw	r24, r30
    1610:	11 24       	eor	r1, r1
    1612:	08 95       	ret

00001614 <__divmodsi4>:
    1614:	97 fb       	bst	r25, 7
    1616:	09 2e       	mov	r0, r25
    1618:	05 26       	eor	r0, r21
    161a:	0e d0       	rcall	.+28     	; 0x1638 <__divmodsi4_neg1>
    161c:	57 fd       	sbrc	r21, 7
    161e:	04 d0       	rcall	.+8      	; 0x1628 <__divmodsi4_neg2>
    1620:	14 d0       	rcall	.+40     	; 0x164a <__udivmodsi4>
    1622:	0a d0       	rcall	.+20     	; 0x1638 <__divmodsi4_neg1>
    1624:	00 1c       	adc	r0, r0
    1626:	38 f4       	brcc	.+14     	; 0x1636 <__divmodsi4_exit>

00001628 <__divmodsi4_neg2>:
    1628:	50 95       	com	r21
    162a:	40 95       	com	r20
    162c:	30 95       	com	r19
    162e:	21 95       	neg	r18
    1630:	3f 4f       	sbci	r19, 0xFF	; 255
    1632:	4f 4f       	sbci	r20, 0xFF	; 255
    1634:	5f 4f       	sbci	r21, 0xFF	; 255

00001636 <__divmodsi4_exit>:
    1636:	08 95       	ret

00001638 <__divmodsi4_neg1>:
    1638:	f6 f7       	brtc	.-4      	; 0x1636 <__divmodsi4_exit>
    163a:	90 95       	com	r25
    163c:	80 95       	com	r24
    163e:	70 95       	com	r23
    1640:	61 95       	neg	r22
    1642:	7f 4f       	sbci	r23, 0xFF	; 255
    1644:	8f 4f       	sbci	r24, 0xFF	; 255
    1646:	9f 4f       	sbci	r25, 0xFF	; 255
    1648:	08 95       	ret

0000164a <__udivmodsi4>:
    164a:	a1 e2       	ldi	r26, 0x21	; 33
    164c:	1a 2e       	mov	r1, r26
    164e:	aa 1b       	sub	r26, r26
    1650:	bb 1b       	sub	r27, r27
    1652:	fd 01       	movw	r30, r26
    1654:	0d c0       	rjmp	.+26     	; 0x1670 <__udivmodsi4_ep>

00001656 <__udivmodsi4_loop>:
    1656:	aa 1f       	adc	r26, r26
    1658:	bb 1f       	adc	r27, r27
    165a:	ee 1f       	adc	r30, r30
    165c:	ff 1f       	adc	r31, r31
    165e:	a2 17       	cp	r26, r18
    1660:	b3 07       	cpc	r27, r19
    1662:	e4 07       	cpc	r30, r20
    1664:	f5 07       	cpc	r31, r21
    1666:	20 f0       	brcs	.+8      	; 0x1670 <__udivmodsi4_ep>
    1668:	a2 1b       	sub	r26, r18
    166a:	b3 0b       	sbc	r27, r19
    166c:	e4 0b       	sbc	r30, r20
    166e:	f5 0b       	sbc	r31, r21

00001670 <__udivmodsi4_ep>:
    1670:	66 1f       	adc	r22, r22
    1672:	77 1f       	adc	r23, r23
    1674:	88 1f       	adc	r24, r24
    1676:	99 1f       	adc	r25, r25
    1678:	1a 94       	dec	r1
    167a:	69 f7       	brne	.-38     	; 0x1656 <__udivmodsi4_loop>
    167c:	60 95       	com	r22
    167e:	70 95       	com	r23
    1680:	80 95       	com	r24
    1682:	90 95       	com	r25
    1684:	9b 01       	movw	r18, r22
    1686:	ac 01       	movw	r20, r24
    1688:	bd 01       	movw	r22, r26
    168a:	cf 01       	movw	r24, r30
    168c:	08 95       	ret

0000168e <_exit>:
    168e:	f8 94       	cli

00001690 <__stop_program>:
    1690:	ff cf       	rjmp	.-2      	; 0x1690 <__stop_program>
